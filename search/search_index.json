{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"plankapy","text":"<p>A Python API for Planka</p> <p></p> <p> </p> <p> </p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install plankapy\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>The full documentation can be found here.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>After pip installing, you can connect to a Planka instance using a Planka interface object</p> <p><pre><code>from plankapy.v2 import Planka\n\nplanka = Planka('https://planka.mydomain.com')\n</code></pre> After creating the Planka instance, you can authenticate using the <code>login</code> method: <pre><code>planka.login(username='username', password='password')\n-- OR --\nplanka.login(api_key='MY_API_KEY')\n</code></pre></p> <p>Logging in for the first time required accepting the instance ToS. Consult with your instance admin on avalable ToS localizations and required ToS types for your user. <pre><code>planka.login(username=..., password=..., accept_terms=True)\n\n-- With Language --\nplanka.login(username=..., password=..., accept_terms=True, lang='ja-JP')\n\n-- Specific ToS --\nplanka.login(username=..., password=..., accept_terms=True, terms_type='extended')\n</code></pre> Now that you've authenticated with the server, you have access to everything that you'd be able to access through the web-ui</p> <pre><code>&gt;&gt;&gt; planka.me\nUser({...})\n&gt;&gt;&gt; planka.projects\n[Project({...}), Project({...}), ...]\n</code></pre>"},{"location":"#features","title":"Features","text":""},{"location":"#fully-typed","title":"Fully Typed","text":"<p>Interfaces for all planka objects are fully documented and typed in the source, so if you are using an IDE that supports a python language server you will get full autocompletion. </p> <p>All methods are fully documented using doctrings and contain all info needed to properly form a function call: </p> <p>Since all objects are initialized as a series of endpoints with a local <code>schema</code> cache, it allows you to access any object from any other object in the tree without ever losing track of what you have: </p> <p>All endpoints and schemas are documeted using <code>TypedDict</code> syntax, so you can safely create raw API calls using the <code>PlankaEndpoints</code> object: </p> <p>All responses are fully typed as well:  </p>"},{"location":"#note","title":"NOTE:","text":"<p>When using plankapy it is reccommended to turn your type checker settings to the strictest mode possible. Since most interfaces forego runtime checks for extensive type hints. </p>"},{"location":"#model-lists","title":"Model Lists","text":"<p>When reading the published docs, all property attributes that are typed as <code>list[&lt;PlankaModel[T]&gt;]</code> will be converted to <code>ModelList</code> at runtime. This list subclass can be used like a regulat list, bu allows indexing and filtering using <code>__getitem__</code> syntax</p>"},{"location":"#intslice","title":"<code>int/slice</code>","text":"<p>Since <code>ModelList</code> subclasses list, all regular list interfaces still work: <pre><code>&gt;&gt;&gt; board.cards[-1]\nCard({...})\n&gt;&gt;&gt; board.cards[:2]\n[Card({...}), Card({})]\n</code></pre></p>"},{"location":"#strid","title":"<code>str/Id</code>","text":"<p>If a string is used to index a model list, the last model with the matching id is popped. If the id does not exist, the exception raised will be the same as popping from an empty list <pre><code>&gt;&gt;&gt; my_card_id = '...'\n&gt;&gt;&gt; board.cards[my_card_id]\nCard({'id': '...'})\n</code></pre></p>"},{"location":"#schemafilterdict","title":"<code>SchemaFilter/dict</code>","text":"<p>If you want to define a filter on the model schema, you can pass a dictionary of schema values or expressions to the index: <pre><code>&gt;&gt;&gt; board.cards[{'name': 'My Card'}]\n[Card({'name': 'My Card'})]\n\n&gt;&gt;&gt; board.cards[{'name': lambda name: 'My' in name}]\n[Card({'name': 'My Card'}), Card({'name': 'My Other Card'})]\n</code></pre></p>"},{"location":"#modelfilter","title":"<code>ModelFilter</code>","text":"<p>You can also specify a raw expression to filter the list: <pre><code>&gt;&gt;&gt; board.cards[lambda card: planka.me in card.members]\n</code></pre></p>"},{"location":"#model","title":"<code>Model</code>","text":"<p>You can also direcly pass a Model to the index. The returned result is another ModelList that can be <code>dpop</code>'ed to check for membership <pre><code>&gt;&gt;&gt; board.users[planka.me].dpop()\nNone # Not in board\n</code></pre></p>"},{"location":"#extract","title":"<code>extract</code>","text":"<p>Model lists also allow schema extraction using the <code>extract</code> method. If a single key is passed, a list of values is returned. If multiple keys are passed, a list of tuples of values is returned <pre><code>&gt;&gt;&gt; board.cards.extract('name')\n['My Card', 'My Other Card']\n&gt;&gt;&gt; board.card.extract('name', 'dueDate')\n[('My Card', None), ('My Other Card', '2026...')]\n</code></pre></p>"},{"location":"#dpop","title":"<code>dpop</code>","text":"<p>A way to safely pop from the model list. Has the same interface as <code>list.pop</code> but accepts a <code>default</code> keyword argument which is det to <code>None</code> when not set by the user: <pre><code>&gt;&gt;&gt; board.lists[0].pop(0)\nIndexError...\n&gt;&gt;&gt; board.lists[0].dpop(0, 'Empty')\n'Empty'\n</code></pre></p>"},{"location":"#live-updates","title":"Live Updates","text":"<p>Every model contains a <code>schema</code> cache attribute that is used for direct attribute access. This means that checking the value of <code>name</code> for a card will not change until <code>sync</code> is called <pre><code>&gt;&gt;&gt; card = board.cards[{'name': 'My Card'}].dpop()\n&gt;&gt;&gt; card.name\n'My Card'\n\n# Change Name on server to 'Not My Card'\n&gt;&gt;&gt; card.name\n'My Card'\n&gt;&gt;&gt; card.sync()\n&gt;&gt;&gt; card.name\n'Not My Card'\n</code></pre> If you want your functions to maintain sync with the server, you access the card via other endpoints. All properties that return item lists will re-construct themselves from the response when accessed</p> <p><pre><code>&gt;&gt;&gt; card = lambda: board.cards[0]\n&gt;&gt;&gt; card().name\n'My Card'\n\n# Change Name on server to 'Not My Card'\n&gt;&gt;&gt; card().name\n'Not My Card'\n</code></pre> This example aliases a request chain to a callable lambda function. You can also just use the full desired request path too <pre><code>&gt;&gt;&gt; board.cards[0].name\n'My Card'\n\n# Change Name on server to 'Not My Card'\n&gt;&gt;&gt; board.cards[0].name\n'Not My Card'\n</code></pre> NOTE: This specific structure is written to always get the first card in the board. This could be useful, but you will usually want to apply a specific filter. </p>"},{"location":"#attribute-access-in-loops","title":"Attribute access in Loops","text":"<p>Since extended calls can fire off multiple requests to keep data synced, if you have a tight/hot loop that is accessing a lot of object attributes, it's best to explicitly use the schema cache: <pre><code>&gt;&gt;&gt; all_cards = ModelList()\n&gt;&gt;&gt; for project in planka.projects:\n...     for board in project.boards:\n...         all_cards.extend(board.cards)\n\n&gt;&gt;&gt; print(all_cards.extract('name'))\n['My Card', ...]\n</code></pre> Now you have an <code>all_cards</code> model list that contains the endpoints and a cache of all cards in your visible projects.</p> <p>If you don't need the models at the end of the loop, you can instead just capture values: <pre><code>&gt;&gt;&gt; card_due_dates = []\n&gt;&gt;&gt; for project in planka.projects:\n...     for board in project.boards:\n...         card_due_dates.extend(board.cards.extract('name', 'dueDate'))\n\n&gt;&gt;&gt; print(card_due_dates)\n[('My Card', '2026...'), ('Other Card', None), ...]\n</code></pre></p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the AGPLv3 License - see the LICENSE file for details.</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#busybox","title":"Busybox","text":"<p>A simple little script that initializes several users and boards and changes values on cards <pre><code>from datetime import datetime, timedelta, timezone\nfrom plankapy.v2 import Planka\nfrom plankapy.v2.models import *\nfrom plankapy.v2.models import UserRole\nfrom httpx import Client, HTTPStatusError\nfrom random import choice, shuffle\n\ndef reset_planka(planka: Planka):\n    for project in planka.projects:\n        for board in project.boards:\n            board.delete()\n        project.delete()\n    for user in planka.users:\n        if user != planka.me:\n            user.delete()\n\ndef create_projects(planka: Planka, *prj_names: str):\n    return {\n        name: planka.create_project(name=name, type='shared')\n        for name in prj_names\n    }\n\ndef create_boards(prj: Project, *board_names: str):\n    return {\n        name: prj.create_board(\n            name=name, \n            position=pos*16384\n        ) \n        for pos, name in enumerate(board_names, start=1)\n    }\n\ndef create_lists(brd: Board, *list_names: str):\n    return {\n        name: brd.create_list(\n            name=name, \n            position=pos*16384, \n            type='active'\n        ) \n        for pos, name in enumerate(list_names, start=1)\n    }\n\ndef create_users(*usernames: str, role: UserRole='admin'):\n    return {\n        name: planka.create_user(\n            name=name, \n            email=name+'@company.org', \n            role=role, \n            password=name+'12345'\n        ) \n        for name in usernames\n    }\n\ndef create_cards(list: List, *card_names: str):\n    return {\n        name: list.create_card(\n            type='project', \n            position=pos*16384, \n            name=name\n        )\n        for pos, name in enumerate(card_names, start=1)\n    }\n\ndef create_labels(board: Board, *label_names: str):\n    return {\n        name: board.create_label(\n            name=name, \n            position=pos*16384, \n            color=choice(LabelColors)\n        )\n        for pos, name in enumerate(label_names, start=1)\n    }\n\nif __name__ == '__main__':\n\n    # Initialize a Planka instance using Demo user\n    client = Client(base_url='http://localhost:1337')\n    planka = Planka(client)\n    planka.logon(username='demo', password='demo')\n\n    # Objects to create\n    projects = ['Project 1', 'Project 2', 'Project 3']\n    users = ['user1', 'user2', 'user3']\n    lists = ['To Do', 'Doing', 'Review', 'Done']\n    labels = ['Overdue', 'On Schedule']\n    boards = ['Fontend', 'Backend']\n    cards = [f'Task {i}'for i in range(1,11)]\n    base_fields = {\n        'Group 1': ['field a', 'field b'], \n        'Group 2': ['field c', 'field d']\n    }\n\n    reset_planka(planka)\n\n    # Build a Framework\n    print('Creating Projects')\n    create_projects(planka, *projects)\n    print('Creating Users')\n    create_users(*users)\n    for project in planka.projects:\n        print(f'Creating Boards in {project.name}')\n        create_boards(project, *boards)\n        for bcfg_name, bcfg_fields in base_fields.items():\n            bcfg = project.create_base_custom_field_group(name=bcfg_name)\n            for pos, field in enumerate(bcfg_fields, start=1):\n                bcfg.create_field(\n                    name=field, \n                    position=16636*pos, \n                    showOnFrontOfCard=True\n                )\n        for board in project.boards:\n            print(f'\\tCreating Lists in {board.name}')\n            create_lists(board, *lists)\n            print(f'\\tCreating Labels in {board.name}')\n            create_labels(board, *labels)\n            print(f'\\tCreating Cards in {board.name}')\n            create_cards(board.active_lists[0], *cards)\n            print(f'\\tAdding Members to {board.name}')\n            board.add_members(planka.users, role='editor')\n\n    # Just kinda move stuff around randomly\n    for project in planka.projects:\n        project.background_gradient = choice(BackgroundGradients)\n        for board in project.boards:\n            overdue = board.labels[{'name': 'Overdue'}].dpop()\n            on_schedule = board.labels[{'name': 'On Schedule'}].dpop()\n\n            cards = board.cards\n            shuffle(cards)\n            for card in cards:\n                user = choice(board.users)\n                to_list = choice(board.active_lists)\n                print(\n                    f'{project.name}-&gt;{board.name}: Moving Card {card.name} '\n                    f'from List {card.list.name} To List {to_list.name}')\n                card.move(to_list, position='bottom')\n                for member in card.members:\n                    card.remove_member(member)\n                user.add_to_card(card)\n\n                # Pick a Due Date then do datemath to warn user of overdue cards and set labels\n                dur_day_delta = choice([-3, -2, -1, 0, 1, 2, 3])\n                card.due_date = (\n                    datetime.now() + timedelta(days=due_day_delta)\n                )\n                due_in = card.due_date - datetime.now().replace(tzinfo=card.due_date.tzinfo)\n                if card.due_date.timestamp() &gt; datetime.now(tz=timezone.utc).timestamp():\n                    print(f'Card: {card.name} is due in {due_in.days} days')\n                    card.remove_label(overdue)\n                    card.add_label(on_schedule)\n                else:\n                    print(f'WARNING Card: {card.name} is overdue by {due_in.days} days!')\n                    card.remove_label(on_schedule)\n                    card.add_label(overdue)\n</code></pre></p>"},{"location":"v1/examples/","title":"Examples","text":""},{"location":"v1/auth/BaseAuth/","title":"Base Auth","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"v1/auth/PasswordAuth/","title":"PasswordAuth","text":"<p>               Bases: <code>BaseAuth</code></p> <p>Authentication using a username or email and password</p> ATTRIBUTE DESCRIPTION <code>endpoint</code> <p>The token to use for authentication (default: 'api/access-tokens')</p> <p> TYPE: <code>str</code> </p> <p>Initialize a PasswordAuth instance with a username or email and password</p> PARAMETER DESCRIPTION <p>The username or email to use for authentication</p> <p> TYPE: <code>str</code> </p> <p>The password to use for authentication</p> <p> TYPE: <code>str</code> </p> Example <pre><code>&gt;&gt;&gt; auth = PasswordAuth('username', 'password')\n&gt;&gt;&gt; auth.authenticate('http://planka.instance')\n{'Authorization' : 'Bearer &lt;token&gt;'}\n</code></pre> METHOD DESCRIPTION <code>authenticate</code> <p>Implementation of the authenticate method</p> Source code in <code>src/plankapy/v1/handlers.py</code> <pre><code>def __init__(self, username_or_email: str, password: str) -&gt; None:\n    \"\"\"Initialize a PasswordAuth instance with a username or email and password\n\n    Args:\n        username_or_email (str): The username or email to use for authentication\n        password (str): The password to use for authentication\n\n    Example:\n        ```python\n        &gt;&gt;&gt; auth = PasswordAuth('username', 'password')\n        &gt;&gt;&gt; auth.authenticate('http://planka.instance')\n        {'Authorization' : 'Bearer &lt;token&gt;'}\n        ```    \n    \"\"\"\n    self.token = None\n    self.credentials = {\n        'emailOrUsername': username_or_email,\n        'password': password\n    }\n</code></pre>"},{"location":"v1/auth/PasswordAuth/#plankapy.v1.handlers.PasswordAuth(username_or_email)","title":"<code>username_or_email</code>","text":""},{"location":"v1/auth/PasswordAuth/#plankapy.v1.handlers.PasswordAuth(password)","title":"<code>password</code>","text":""},{"location":"v1/auth/PasswordAuth/#plankapy.v1.handlers.PasswordAuth.authenticate","title":"authenticate","text":"<pre><code>authenticate(url: str) -&gt; dict[str, str]\n</code></pre> <p>Implementation of the authenticate method</p> PARAMETER DESCRIPTION <p>The base url of the Planka instance</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict[str, str]</code> <p>Headers with the token in the <code>Authorization</code> key</p> Source code in <code>src/plankapy/v1/handlers.py</code> <pre><code>def authenticate(self, url: str) -&gt; dict[str, str]:\n    \"\"\"Implementation of the authenticate method\n\n    Args:\n        url (str): The base url of the Planka instance\n\n    Returns:\n        Headers with the token in the `Authorization` key\n    \"\"\"\n    self.token = JSONHandler(url, endpoint=self.endpoint).post(self.credentials)['item']\n    return {\"Authorization\": f\"Bearer {self.token}\"}\n</code></pre>"},{"location":"v1/auth/PasswordAuth/#plankapy.v1.handlers.PasswordAuth.authenticate(url)","title":"<code>url</code>","text":""},{"location":"v1/auth/TokenAuth/","title":"TokenAuth","text":"<p>               Bases: <code>BaseAuth</code></p> <p>Authentication using a pre-supplied token</p> ATTRIBUTE DESCRIPTION <code>endpoint</code> <p>The token to use for authentication (default: 'api/access-tokens')</p> <p> TYPE: <code>str</code> </p> Example <pre><code>&gt;&gt;&gt; auth = TokenAuth('&lt;token&gt;')\n&gt;&gt;&gt; auth.authenticate()\n{'Authorization : 'Bearer &lt;token&gt;'}\n</code></pre> <p>Initialize a TokenAuth instance with a token</p> PARAMETER DESCRIPTION <p>The token to use for authentication</p> <p> TYPE: <code>str</code> </p> METHOD DESCRIPTION <code>authenticate</code> <p>Implementation of the authenticate method</p> Source code in <code>src/plankapy/v1/handlers.py</code> <pre><code>def __init__(self, token: str) -&gt; None:\n    \"\"\"Initialize a TokenAuth instance with a token\n\n    Args:\n        token (str): The token to use for authentication\n    \"\"\"\n    self.token = token\n</code></pre>"},{"location":"v1/auth/TokenAuth/#plankapy.v1.handlers.TokenAuth(token)","title":"<code>token</code>","text":""},{"location":"v1/auth/TokenAuth/#plankapy.v1.handlers.TokenAuth.authenticate","title":"authenticate","text":"<pre><code>authenticate(url: str = None) -&gt; dict[str, str]\n</code></pre> <p>Implementation of the authenticate method</p> PARAMETER DESCRIPTION <p>Not used, but required by the protocol</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>dict[str, str]</code> <p>Headers with the token in the <code>Authorization</code> key</p> Source code in <code>src/plankapy/v1/handlers.py</code> <pre><code>def authenticate(self, url: str=None) -&gt; dict[str, str]:\n    \"\"\"Implementation of the authenticate method\n\n    Args:\n        url (str): Not used, but required by the protocol\n\n    Returns:\n       Headers with the token in the `Authorization` key\n    \"\"\"\n    return {\"Authorization\": f\"Bearer {self.token}\"}\n</code></pre>"},{"location":"v1/auth/TokenAuth/#plankapy.v1.handlers.TokenAuth.authenticate(url)","title":"<code>url</code>","text":""},{"location":"v1/cli/cli/","title":"COMING SOON ?","text":""},{"location":"v1/constants/constants/","title":"Constants","text":""},{"location":"v1/constants/constants/#actiontype","title":"ActionType","text":"<p><code>createCard</code> <code>moveCard</code> <code>commentCard</code></p>"},{"location":"v1/constants/constants/#boardrole","title":"BoardRole","text":"<p><code>editor</code> <code>viewer</code></p>"},{"location":"v1/constants/constants/#sort-options","title":"Sort Options","text":"<p><code>Name</code> <code>Due date</code> <code>Oldest First</code> <code>Newest First</code></p>"},{"location":"v1/constants/constants/#label-colors","title":"Label Colors","text":"Name Hex  berry-red  #c0392b  pumpkin-orange  #f0982d  lagoon-blue  #109dc0  pink-tulip  #f97394  light-mud  #c7a57b  orange-peel  #fab623  bright-moss  #a5c261  antique-blue  #6c99bb  dark-granite  #8b8680  lagune-blue  #00b4b1  sunny-grass  #bfca02  morning-sky  #52bad5  light-orange  #ffc66d  midnight-blue  #004d73  tank-green  #8aa177  gun-metal  #355263  wet-moss  #4a8753  red-burgundy  #ad5f7d  light-concrete  #afb0a4  apricot-red  #fc736d  desert-sand  #edcb76  navy-blue  #166a8f  egg-yellow  #f7d036  coral-green  #2b6a6c  light-cocoa  #87564a"},{"location":"v1/constants/constants/#project-gradients","title":"Project Gradients","text":"<p>Note: Some of these gradients are not supported currently, but I've included them here because they are defined in the planka codebase.</p> Name CSS  ocean-dive  <code>linear-gradient(to top, #062e53, #1ad0e0)</code>  old-lime  <code>linear-gradient(to bottom, #7b920a, #add100)</code>  tzepesch-style  <code>linear-gradient(to bottom, #190a05, #870000)</code>  jungle-mesh  <code>linear-gradient(to bottom, #727a17, #414d0b)</code>  blue-danube  <code>radial-gradient(circle, rgba(9, 9, 121, 1) 0%, rgba(2, 0, 36, 1) 0%, rgba(2, 29, 66, 1) 0%, rgba(2, 41, 78, 1) 0%, rgba(2, 57, 95, 1) 0%, rgba(1, 105, 144, 1) 100%, rgba(1, 151, 192, 1) 100%, rgba(0, 212, 255, 1) 100%)</code>  sundown-stripe  <code>linear-gradient(22deg, rgba(31, 30, 30, 1) 0%, rgba(255, 128, 0, 1) 10%, rgba(255, 128, 0, 1) 41%, rgba(0, 0, 0, 1) 41%, rgba(0, 102, 204, 1) 89%)</code>  magical-dawn  <code>radial-gradient(circle, rgba(0, 107, 141, 1) 0%, rgba(0, 69, 91, 1) 90%)</code>  strawberry-dust  <code>linear-gradient(180deg, rgba(172, 79, 115, 1) 0%, rgba(254, 158, 150, 1) 66%)</code>  purple-rose  <code>linear-gradient(128deg, rgba(116, 43, 62, 1) 19%, rgba(192, 71, 103, 1) 90%)</code>  sun-scream  <code>linear-gradient(112deg, rgba(251, 221, 19, 1) 19%, rgba(255, 153, 1, 1) 62%)</code>  warm-rust  <code>linear-gradient(141deg, rgba(255, 90, 8, 1) 0%, rgba(88, 0, 0, 1) 96%)</code>  sky-change  <code>linear-gradient(135deg, rgba(0, 52, 89, 1) 0%, rgba(0, 168, 232, 1) 90%)</code>  green-eyes  <code>linear-gradient(138deg, rgba(19, 170, 82, 1) 0%, rgba(0, 102, 43, 1) 90%)</code>  blue-xchange  <code>radial-gradient(circle, #294f83, #162c4a)</code>  blood-orange  <code>linear-gradient(360deg, #d64759 10%, #da7352 360%)</code>  sour-peel  <code>linear-gradient(360deg, #fd6f46 10%, #fb9832 360%)</code>  green-ninja  <code>linear-gradient(360deg, #224e4d 10%, #083023 360%)</code>  ice-blue  <code>linear-gradient(360deg, #38aecc 10%, #347fb9 360%)</code>  epic-green  <code>linear-gradient(360deg, #01a99c 10%, #0698b1 360%)</code>  algae-green  <code>radial-gradient(circle farthest-corner at 10% 20%, rgba(0, 95, 104, 1) 0%, rgba(15, 156, 168, 1) 90%)</code>  coral-reef  <code>linear-gradient(110.3deg, rgba(238, 179, 123, 1) 8.7%, rgba(216, 103, 77, 1) 47.5%, rgba(238, 179, 123, 1) 100%)</code>  wow-blue  <code>linear-gradient(111.8deg, rgba(0, 104, 155, 1) 19.8%, rgba(0, 173, 239, 1) 92.1%)</code>  velvet-lounge  <code>radial-gradient(circle farthest-corner at 10% 20%, rgba(151, 10, 130, 1) 0%, rgba(33, 33, 33, 1) 100.2%)</code>  lagoon  <code>radial-gradient(circle farthest-corner at 10% 20%, rgba(0, 107, 141, 1) 0%, rgba(0, 69, 91, 1) 90%)</code>  purple-rain  <code>linear-gradient(91.7deg, rgba(50, 25, 79, 1) -4.3%, rgba(122, 101, 149, 1) 101.8%)</code>  blue-steel  <code>linear-gradient(to top, #09203f 0%, #537895 100%)</code>  blueish-curve  <code>linear-gradient(171.8deg, rgba(5, 111, 146, 1) 13.5%, rgba(6, 57, 84, 1) 78.6%)</code>  prism-light  <code>linear-gradient(111.7deg, rgba(251, 198, 6, 1) 2.4%, rgba(224, 82, 95, 1) 28.3%, rgba(194, 78, 154, 1) 46.2%, rgba(32, 173, 190, 1) 79.4%, rgba(22, 158, 95, 1) 100.2%)</code>  the-bow  <code>radial-gradient(circle farthest-corner at -8.9% 51.2%, rgba(255, 124, 0, 1) 0%, rgba(255, 124, 0, 1) 15.9%, rgba(255, 163, 77, 1) 15.9%, rgba(255, 163, 77, 1) 24.4%, rgba(19, 30, 37, 1) 24.5%, rgba(19, 30, 37, 1) 66%)</code>  green-mist  <code>linear-gradient(180.5deg, rgba(0, 128, 128, 1) 8.5%, rgba(174, 206, 100, 1) 118.2%)</code>  red-curtain  <code>radial-gradient(circle 371px at 2.9% 14.3%, rgba(255, 0, 102, 1) 0%, rgba(80, 5, 35, 1) 100.7%)</code>  steel-grey  <code>radial-gradient(circle farthest-corner at -4% -12.9%, rgba(74, 98, 110, 1) 0.3%, rgba(30, 33, 48, 1) 90.2%)</code>"},{"location":"v1/helpers/helpers/","title":"Helpers","text":"FUNCTION DESCRIPTION <code>add_editors_to_board</code> <p>Add users to a board with editing permissions</p> <code>add_labels_to_card</code> <p>Add labels to a card</p> <code>add_members_to_card</code> <p>Add members to a card</p> <code>add_viewers_to_board</code> <p>Add users to a board with viewing permissions</p> <code>by_action_type</code> <p>Get actions by type</p> <code>by_board_name</code> <p>Get boards by name</p> <code>by_card_name</code> <p>Get cards by name</p> <code>by_label_name</code> <p>Get labels by name</p> <code>by_list_name</code> <p>Get lists by name</p> <code>by_project_name</code> <p>Get projects by name</p> <code>by_username</code> <p>Get users by username</p> <code>create_board_labels</code> <p>Create labels on a board</p> <code>delete_actions</code> <p>Delete a list of actions</p> <code>delete_boards</code> <p>Delete a list of boards</p> <code>delete_cards</code> <p>Delete a list of cards</p> <code>delete_labels</code> <p>Delete a list of labels</p> <code>delete_lists</code> <p>Delete a list of lists</p> <code>delete_projects</code> <p>Delete a list of projects</p> <code>delete_users</code> <p>Delete a list of users</p> <code>get_boards_by_name</code> <p>Get all boards in a project by name</p> <code>get_cards_by_name</code> <p>Get a card by name from a list or board</p> <code>get_labels_by_name</code> <p>Get a label by name from a board or card</p> <code>get_lists_by_name</code> <p>Get all lists in a board by name</p> <code>get_projects_by_name</code> <p>Get all projects with the given name</p> <code>get_users_by_username</code> <p>Get a user by username from a Planka Instance, Project, or Board</p> <code>remove_labels_from_card</code> <p>Remove labels from a card</p>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.add_editors_to_board","title":"add_editors_to_board","text":"<pre><code>add_editors_to_board(board: Board, users: list[User]) -&gt; list[BoardMembership]\n</code></pre> <p>Add users to a board with editing permissions</p> PARAMETER DESCRIPTION <p>Board to add users to</p> <p> TYPE: <code>Board</code> </p> <p>Users to add</p> <p> TYPE: <code>list[User]</code> </p> RETURNS DESCRIPTION <code>Board</code> <p>Board with users added</p> <p> TYPE: <code>list[BoardMembership]</code> </p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def add_editors_to_board(board: Board, users: list[User]) -&gt; list[BoardMembership]:\n    \"\"\"Add users to a board with editing permissions\n\n    Args:\n        board (Board): Board to add users to\n        users (list[User]): Users to add\n\n    Returns:\n        Board: Board with users added\n    \"\"\"\n    return [board.add_user(users, canComment=True) for user in users]\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.add_editors_to_board(board)","title":"<code>board</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.add_editors_to_board(users)","title":"<code>users</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.add_labels_to_card","title":"add_labels_to_card","text":"<pre><code>add_labels_to_card(card: Card, labels: list[Label]) -&gt; list[CardLabel]\n</code></pre> <p>Add labels to a card</p> PARAMETER DESCRIPTION <p>Card to add labels to</p> <p> TYPE: <code>Card</code> </p> <p>Labels to add</p> <p> TYPE: <code>list[Label]</code> </p> RETURNS DESCRIPTION <code>list[CardLabel]</code> <p>list[CardLabel]: CardLabel relationships created</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def add_labels_to_card(card: Card, labels: list[Label]) -&gt; list[CardLabel]:\n    \"\"\"Add labels to a card\n\n    Args:\n        card (Card): Card to add labels to\n        labels (list[Label]): Labels to add\n\n    Returns:\n        list[CardLabel]: CardLabel relationships created\n    \"\"\"\n    return [card.add_label(label) for label in labels]\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.add_labels_to_card(card)","title":"<code>card</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.add_labels_to_card(labels)","title":"<code>labels</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.add_members_to_card","title":"add_members_to_card","text":"<pre><code>add_members_to_card(card: Card, members: list[User]) -&gt; list[CardMembership]\n</code></pre> <p>Add members to a card</p> PARAMETER DESCRIPTION <p>Card to add members to</p> <p> TYPE: <code>Card</code> </p> <p>Members to add</p> <p> TYPE: <code>list[User]</code> </p> RETURNS DESCRIPTION <code>list[CardMembership]</code> <p>list[CardMembership]: CardMemberships created</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def add_members_to_card(card: Card, members: list[User]) -&gt; list[CardMembership]:\n    \"\"\"Add members to a card\n\n    Args:\n        card (Card): Card to add members to\n        members (list[User]): Members to add\n\n    Returns:\n        list[CardMembership]: CardMemberships created\n    \"\"\"\n    return [card.add_member(member) for member in members]\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.add_members_to_card(card)","title":"<code>card</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.add_members_to_card(members)","title":"<code>members</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.add_viewers_to_board","title":"add_viewers_to_board","text":"<pre><code>add_viewers_to_board(board: Board, users: list[User]) -&gt; list[BoardMembership]\n</code></pre> <p>Add users to a board with viewing permissions</p> PARAMETER DESCRIPTION <p>Board to add users to</p> <p> TYPE: <code>Board</code> </p> <p>Users to add</p> <p> TYPE: <code>list[User]</code> </p> RETURNS DESCRIPTION <code>list[BoardMembership]</code> <p>list[BoardMembership]: BoardMemberships created</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def add_viewers_to_board(board: Board, users: list[User]) -&gt; list[BoardMembership]:\n    \"\"\"Add users to a board with viewing permissions\n\n    Args:\n        board (Board): Board to add users to\n        users (list[User]): Users to add\n\n    Returns:\n        list[BoardMembership]: BoardMemberships created\n    \"\"\"\n    return [board.add_user(user, canComment=False) for user in users]\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.add_viewers_to_board(board)","title":"<code>board</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.add_viewers_to_board(users)","title":"<code>users</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.by_action_type","title":"by_action_type","text":"<pre><code>by_action_type(action_list: list[Action], type: ActionType) -&gt; list[Action]\n</code></pre> <p>Get actions by type</p> PARAMETER DESCRIPTION <p>List of actions to search</p> <p> TYPE: <code>list[Action]</code> </p> <p>Type of the action</p> <p> TYPE: <code>ActionType</code> </p> RETURNS DESCRIPTION <code>list[Action]</code> <p>list[Action]: Actions with the given type</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def by_action_type(action_list: list[Action], type: ActionType) -&gt; list[Action]:\n    \"\"\"Get actions by type\n\n    Args:\n        action_list (list[Action]): List of actions to search\n        type (ActionType): Type of the action\n\n    Returns:\n        list[Action]: Actions with the given type\n    \"\"\"\n    return [action for action in action_list if action.type == type]\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.by_action_type(action_list)","title":"<code>action_list</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.by_action_type(type)","title":"<code>type</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.by_board_name","title":"by_board_name","text":"<pre><code>by_board_name(board_list: list[Board], name: str) -&gt; list[Board]\n</code></pre> <p>Get boards by name</p> PARAMETER DESCRIPTION <p>List of boards to search</p> <p> TYPE: <code>list[Board]</code> </p> <p>Name of the board</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[Board]</code> <p>list[Board]: Boards with the given name</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def by_board_name(board_list: list[Board], name: str) -&gt; list[Board]:\n    \"\"\"Get boards by name\n\n    Args:\n        board_list (list[Board]): List of boards to search\n        name (str): Name of the board\n\n    Returns:\n        list[Board]: Boards with the given name\n    \"\"\"\n    return [board for board in board_list if board.name == name]\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.by_board_name(board_list)","title":"<code>board_list</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.by_board_name(name)","title":"<code>name</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.by_card_name","title":"by_card_name","text":"<pre><code>by_card_name(card_list: list[Card], name: str) -&gt; list[Card]\n</code></pre> <p>Get cards by name</p> PARAMETER DESCRIPTION <p>List of cards to search</p> <p> TYPE: <code>list[Card]</code> </p> <p>Name of the card</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[Card]</code> <p>list[Card]: Cards with the given</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def by_card_name(card_list: list[Card], name: str) -&gt; list[Card]:\n    \"\"\"Get cards by name\n\n    Args:\n        card_list (list[Card]): List of cards to search\n        name (str): Name of the card\n\n    Returns:\n        list[Card]: Cards with the given \n    \"\"\"\n    return [card for card in card_list if card.name == name]\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.by_card_name(card_list)","title":"<code>card_list</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.by_card_name(name)","title":"<code>name</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.by_label_name","title":"by_label_name","text":"<pre><code>by_label_name(label_list: list[Label], name: str) -&gt; list[Label]\n</code></pre> <p>Get labels by name</p> PARAMETER DESCRIPTION <p>List of labels to search</p> <p> TYPE: <code>list[Label]</code> </p> <p>Name of the label</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[Label]</code> <p>list[Label]: Labels with the given name</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def by_label_name(label_list: list[Label], name: str) -&gt; list[Label]:\n    \"\"\"Get labels by name\n\n    Args:\n        label_list (list[Label]): List of labels to search\n        name (str): Name of the label\n\n    Returns:\n        list[Label]: Labels with the given name\n    \"\"\"\n    return [label for label in label_list if label.name == name]\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.by_label_name(label_list)","title":"<code>label_list</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.by_label_name(name)","title":"<code>name</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.by_list_name","title":"by_list_name","text":"<pre><code>by_list_name(list_list: list[List], name: str) -&gt; list[List]\n</code></pre> <p>Get lists by name</p> PARAMETER DESCRIPTION <p>List of lists to search</p> <p> TYPE: <code>list[List]</code> </p> <p>Name of the list</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[List]</code> <p>list[List]: Lists with the given name</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def by_list_name(list_list: list[List], name: str) -&gt; list[List]:\n    \"\"\"Get lists by name\n\n    Args:\n        list_list (list[List]): List of lists to search\n        name (str): Name of the list\n\n    Returns:\n        list[List]: Lists with the given name\n    \"\"\"\n    return [list_ for list_ in list_list if list_.name == name]\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.by_list_name(list_list)","title":"<code>list_list</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.by_list_name(name)","title":"<code>name</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.by_project_name","title":"by_project_name","text":"<pre><code>by_project_name(project_list: list[Project], name: str) -&gt; list[Project]\n</code></pre> <p>Get projects by name</p> PARAMETER DESCRIPTION <p>List of projects to search</p> <p> TYPE: <code>list[Project]</code> </p> <p>Name of the project</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[Project]</code> <p>list[Project]: Projects with the given name</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def by_project_name(project_list: list[Project], name: str) -&gt; list[Project]:\n    \"\"\"Get projects by name\n\n    Args:\n        project_list (list[Project]): List of projects to search\n        name (str): Name of the project\n\n    Returns:\n        list[Project]: Projects with the given name\n    \"\"\"\n    return [project for project in project_list if project.name == name]\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.by_project_name(project_list)","title":"<code>project_list</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.by_project_name(name)","title":"<code>name</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.by_username","title":"by_username","text":"<pre><code>by_username(user_list: list[User], name: str) -&gt; list[User]\n</code></pre> <p>Get users by username</p> PARAMETER DESCRIPTION <p>List of users to search</p> <p> TYPE: <code>list[User]</code> </p> <p>Username of the user</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[User]</code> <p>list[User]: Users with the given username</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def by_username(user_list: list[User], name: str) -&gt; list[User]:\n    \"\"\"Get users by username\n\n    Args:\n        user_list (list[User]): List of users to search\n        name (str): Username of the user\n\n    Returns:\n        list[User]: Users with the given username\n    \"\"\"\n    return [user for user in user_list if user.username == name]\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.by_username(user_list)","title":"<code>user_list</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.by_username(name)","title":"<code>name</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.create_board_labels","title":"create_board_labels","text":"<pre><code>create_board_labels(board: Board, labels: list[Label]) -&gt; list[Label]\n</code></pre> <p>Create labels on a board</p> PARAMETER DESCRIPTION <p>Board to create labels on</p> <p> TYPE: <code>Board</code> </p> <p>Labels to create</p> <p> TYPE: <code>list[Label]</code> </p> RETURNS DESCRIPTION <code>list[Label]</code> <p>list[Label]: The labels that were created</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def create_board_labels(board: Board, labels: list[Label]) -&gt; list[Label]:\n    \"\"\"Create labels on a board\n\n    Args:\n        board (Board): Board to create labels on\n        labels (list[Label]): Labels to create\n\n    Returns:\n        list[Label]: The labels that were created\n    \"\"\"\n    return [board.create_label(label) for label in labels]\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.create_board_labels(board)","title":"<code>board</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.create_board_labels(labels)","title":"<code>labels</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.delete_actions","title":"delete_actions","text":"<pre><code>delete_actions(actions: list[Action]) -&gt; list[Action]\n</code></pre> <p>Delete a list of actions</p> PARAMETER DESCRIPTION <p>Actions to delete</p> <p> TYPE: <code>list[Action]</code> </p> RETURNS DESCRIPTION <code>list[Action]</code> <p>list[Action]: Actions that were deleted</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def delete_actions(actions: list[Action]) -&gt; list[Action]:\n    \"\"\"Delete a list of actions\n\n    Args:\n        actions (list[Action]): Actions to delete\n\n    Returns:\n        list[Action]: Actions that were deleted\n    \"\"\"\n    return [action.delete() for action in actions]\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.delete_actions(actions)","title":"<code>actions</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.delete_boards","title":"delete_boards","text":"<pre><code>delete_boards(boards: list[Board]) -&gt; list[Board]\n</code></pre> <p>Delete a list of boards</p> PARAMETER DESCRIPTION <p>Boards to delete</p> <p> TYPE: <code>list[Board]</code> </p> RETURNS DESCRIPTION <code>list[Board]</code> <p>list[Board]: Boards that were deleted</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def delete_boards(boards: list[Board]) -&gt; list[Board]:\n    \"\"\"Delete a list of boards\n\n    Args:\n        boards (list[Board]): Boards to delete\n\n    Returns:\n        list[Board]: Boards that were deleted\n    \"\"\"\n    return [board.delete() for board in boards]\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.delete_boards(boards)","title":"<code>boards</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.delete_cards","title":"delete_cards","text":"<pre><code>delete_cards(cards: list[Card]) -&gt; list[Card]\n</code></pre> <p>Delete a list of cards</p> PARAMETER DESCRIPTION <p>Cards to delete</p> <p> TYPE: <code>list[Card]</code> </p> RETURNS DESCRIPTION <code>list[Card]</code> <p>list[Card]: Cards that were deleted</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def delete_cards(cards: list[Card]) -&gt; list[Card]:\n    \"\"\"Delete a list of cards\n\n    Args:\n        cards (list[Card]): Cards to delete\n\n    Returns:\n        list[Card]: Cards that were deleted\n    \"\"\"\n    return [card.delete() for card in cards]\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.delete_cards(cards)","title":"<code>cards</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.delete_labels","title":"delete_labels","text":"<pre><code>delete_labels(labels: list[Label]) -&gt; list[Label]\n</code></pre> <p>Delete a list of labels</p> PARAMETER DESCRIPTION <p>Labels to delete</p> <p> TYPE: <code>list[Label]</code> </p> RETURNS DESCRIPTION <code>list[Label]</code> <p>list[Label]: Labels that were deleted</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def delete_labels(labels: list[Label]) -&gt; list[Label]:\n    \"\"\"Delete a list of labels\n\n    Args:\n        labels (list[Label]): Labels to delete\n\n    Returns:\n        list[Label]: Labels that were deleted\n    \"\"\"\n    return [label.delete() for label in labels]\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.delete_labels(labels)","title":"<code>labels</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.delete_lists","title":"delete_lists","text":"<pre><code>delete_lists(lists: list[List]) -&gt; list[List]\n</code></pre> <p>Delete a list of lists</p> PARAMETER DESCRIPTION <p>Lists to delete</p> <p> TYPE: <code>list[List]</code> </p> RETURNS DESCRIPTION <code>list[List]</code> <p>list[List]: Lists that were deleted</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def delete_lists(lists: list[List]) -&gt; list[List]:\n    \"\"\"Delete a list of lists\n\n    Args:\n        lists (list[List]): Lists to delete\n\n    Returns:\n        list[List]: Lists that were deleted\n    \"\"\"\n    return [list_.delete() for list_ in lists]\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.delete_lists(lists)","title":"<code>lists</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.delete_projects","title":"delete_projects","text":"<pre><code>delete_projects(projects: list[Project]) -&gt; list[Project]\n</code></pre> <p>Delete a list of projects</p> PARAMETER DESCRIPTION <p>Projects to delete</p> <p> TYPE: <code>list[Project]</code> </p> RETURNS DESCRIPTION <code>list[Project]</code> <p>list[Project]: Projects that were deleted</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def delete_projects(projects: list[Project]) -&gt; list[Project]:\n    \"\"\"Delete a list of projects\n\n    Args:\n        projects (list[Project]): Projects to delete\n\n    Returns:\n        list[Project]: Projects that were deleted\n    \"\"\"\n    return [project.delete() for project in projects]\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.delete_projects(projects)","title":"<code>projects</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.delete_users","title":"delete_users","text":"<pre><code>delete_users(users: list[User]) -&gt; list[User]\n</code></pre> <p>Delete a list of users</p> PARAMETER DESCRIPTION <p>Users to delete</p> <p> TYPE: <code>list[User]</code> </p> RETURNS DESCRIPTION <code>list[User]</code> <p>list[User]: Users that were deleted</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def delete_users(users: list[User]) -&gt; list[User]:\n    \"\"\"Delete a list of users\n\n    Args:\n        users (list[User]): Users to delete\n\n    Returns:\n        list[User]: Users that were deleted\n    \"\"\"\n    return [user.delete() for user in users]\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.delete_users(users)","title":"<code>users</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.get_boards_by_name","title":"get_boards_by_name","text":"<pre><code>get_boards_by_name(project: Project, name: str) -&gt; list[Board]\n</code></pre> <p>Get all boards in a project by name</p> PARAMETER DESCRIPTION <p>Project to search</p> <p> TYPE: <code>Project</code> </p> <p>Name of the board</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[Board]</code> <p>list[Board]: Boards in the project with the given name</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def get_boards_by_name(project: Project, name: str) -&gt; list[Board]:\n    \"\"\"Get all boards in a project by name\n\n    Args:\n        project (Project): Project to search\n        name (str): Name of the board\n\n    Returns:\n        list[Board]: Boards in the project with the given name\n    \"\"\"\n    return by_board_name(project.boards, name)\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.get_boards_by_name(project)","title":"<code>project</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.get_boards_by_name(name)","title":"<code>name</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.get_cards_by_name","title":"get_cards_by_name","text":"<pre><code>get_cards_by_name(org_unit: List | Board, name: str) -&gt; list[Card]\n</code></pre> <p>Get a card by name from a list or board</p> PARAMETER DESCRIPTION <p>List or Board to search</p> <p> TYPE: <code>List | Board</code> </p> <p>Name of the card</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[Card]</code> <p>list[Card]: Cards in the list or board with the given name</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def get_cards_by_name(org_unit: List | Board, name: str) -&gt; list[Card]:\n    \"\"\"Get a card by name from a list or board\n\n    Args:\n        org_unit (List | Board): List or Board to search\n        name (str): Name of the card\n\n    Returns:\n        list[Card]: Cards in the list or board with the given name\n    \"\"\"\n    return by_card_name(org_unit.cards, name)\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.get_cards_by_name(org_unit)","title":"<code>org_unit</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.get_cards_by_name(name)","title":"<code>name</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.get_labels_by_name","title":"get_labels_by_name","text":"<pre><code>get_labels_by_name(org_unit: Board | Card, name: str) -&gt; list[Label]\n</code></pre> <p>Get a label by name from a board or card</p> PARAMETER DESCRIPTION <p>Board or Card to search</p> <p> TYPE: <code>Board | Card</code> </p> <p>Name of the label</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[Label]</code> <p>list[Label]: Labels in the board or card with the given name</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def get_labels_by_name(org_unit: Board | Card, name: str) -&gt; list[Label]:\n    \"\"\"Get a label by name from a board or card\n\n    Args:\n        org_unit (Board | Card): Board or Card to search\n        name (str): Name of the label\n\n    Returns:\n        list[Label]: Labels in the board or card with the given name\n    \"\"\"\n    return by_label_name(org_unit.labels, name)\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.get_labels_by_name(org_unit)","title":"<code>org_unit</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.get_labels_by_name(name)","title":"<code>name</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.get_lists_by_name","title":"get_lists_by_name","text":"<pre><code>get_lists_by_name(board: Board, name: str) -&gt; list[List]\n</code></pre> <p>Get all lists in a board by name</p> PARAMETER DESCRIPTION <p>Board to search</p> <p> TYPE: <code>Board</code> </p> <p>Name of the list</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[List]</code> <p>list[List]: Lists in the board with the given name</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def get_lists_by_name(board: Board, name: str) -&gt; list[List]:\n    \"\"\"Get all lists in a board by name\n\n    Args:\n        board (Board): Board to search\n        name (str): Name of the list\n\n    Returns:\n        list[List]: Lists in the board with the given name\n    \"\"\"\n    return by_list_name(board.lists, name)\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.get_lists_by_name(board)","title":"<code>board</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.get_lists_by_name(name)","title":"<code>name</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.get_projects_by_name","title":"get_projects_by_name","text":"<pre><code>get_projects_by_name(planka: Planka, name: str) -&gt; list[Project]\n</code></pre> <p>Get all projects with the given name</p> PARAMETER DESCRIPTION <p>Planka instance</p> <p> TYPE: <code>Planka</code> </p> <p>Name of the project</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[Project]</code> <p>list[Project]: List of projects with the given name</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def get_projects_by_name(planka: Planka, name: str) -&gt; list[Project]:\n    \"\"\"Get all projects with the given name\n\n    Args:\n        planka (Planka): Planka instance\n        name (str): Name of the project\n\n    Returns:\n        list[Project]: List of projects with the given name\n    \"\"\"\n    return by_project_name(planka.projects, name)\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.get_projects_by_name(planka)","title":"<code>planka</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.get_projects_by_name(name)","title":"<code>name</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.get_users_by_username","title":"get_users_by_username","text":"<pre><code>get_users_by_username(org_unit: Planka | Project | Board, username: str) -&gt; list[User]\n</code></pre> <p>Get a user by username from a Planka Instance, Project, or Board</p> PARAMETER DESCRIPTION <p>Planka instance, Project, or Board to search</p> <p> TYPE: <code>Planka | Project | Board</code> </p> <p>Username of the user</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[User]</code> <p>list[User]: Users in the org_unit with the given username</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def get_users_by_username(org_unit: Planka | Project | Board, username: str) -&gt; list[User]:\n    \"\"\"Get a user by username from a Planka Instance, Project, or Board\n\n    Args:\n        org_unit (Planka | Project | Board): Planka instance, Project, or Board to search\n        username (str): Username of the user\n\n    Returns:\n        list[User]: Users in the org_unit with the given username\n    \"\"\"\n    return by_username(org_unit.users, username)\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.get_users_by_username(org_unit)","title":"<code>org_unit</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.get_users_by_username(username)","title":"<code>username</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.remove_labels_from_card","title":"remove_labels_from_card","text":"<pre><code>remove_labels_from_card(card: Card, labels: list[Label]) -&gt; list[Label]\n</code></pre> <p>Remove labels from a card</p> PARAMETER DESCRIPTION <p>Card to remove labels from</p> <p> TYPE: <code>Card</code> </p> <p>Labels to remove</p> <p> TYPE: <code>list[Label]</code> </p> RETURNS DESCRIPTION <code>list[Label]</code> <p>list[Label]: Labels that were removed</p> Source code in <code>src/plankapy/v1/helpers.py</code> <pre><code>def remove_labels_from_card(card: Card, labels: list[Label]) -&gt; list[Label]:\n    \"\"\"Remove labels from a card\n\n    Args:\n        card (Card): Card to remove labels from\n        labels (list[Label]): Labels to remove\n\n    Returns:\n        list[Label]: Labels that were removed\n    \"\"\"\n    return [card.remove_label(label) for label in labels]\n</code></pre>"},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.remove_labels_from_card(card)","title":"<code>card</code>","text":""},{"location":"v1/helpers/helpers/#plankapy.v1.helpers.remove_labels_from_card(labels)","title":"<code>labels</code>","text":""},{"location":"v1/interfaces/Action/","title":"Action","text":"<p>               Bases: <code>Action_</code></p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Deletes the comment action</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>Refreshes the action data</p> ATTRIBUTE DESCRIPTION <code>created_at</code> <p>Get the creation date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>deleted_at</code> <p>Get the deletion date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>link</code> <p>Get the link to the model instance</p> <p> TYPE: <code>str | None</code> </p> <code>routes</code> <p>Get the routes for the model instance</p> <p> TYPE: <code>Routes</code> </p> <code>unique_name</code> <p>Generate a unique name for the model instance using the last 5 characters of the id</p> <p> TYPE: <code>str</code> </p> <code>updated_at</code> <p>Get the last update date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p>"},{"location":"v1/interfaces/Action/#plankapy.v1.interfaces.Action.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/interfaces/Action/#plankapy.v1.interfaces.Action.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/interfaces/Action/#plankapy.v1.interfaces.Action.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/interfaces/Action/#plankapy.v1.interfaces.Action.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/interfaces/Action/#plankapy.v1.interfaces.Action.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/interfaces/Action/#plankapy.v1.interfaces.Action.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/interfaces/Action/#plankapy.v1.interfaces.Action.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/interfaces/Action/#plankapy.v1.interfaces.Action.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/interfaces/Action/#plankapy.v1.interfaces.Action.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/interfaces/Action/#plankapy.v1.interfaces.Action.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/interfaces/Action/#plankapy.v1.interfaces.Action.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/interfaces/Action/#plankapy.v1.interfaces.Action.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/interfaces/Action/#plankapy.v1.interfaces.Action.delete","title":"delete","text":"<pre><code>delete() -&gt; Action\n</code></pre> <p>Deletes the comment action</p> Danger <p>This action is irreversible and cannot be undone</p> RETURNS DESCRIPTION <code>Action</code> <p>Deleted comment action instance</p> <p> TYPE: <code>Action</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def delete(self) -&gt; Action:\n    \"\"\"Deletes the comment action\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        Action: Deleted comment action instance\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_comment_action(id=self.id)\n    route()\n    return self\n</code></pre>"},{"location":"v1/interfaces/Action/#plankapy.v1.interfaces.Action.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/interfaces/Action/#plankapy.v1.interfaces.Action.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/interfaces/Action/#plankapy.v1.interfaces.Action.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/interfaces/Action/#plankapy.v1.interfaces.Action.refresh","title":"refresh","text":"<pre><code>refresh() -&gt; None\n</code></pre> <p>Refreshes the action data</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshes the action data\"\"\"\n    for action in self.card.comments:\n        if action.id == self.id:\n            self.__init__(**action)\n</code></pre>"},{"location":"v1/interfaces/Archive/","title":"Archive","text":"<p>               Bases: <code>Archive_</code></p> <p>Interface for interacting with planka Archives and their included sub-objects</p> Warning <p>This class is not yet implemented and is a placeholder for future development There are no current Planka endpoints for interacting with <code>Archive</code> objects</p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Delete the model instance</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>\"Refresh the model instance</p> <code>update</code> <p>Update the model instance</p> ATTRIBUTE DESCRIPTION <code>created_at</code> <p>Get the creation date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>deleted_at</code> <p>Get the deletion date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>link</code> <p>Get the link to the model instance</p> <p> TYPE: <code>str | None</code> </p> <code>routes</code> <p>Get the routes for the model instance</p> <p> TYPE: <code>Routes</code> </p> <code>unique_name</code> <p>Generate a unique name for the model instance using the last 5 characters of the id</p> <p> TYPE: <code>str</code> </p> <code>updated_at</code> <p>Get the last update date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p>"},{"location":"v1/interfaces/Archive/#plankapy.v1.interfaces.Archive.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/interfaces/Archive/#plankapy.v1.interfaces.Archive.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/interfaces/Archive/#plankapy.v1.interfaces.Archive.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/interfaces/Archive/#plankapy.v1.interfaces.Archive.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/interfaces/Archive/#plankapy.v1.interfaces.Archive.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/interfaces/Archive/#plankapy.v1.interfaces.Archive.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/interfaces/Archive/#plankapy.v1.interfaces.Archive.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/interfaces/Archive/#plankapy.v1.interfaces.Archive.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/interfaces/Archive/#plankapy.v1.interfaces.Archive.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/interfaces/Archive/#plankapy.v1.interfaces.Archive.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/interfaces/Archive/#plankapy.v1.interfaces.Archive.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/interfaces/Archive/#plankapy.v1.interfaces.Archive.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/interfaces/Archive/#plankapy.v1.interfaces.Archive.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/interfaces/Archive/#plankapy.v1.interfaces.Archive.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/interfaces/Archive/#plankapy.v1.interfaces.Archive.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/interfaces/Archive/#plankapy.v1.interfaces.Archive.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/interfaces/Archive/#plankapy.v1.interfaces.Archive.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>\"Refresh the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def refresh(self): \n    \"\"\"\"Refresh the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/interfaces/Archive/#plankapy.v1.interfaces.Archive.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/interfaces/Attachment/","title":"Attachment","text":"<p>               Bases: <code>Attachment_</code></p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>data</code> <p>Attachment data as bytes</p> <code>delete</code> <p>Deletes the attachment</p> <code>download</code> <p>Downloads the attachment to a file</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>Refreshes the attachment data</p> <code>update</code> <p>Updates the attachment with new values</p> ATTRIBUTE DESCRIPTION <code>card</code> <p>Card the attachment belongs to</p> <p> TYPE: <code>Card</code> </p> <code>created_at</code> <p>Get the creation date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>creator</code> <p>User that created the attachment</p> <p> TYPE: <code>User</code> </p> <code>deleted_at</code> <p>Get the deletion date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>link</code> <p>Get the link to the model instance</p> <p> TYPE: <code>str | None</code> </p> <code>routes</code> <p>Get the routes for the model instance</p> <p> TYPE: <code>Routes</code> </p> <code>unique_name</code> <p>Generate a unique name for the model instance using the last 5 characters of the id</p> <p> TYPE: <code>str</code> </p> <code>updated_at</code> <p>Get the last update date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p>"},{"location":"v1/interfaces/Attachment/#plankapy.v1.interfaces.Attachment.card","title":"card  <code>property</code>","text":"<pre><code>card: Card\n</code></pre> <p>Card the attachment belongs to</p>"},{"location":"v1/interfaces/Attachment/#plankapy.v1.interfaces.Attachment.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/interfaces/Attachment/#plankapy.v1.interfaces.Attachment.creator","title":"creator  <code>property</code>","text":"<pre><code>creator: User\n</code></pre> <p>User that created the attachment</p>"},{"location":"v1/interfaces/Attachment/#plankapy.v1.interfaces.Attachment.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/interfaces/Attachment/#plankapy.v1.interfaces.Attachment.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/interfaces/Attachment/#plankapy.v1.interfaces.Attachment.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/interfaces/Attachment/#plankapy.v1.interfaces.Attachment.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/interfaces/Attachment/#plankapy.v1.interfaces.Attachment.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/interfaces/Attachment/#plankapy.v1.interfaces.Attachment.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/interfaces/Attachment/#plankapy.v1.interfaces.Attachment.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/interfaces/Attachment/#plankapy.v1.interfaces.Attachment.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/interfaces/Attachment/#plankapy.v1.interfaces.Attachment.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/interfaces/Attachment/#plankapy.v1.interfaces.Attachment.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/interfaces/Attachment/#plankapy.v1.interfaces.Attachment.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/interfaces/Attachment/#plankapy.v1.interfaces.Attachment.data","title":"data","text":"<pre><code>data() -&gt; bytes\n</code></pre> <p>Attachment data as bytes</p> RETURNS DESCRIPTION <code>bytes</code> <p>Attachment data</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def data(self) -&gt; bytes:\n    \"\"\"Attachment data as bytes\n\n    Returns:\n        Attachment data\n    \"\"\"\n    return self.routes.handler._get_file(self.url)\n</code></pre>"},{"location":"v1/interfaces/Attachment/#plankapy.v1.interfaces.Attachment.delete","title":"delete","text":"<pre><code>delete() -&gt; Attachment\n</code></pre> <p>Deletes the attachment</p> Danger <p>This action is irreversible and cannot be undone</p> RETURNS DESCRIPTION <code>Attachment</code> <p>Deleted attachment instance</p> <p> TYPE: <code>Attachment</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def delete(self) -&gt; Attachment:\n    \"\"\"Deletes the attachment\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        Attachment: Deleted attachment instance\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_attachment(id=self.id)\n    route()\n    return self\n</code></pre>"},{"location":"v1/interfaces/Attachment/#plankapy.v1.interfaces.Attachment.download","title":"download","text":"<pre><code>download(path: Path) -&gt; None\n</code></pre> <p>Downloads the attachment to a file</p> PARAMETER DESCRIPTION <p>Path to the file to save the attachment to</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def download(self, path: Path) -&gt; None:\n    \"\"\"Downloads the attachment to a file\n\n    Args:\n        path (Path): Path to the file to save the attachment to\n    \"\"\"\n    with open(path, 'wb') as file:\n        file.write(self.data())\n</code></pre>"},{"location":"v1/interfaces/Attachment/#plankapy.v1.interfaces.Attachment.download(path)","title":"<code>path</code>","text":""},{"location":"v1/interfaces/Attachment/#plankapy.v1.interfaces.Attachment.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/interfaces/Attachment/#plankapy.v1.interfaces.Attachment.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/interfaces/Attachment/#plankapy.v1.interfaces.Attachment.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/interfaces/Attachment/#plankapy.v1.interfaces.Attachment.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>Refreshes the attachment data</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def refresh(self):\n    \"\"\"Refreshes the attachment data\"\"\"\n    for attachment in self.card.attachments:\n        if attachment.id == self.id:\n            self.__init__(**attachment)\n</code></pre>"},{"location":"v1/interfaces/Attachment/#plankapy.v1.interfaces.Attachment.update","title":"update","text":"<pre><code>update() -&gt; Attachment\n</code></pre> <p>Updates the attachment with new values</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def update(self) -&gt; Attachment:\n    \"\"\"Updates the attachment with new values\"\"\"\n    route = self.routes.patch_attachment(id=self.id)\n    self.__init__(**route(**self)['item'])\n    return self\n</code></pre>"},{"location":"v1/interfaces/Board/","title":"Board","text":"<p>               Bases: <code>Board_</code></p> <p>Interface for interacting with planka Boards and their included sub-objects</p> Note <p>All implemented public properties return API responses with accessed. This means that the values are not cached  and will be updated on every access. If you wish to cache values, you are responsible for doing so. By default,  property access will always provide the most up to date information.</p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>add_user</code> <p>Adds a user to the board</p> <code>bind</code> <p>Bind routes to the model</p> <code>create_label</code> <p>Creates a new label in the board</p> <code>create_list</code> <p>Creates a new list in the board</p> <code>delete</code> <p>Deletes the board</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>Refreshes the board data</p> <code>remove_user</code> <p>Remove a user from a board</p> <code>update</code> <p>Updates the board with new values</p> ATTRIBUTE DESCRIPTION <code>attachments</code> <p>All attachments in the board</p> <p> TYPE: <code>QueryableList[Attachment]</code> </p> <code>boardMemberships</code> <p>All board memberships</p> <p> TYPE: <code>QueryableList[BoardMembership]</code> </p> <code>cardLabels</code> <p>All card -&gt; label relationships in the board</p> <p> TYPE: <code>QueryableList[CardLabel]</code> </p> <code>cardMemberships</code> <p>All card -&gt; user relationships in the board</p> <p> TYPE: <code>QueryableList[CardMembership]</code> </p> <code>cards</code> <p>All cards in the board</p> <p> TYPE: <code>QueryableList[Card]</code> </p> <code>created_at</code> <p>Get the creation date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>deleted_at</code> <p>Get the deletion date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>editors</code> <p>All users that can edit the board</p> <p> TYPE: <code>QueryableList[User]</code> </p> <code>labels</code> <p>All labels in the board</p> <p> TYPE: <code>QueryableList[Label]</code> </p> <code>link</code> <p>Get the link to the model instance</p> <p> TYPE: <code>str | None</code> </p> <code>lists</code> <p>All lists in the board</p> <p> TYPE: <code>QueryableList[List]</code> </p> <code>project</code> <p>Project the board belongs to</p> <p> TYPE: <code>Project</code> </p> <code>routes</code> <p>Get the routes for the model instance</p> <p> TYPE: <code>Routes</code> </p> <code>tasks</code> <p>All tasks in the board</p> <p> TYPE: <code>QueryableList[Task]</code> </p> <code>unique_name</code> <p>Generate a unique name for the model instance using the last 5 characters of the id</p> <p> TYPE: <code>str</code> </p> <code>updated_at</code> <p>Get the last update date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>users</code> <p>All users in the board</p> <p> TYPE: <code>QueryableList[User]</code> </p> <code>viewers</code> <p>All users that can view the board</p> <p> TYPE: <code>QueryableList[User]</code> </p>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.attachments","title":"attachments  <code>property</code>","text":"<pre><code>attachments: QueryableList[Attachment]\n</code></pre> <p>All attachments in the board</p> Note <p>This property is used by the <code>Card</code> class to determine its attachments</p> RETURNS DESCRIPTION <code>QueryableList[Attachment]</code> <p>A list of all card attachments in the board</p>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.boardMemberships","title":"boardMemberships  <code>property</code>","text":"<pre><code>boardMemberships: QueryableList[BoardMembership]\n</code></pre> <p>All board memberships</p> Note <p>This property is primarily here for internal use, '.editor' and '.viewer' properties  are derived from the board memberships</p> RETURNS DESCRIPTION <code>QueryableList[BoardMembership]</code> <p>Queryable List of all membership types (editor, viewer)</p>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.cardLabels","title":"cardLabels  <code>property</code>","text":"<pre><code>cardLabels: QueryableList[CardLabel]\n</code></pre> <p>All card -&gt; label relationships in the board</p> Note <p>This property is used by the <code>Card</code> class to determine its labels</p> RETURNS DESCRIPTION <code>QueryableList[CardLabel]</code> <p>A list of all card labels in the board</p>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.cardMemberships","title":"cardMemberships  <code>property</code>","text":"<pre><code>cardMemberships: QueryableList[CardMembership]\n</code></pre> <p>All card -&gt; user relationships in the board</p> Note <p>This property is used by the <code>Card</code> class to determine its users</p> RETURNS DESCRIPTION <code>QueryableList[CardMembership]</code> <p>A list of all card memberships in the board</p>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.cards","title":"cards  <code>property</code>","text":"<pre><code>cards: QueryableList[Card]\n</code></pre> <p>All cards in the board</p> RETURNS DESCRIPTION <code>QueryableList[Card]</code> <p>A list of all cards in the board</p>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.editors","title":"editors  <code>property</code>","text":"<pre><code>editors: QueryableList[User]\n</code></pre> <p>All users that can edit the board</p> RETURNS DESCRIPTION <code>QueryableList[User]</code> <p>Queryable List of all editors</p>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.labels","title":"labels  <code>property</code>","text":"<pre><code>labels: QueryableList[Label]\n</code></pre> <p>All labels in the board</p> RETURNS DESCRIPTION <code>QueryableList[Label]</code> <p>Queryable List of all labels in the board</p>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.lists","title":"lists  <code>property</code>","text":"<pre><code>lists: QueryableList[List]\n</code></pre> <p>All lists in the board</p> RETURNS DESCRIPTION <code>QueryableList[List]</code> <p>Queryable List of all lists in the board</p>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.project","title":"project  <code>property</code>","text":"<pre><code>project: Project\n</code></pre> <p>Project the board belongs to</p> Note <p>All objects include a reference to their parent object and parent objects include a reference to their children This means that you can traverse the entire API structure from any object</p> RETURNS DESCRIPTION <code>Project</code> <p>Project instance</p> <p> TYPE: <code>Project</code> </p>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: QueryableList[Task]\n</code></pre> <p>All tasks in the board</p> Note <p>This property is used by the <code>Card</code> class to determine its tasks</p> RETURNS DESCRIPTION <code>QueryableList[Task]</code> <p>A list of all card tasks in the board</p>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.users","title":"users  <code>property</code>","text":"<pre><code>users: QueryableList[User]\n</code></pre> <p>All users in the board</p> RETURNS DESCRIPTION <code>QueryableList[User]</code> <p>Queryable List of all users</p>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.viewers","title":"viewers  <code>property</code>","text":"<pre><code>viewers: QueryableList[User]\n</code></pre> <p>All users that can view the board</p> RETURNS DESCRIPTION <code>QueryableList[User]</code> <p>Queryable List of all viewers</p>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.add_user","title":"add_user","text":"<pre><code>add_user(user: User, role: BoardRole = 'viewer', canComment: bool = False) -&gt; BoardMembership\n</code></pre> <p>Adds a user to the board</p> PARAMETER DESCRIPTION <p>User instance to add</p> <p> TYPE: <code>User</code> </p> <p>Whether the user can comment on the board (default: False)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>BoardMembership</code> <p>New board membership</p> <p> TYPE: <code>BoardMembership</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the role is invalid (must be 'viewer' or 'editor')</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def add_user(self, user: User, role: BoardRole='viewer', canComment: bool=False) -&gt; BoardMembership:\n    \"\"\"Adds a user to the board\n\n    Args:\n        user (User): User instance to add\n        canComment (bool): Whether the user can comment on the board (default: False)\n\n    Returns:\n        BoardMembership: New board membership\n\n    Raises:\n        ValueError: If the role is invalid (must be 'viewer' or 'editor')\n    \"\"\"\n    if role not in self.roles:\n        raise ValueError(f'Invalid role: {role}')\n\n    if role == 'editor':\n        canComment = True\n    route = self.routes.post_board_membership(boardId=self.id)\n    return BoardMembership(**route(userId=user.id, boardId=self.id, canComment=canComment, role=role)['item']).bind(self.routes)\n</code></pre>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.add_user(user)","title":"<code>user</code>","text":""},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.add_user(canComment)","title":"<code>canComment</code>","text":""},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.create_label","title":"create_label","text":"<pre><code>create_label(label: Label) -&gt; Label\n</code></pre><pre><code>create_label(name: str, position: int = 0, color: LabelColor = None) -&gt; Label\n</code></pre> <pre><code>create_label(*args, **kwargs) -&gt; Label\n</code></pre> <p>Creates a new label in the board</p> PARAMETER DESCRIPTION <p>Name of the label (required)</p> <p> TYPE: <code>str</code> </p> <p>Position of the label (default: 0)</p> <p> TYPE: <code>int</code> </p> <p>Color of the label (default: \"berry-red\")</p> <p> TYPE: <code>LabelColor</code> </p> ALTERNATE DESCRIPTION <p>Label instance to create</p> <p> TYPE: <code>Label</code> </p> RETURNS DESCRIPTION <code>Label</code> <p>New label instance</p> <p> TYPE: <code>Label</code> </p> Example <pre><code>&gt;&gt;&gt; new_label = board.create_label('My Label')\n&gt;&gt;&gt; label = Label(name='My Label', position=0, color='wet-moss')\n&gt;&gt;&gt; new_label2 = board.create_label(label)\n</code></pre> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def create_label(self, *args, **kwargs) -&gt; Label:\n    \"\"\"Creates a new label in the board\n\n    Args:\n        name (str): Name of the label (required)\n        position (int): Position of the label (default: 0)\n        color (LabelColor): Color of the label (default: \"berry-red\")\n\n    Args: Alternate\n        label (Label): Label instance to create\n\n    Returns:\n        Label: New label instance\n\n    Example:\n        ```python\n        &gt;&gt;&gt; new_label = board.create_label('My Label')\n        &gt;&gt;&gt; label = Label(name='My Label', position=0, color='wet-moss')\n        &gt;&gt;&gt; new_label2 = board.create_label(label)\n        ```\n    \"\"\"\n    overload = parse_overload(args, kwargs, model='label', \n                              options=('name', 'position', 'color'), \n                              required=('name',)) # Only name requires user provided value\n\n    # Required arguments with defaults must be manually assigned\n    overload['position'] = overload.get('position', 0)\n    overload['color'] = overload.get('color', choice(LabelColor.__args__))\n    overload['boardId'] = self.id\n\n    route = self.routes.post_label(boardId=self.id)\n    return Label(**route(**overload)['item']).bind(self.routes)\n</code></pre>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.create_label(name)","title":"<code>name</code>","text":""},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.create_label(position)","title":"<code>position</code>","text":""},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.create_label(color)","title":"<code>color</code>","text":""},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.create_label(label)","title":"<code>label</code>","text":""},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.create_list","title":"create_list","text":"<pre><code>create_list(_list: List) -&gt; List\n</code></pre><pre><code>create_list(name: str, position: int) -&gt; List\n</code></pre> <pre><code>create_list(*args, **kwargs) -&gt; List\n</code></pre> <p>Creates a new list in the board</p> PARAMETER DESCRIPTION <p>Name of the list (required)</p> <p> TYPE: <code>str</code> </p> <p>Position of the list (default: 0)</p> <p> TYPE: <code>int</code> </p> ALTERNATE DESCRIPTION <p>List instance to create</p> <p> TYPE: <code>List</code> </p> RETURNS DESCRIPTION <code>List</code> <p>New list instance</p> <p> TYPE: <code>List</code> </p> Example <pre><code>&gt;&gt;&gt; new_list = board.create_list('My List')\n\n&gt;&gt;&gt; l = List(name='My List', position=0)\n&gt;&gt;&gt; new_list2 = board.create_list(l)\n</code></pre> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def create_list(self, *args, **kwargs) -&gt; List:\n    \"\"\"Creates a new list in the board\n\n    Args:\n        name (str): Name of the list (required)\n        position (int): Position of the list (default: 0)\n\n    Args: Alternate\n        list (List): List instance to create\n\n    Returns:\n        List: New list instance\n\n    Example:\n        ```python\n        &gt;&gt;&gt; new_list = board.create_list('My List')\n\n        &gt;&gt;&gt; l = List(name='My List', position=0)\n        &gt;&gt;&gt; new_list2 = board.create_list(l)\n        ```\n    \"\"\"\n    overload = parse_overload(args, kwargs, model='list', \n                              options=('name', 'position'), \n                              required=('name',))\n\n    overload['position'] = overload.get('position', 0)\n    overload['boardId'] = self.id\n\n    route = self.routes.post_list(boardId=self.id)\n    return List(**route(**overload)['item']).bind(self.routes)\n</code></pre>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.create_list(name)","title":"<code>name</code>","text":""},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.create_list(position)","title":"<code>position</code>","text":""},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.create_list(list)","title":"<code>list</code>","text":""},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.delete","title":"delete","text":"<pre><code>delete() -&gt; Board\n</code></pre> <p>Deletes the board</p> Danger <p>This action is irreversible and cannot be undone</p> RETURNS DESCRIPTION <code>Board</code> <p>Deleted board instance</p> <p> TYPE: <code>Board</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def delete(self) -&gt; Board:\n    \"\"\"Deletes the board\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        Board: Deleted board instance\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_board(id=self.id)\n    route()\n    return self\n</code></pre>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.refresh","title":"refresh","text":"<pre><code>refresh() -&gt; None\n</code></pre> <p>Refreshes the board data</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshes the board data\"\"\"\n    route = self.routes.get_board(id=self.id)\n    self.__init__(**route()['item'])\n</code></pre>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.remove_user","title":"remove_user","text":"<pre><code>remove_user(user: User) -&gt; User\n</code></pre><pre><code>remove_user(userId: int) -&gt; User\n</code></pre> <pre><code>remove_user(*args, **kwargs) -&gt; User\n</code></pre> <p>Remove a user from a board</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def remove_user(self, *args, **kwargs) -&gt; User:\n    \"\"\"Remove a user from a board\n    \"\"\"\n    overload = parse_overload(args, kwargs,\n                              model='user',\n                              options=('userId',),\n                              required=('userId',))\n\n    if 'userId' not in overload: # Case if passed User\n        overload['userId'] = overload['id']\n\n    for member in self.boardMemberships:\n        if member.userId == overload['userId']:\n            member.delete()\n</code></pre>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.update","title":"update","text":"<pre><code>update() -&gt; Board\n</code></pre><pre><code>update(board: Board) -&gt; Board\n</code></pre><pre><code>update(name: str = None, position: int = None) -&gt; Board\n</code></pre> <pre><code>update(*args, **kwargs) -&gt; Board\n</code></pre> <p>Updates the board with new values</p> PARAMETER DESCRIPTION <p>Name of the board (optional)</p> <p> TYPE: <code>str</code> </p> <p>Position of the board (optional)</p> <p> TYPE: <code>int</code> </p> ALTERNATE DESCRIPTION <p>Board instance to update (required)</p> <p> TYPE: <code>Board</code> </p> Note <p>If no arguments are provided, the board will update itself with the current values stored in its attributes</p> RETURNS DESCRIPTION <code>Board</code> <p>Updated board instance</p> <p> TYPE: <code>Board</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def update(self, *args, **kwargs) -&gt; Board:\n    \"\"\"Updates the board with new values\n\n    Args:\n        name (str): Name of the board (optional)\n        position (int): Position of the board (optional)\n\n    Args: Alternate\n        board (Board): Board instance to update (required)\n\n    Note:\n        If no arguments are provided, the board will update itself with the current values\n        stored in its attributes\n\n    Returns:\n        Board: Updated board instance\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='board', \n        options=('name', 'position'),\n        noarg=self)\n\n    route = self.routes.patch_board(id=self.id)\n    self.__init__(**route(**overload)['item'])\n    return self\n</code></pre>"},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.update(name)","title":"<code>name</code>","text":""},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.update(position)","title":"<code>position</code>","text":""},{"location":"v1/interfaces/Board/#plankapy.v1.interfaces.Board.update(board)","title":"<code>board</code>","text":""},{"location":"v1/interfaces/BoardMembership/","title":"BoardMembership","text":"<p>               Bases: <code>BoardMembership_</code></p> <p>Interface for interacting with planka Board Memberships</p> Note <p>Only memberships that the current user has manager access to can be seen</p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Deletes the board membership relation</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>Refreshes the board membership data</p> <code>update</code> <p>Updates the board membership with new values</p> ATTRIBUTE DESCRIPTION <code>board</code> <p>Board that the membership is associated with</p> <p> TYPE: <code>Board</code> </p> <code>created_at</code> <p>Get the creation date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>deleted_at</code> <p>Get the deletion date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>link</code> <p>Get the link to the model instance</p> <p> TYPE: <code>str | None</code> </p> <code>routes</code> <p>Get the routes for the model instance</p> <p> TYPE: <code>Routes</code> </p> <code>unique_name</code> <p>Generate a unique name for the model instance using the last 5 characters of the id</p> <p> TYPE: <code>str</code> </p> <code>updated_at</code> <p>Get the last update date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>user</code> <p>User that the membership is associated with</p> <p> TYPE: <code>User</code> </p>"},{"location":"v1/interfaces/BoardMembership/#plankapy.v1.interfaces.BoardMembership.board","title":"board  <code>property</code>","text":"<pre><code>board: Board\n</code></pre> <p>Board that the membership is associated with</p> RETURNS DESCRIPTION <code>Board</code> <p>Board instance</p> <p> TYPE: <code>Board</code> </p>"},{"location":"v1/interfaces/BoardMembership/#plankapy.v1.interfaces.BoardMembership.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/interfaces/BoardMembership/#plankapy.v1.interfaces.BoardMembership.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/interfaces/BoardMembership/#plankapy.v1.interfaces.BoardMembership.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/interfaces/BoardMembership/#plankapy.v1.interfaces.BoardMembership.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/interfaces/BoardMembership/#plankapy.v1.interfaces.BoardMembership.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/interfaces/BoardMembership/#plankapy.v1.interfaces.BoardMembership.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/interfaces/BoardMembership/#plankapy.v1.interfaces.BoardMembership.user","title":"user  <code>property</code>","text":"<pre><code>user: User\n</code></pre> <p>User that the membership is associated with</p> RETURNS DESCRIPTION <code>User</code> <p>User instance</p> <p> TYPE: <code>User</code> </p>"},{"location":"v1/interfaces/BoardMembership/#plankapy.v1.interfaces.BoardMembership.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/interfaces/BoardMembership/#plankapy.v1.interfaces.BoardMembership.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/interfaces/BoardMembership/#plankapy.v1.interfaces.BoardMembership.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/interfaces/BoardMembership/#plankapy.v1.interfaces.BoardMembership.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/interfaces/BoardMembership/#plankapy.v1.interfaces.BoardMembership.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/interfaces/BoardMembership/#plankapy.v1.interfaces.BoardMembership.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/interfaces/BoardMembership/#plankapy.v1.interfaces.BoardMembership.delete","title":"delete","text":"<pre><code>delete() -&gt; tuple[User, Board]\n</code></pre> <p>Deletes the board membership relation</p> Danger <p>This action is irreversible and cannot be undone</p> RETURNS DESCRIPTION <code>User</code> <p>The user that was removed from the board</p> <p> TYPE: <code>tuple[User, Board]</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def delete(self) -&gt; tuple[User, Board]:\n    \"\"\"Deletes the board membership relation\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        User: The user that was removed from the board\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_board_membership(id=self.id)\n    route()\n    return (self.user, self.board)\n</code></pre>"},{"location":"v1/interfaces/BoardMembership/#plankapy.v1.interfaces.BoardMembership.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/interfaces/BoardMembership/#plankapy.v1.interfaces.BoardMembership.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/interfaces/BoardMembership/#plankapy.v1.interfaces.BoardMembership.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/interfaces/BoardMembership/#plankapy.v1.interfaces.BoardMembership.refresh","title":"refresh","text":"<pre><code>refresh() -&gt; None\n</code></pre> <p>Refreshes the board membership data</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshes the board membership data\"\"\"\n    for membership in self.board.boardMemberships:\n        if membership.id == self.id:\n            self.__init__(**membership)\n</code></pre>"},{"location":"v1/interfaces/BoardMembership/#plankapy.v1.interfaces.BoardMembership.update","title":"update","text":"<pre><code>update()\n</code></pre><pre><code>update(boardMembership: BoardMembership)\n</code></pre><pre><code>update(role: BoardRole = None, canComment: bool = None)\n</code></pre> <pre><code>update(*args, **kwargs) -&gt; BoardMembership\n</code></pre> <p>Updates the board membership with new values</p> Tip <p>Use <code>.editor()</code> context manager to update the board membership with the user as an editor</p> <p>Example: <pre><code>&gt;&gt;&gt; with boardMembership.editor():\n...    boardMembership.role = 'editor'\n\n&gt;&gt;&gt; boardMembership\nBoardMembership(userId='...', boardId='...', role='editor', canComment=True)\n</code></pre></p> Warning <p>canComment will always be set to True if the role is 'editor', if a context is used as a user is  switched to a viewer, they will maintain their ability to comment unless explicitly set to False</p> <p>Example: <pre><code>&gt;&gt;&gt; boardMembership.role\n'editor'\n\n&gt;&gt;&gt; with boardMembership.editor():\n...    boardMembership.role = 'viewer'\n\n&gt;&gt;&gt; boardMembership.canComment\nTrue\n\n&gt;&gt;&gt; # Using .update() will not automatically set canComment to False\n&gt;&gt;&gt; # on role change unless specified\n&gt;&gt;&gt; boardMembership.update(role='viewer')\n&gt;&gt;&gt; boardMembership.canComment\nFalse\n</code></pre></p> PARAMETER DESCRIPTION <p>Role of the user in the board (default: None)</p> <p> TYPE: <code>BoardRole</code> </p> <p>Whether the user can comment on the board (default: None)</p> <p> TYPE: <code>bool</code> </p> ALTERNATE DESCRIPTION <p>Board membership instance to update with</p> <p> TYPE: <code>BoardMembership</code> </p> RETURNS DESCRIPTION <code>BoardMembership</code> <p>Updated board membership instance</p> <p> TYPE: <code>BoardMembership</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the role is invalid (must be 'viewer' or 'editor')</p> Note <p>If no arguments are provided, the board membership will update itself with the current values stored in its attributes</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def update(self, *args, **kwargs) -&gt; BoardMembership:\n    \"\"\"Updates the board membership with new values\n\n    Tip:\n        Use `.editor()` context manager to update the board membership with the user as an editor\n\n        Example:\n        ```python\n        &gt;&gt;&gt; with boardMembership.editor():\n        ...    boardMembership.role = 'editor'\n\n        &gt;&gt;&gt; boardMembership\n        BoardMembership(userId='...', boardId='...', role='editor', canComment=True)\n        ```\n\n    Warning:\n        canComment will always be set to True if the role is 'editor', if a context is used as a user is \n        switched to a viewer, they will maintain their ability to comment unless explicitly set to False\n\n        Example:\n        ```python\n        &gt;&gt;&gt; boardMembership.role\n        'editor'\n\n        &gt;&gt;&gt; with boardMembership.editor():\n        ...    boardMembership.role = 'viewer'\n\n        &gt;&gt;&gt; boardMembership.canComment\n        True\n\n        &gt;&gt;&gt; # Using .update() will not automatically set canComment to False\n        &gt;&gt;&gt; # on role change unless specified\n        &gt;&gt;&gt; boardMembership.update(role='viewer')\n        &gt;&gt;&gt; boardMembership.canComment\n        False\n        ```\n\n    Args:\n        role (BoardRole): Role of the user in the board (default: None)\n        canComment (bool): Whether the user can comment on the board (default: None)\n\n    Args: Alternate\n        boardMembership (BoardMembership): Board membership instance to update with\n\n    Returns:\n        BoardMembership: Updated board membership instance\n\n    Raises:\n        ValueError: If the role is invalid (must be 'viewer' or 'editor')\n\n    Note:\n        If no arguments are provided, the board membership will update itself with the current values stored in its attributes\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='boardMembership', \n        options=('role', 'canComment'),\n        noarg=self)\n\n    if 'role' in overload:\n        if overload['role'] not in self.roles:\n            raise ValueError(\n                f'Invalid role: {overload[\"role\"]}'\n                f'Available roles: {self.roles}')\n\n        if overload['role'] == 'editor': # Editors can always comment\n            overload['canComment'] = True\n\n        if overload['role'] == 'viewer': # Viewers can only comment if explicitly set\n            overload['canComment'] = overload.get('canComment', False)\n\n    route = self.routes.patch_board_membership(id=self.id)\n    self.__init__(**route(**overload)['item'])\n    return self\n</code></pre>"},{"location":"v1/interfaces/BoardMembership/#plankapy.v1.interfaces.BoardMembership.update(role)","title":"<code>role</code>","text":""},{"location":"v1/interfaces/BoardMembership/#plankapy.v1.interfaces.BoardMembership.update(canComment)","title":"<code>canComment</code>","text":""},{"location":"v1/interfaces/BoardMembership/#plankapy.v1.interfaces.BoardMembership.update(boardMembership)","title":"<code>boardMembership</code>","text":""},{"location":"v1/interfaces/Card/","title":"Card","text":"<p>               Bases: <code>Card_</code></p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>add_attachment</code> <p>Adds an attachment to the card</p> <code>add_comment</code> <p>Adds a comment to the card</p> <code>add_label</code> <p>Adds a label to the card</p> <code>add_member</code> <p>Adds a user to the card</p> <code>add_stopwatch</code> <p>Adds a stopwatch to the card if there is not one already</p> <code>add_task</code> <p>Adds a task to the card</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Deletes the card</p> <code>duplicate</code> <p>Duplicates the card</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>move</code> <p>Moves the card to a new list</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>Refreshes the card data</p> <code>remove_attachment</code> <p>Removes an attachment from the card</p> <code>remove_comment</code> <p>Pass a comment from self.comments to remove it</p> <code>remove_label</code> <p>Removes a label from the card</p> <code>remove_member</code> <p>Removes a user from the card</p> <code>remove_stopwatch</code> <p>Removes the stopwatch from the card</p> <code>set_due_date</code> <p>Sets the due date of the card</p> <code>update</code> <p>Updates the card with new values</p> ATTRIBUTE DESCRIPTION <code>attachments</code> <p>All attachments on the card</p> <p> TYPE: <code>QueryableList[Attachment]</code> </p> <code>board</code> <p>Board the card belongs to</p> <p> TYPE: <code>Board</code> </p> <code>comments</code> <p>All comments on the card</p> <p> TYPE: <code>QueryableList[Action]</code> </p> <code>created_at</code> <p>Get the creation date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>creator</code> <p>User that created the card</p> <p> TYPE: <code>User</code> </p> <code>deleted_at</code> <p>Get the deletion date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>due_date</code> <p>Due date of the card in datetime format</p> <p> TYPE: <code>datetime | None</code> </p> <code>labels</code> <p>All labels on the card</p> <p> TYPE: <code>QueryableList[Label]</code> </p> <code>link</code> <p>Get the link to the model instance</p> <p> TYPE: <code>str | None</code> </p> <code>list</code> <p>List the card belongs to</p> <p> TYPE: <code>List</code> </p> <code>members</code> <p>All users assigned to the card</p> <p> TYPE: <code>QueryableList[User]</code> </p> <code>routes</code> <p>Get the routes for the model instance</p> <p> TYPE: <code>Routes</code> </p> <code>tasks</code> <p>All tasks on the card</p> <p> TYPE: <code>QueryableList[Task]</code> </p> <code>unique_name</code> <p>Generate a unique name for the model instance using the last 5 characters of the id</p> <p> TYPE: <code>str</code> </p> <code>updated_at</code> <p>Get the last update date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.attachments","title":"attachments  <code>property</code>","text":"<pre><code>attachments: QueryableList[Attachment]\n</code></pre> <p>All attachments on the card</p> RETURNS DESCRIPTION <code>QueryableList[Attachment]</code> <p>Queryable List of all attachments on the card</p>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.board","title":"board  <code>property</code>","text":"<pre><code>board: Board\n</code></pre> <p>Board the card belongs to</p> RETURNS DESCRIPTION <code>Board</code> <p>Board instance</p> <p> TYPE: <code>Board</code> </p>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.comments","title":"comments  <code>property</code>","text":"<pre><code>comments: QueryableList[Action]\n</code></pre> <p>All comments on the card</p> RETURNS DESCRIPTION <code>QueryableList[Action]</code> <p>Queryable List of all comments on the card</p>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.creator","title":"creator  <code>property</code>","text":"<pre><code>creator: User\n</code></pre> <p>User that created the card</p> RETURNS DESCRIPTION <code>User</code> <p>Creator of the card</p> <p> TYPE: <code>User</code> </p>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.due_date","title":"due_date  <code>property</code>","text":"<pre><code>due_date: datetime | None\n</code></pre> <p>Due date of the card in datetime format</p> Note <p>The <code>dueDate</code> attribute is stored as an ISO 8601 string, this property will return the due date as a python datetime object</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Due date of the card</p>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.labels","title":"labels  <code>property</code>","text":"<pre><code>labels: QueryableList[Label]\n</code></pre> <p>All labels on the card</p> RETURNS DESCRIPTION <code>QueryableList[Label]</code> <p>Queryable List of all labels on the card</p>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.list","title":"list  <code>property</code>","text":"<pre><code>list: List\n</code></pre> <p>List the card belongs to</p> RETURNS DESCRIPTION <code>List</code> <p>List instance</p> <p> TYPE: <code>List</code> </p>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.members","title":"members  <code>property</code>","text":"<pre><code>members: QueryableList[User]\n</code></pre> <p>All users assigned to the card</p> RETURNS DESCRIPTION <code>QueryableList[User]</code> <p>Queryable List of all users assigned to the card</p>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: QueryableList[Task]\n</code></pre> <p>All tasks on the card</p> RETURNS DESCRIPTION <code>QueryableList[Task]</code> <p>Queryable List of all tasks on the card</p>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.add_attachment","title":"add_attachment","text":"<pre><code>add_attachment(file_path: Path) -&gt; Attachment\n</code></pre> <p>Adds an attachment to the card</p> PARAMETER DESCRIPTION <p>Attachment instance to add (can be a file path or url)</p> <p> TYPE: <code>Path | &lt;url&gt;</code> </p> RETURNS DESCRIPTION <code>Attachment</code> <p>New attachment instance</p> <p> TYPE: <code>Attachment</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def add_attachment(self, file_path: Path) -&gt; Attachment:\n    \"\"\"Adds an attachment to the card\n\n    Args:\n        attachment (Path | &lt;url&gt;): Attachment instance to add (can be a file path or url)\n\n    Returns:\n        Attachment: New attachment instance\n    \"\"\"\n    route = self.routes.post_attachment(cardId=self.id)\n    return Attachment(**route(_file=file_path)['item']).bind(self.routes)\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.add_attachment(attachment)","title":"<code>attachment</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.add_comment","title":"add_comment","text":"<pre><code>add_comment(comment: str) -&gt; Action\n</code></pre> <p>Adds a comment to the card</p> Note <p>Comments can only be added by the authenticated user, all comments made through plankapy will be attributed to the user in <code>planka.me</code></p> PARAMETER DESCRIPTION <p>Comment to add</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Action</code> <p>New comment action instance</p> <p> TYPE: <code>Action</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def add_comment(self, comment: str) -&gt; Action:\n    \"\"\"Adds a comment to the card\n\n    Note:\n        Comments can only be added by the authenticated user, all comments made\n        through plankapy will be attributed to the user in `planka.me`\n\n    Args:\n        comment (str): Comment to add\n\n    Returns:\n        Action: New comment action instance\n    \"\"\"\n    route = self.routes.post_comment_action(cardId=self.id)        \n    return Action(**route(text=comment, cardId=self.id)['item']).bind(self.routes)\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.add_comment(comment)","title":"<code>comment</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.add_label","title":"add_label","text":"<pre><code>add_label(label: Label) -&gt; CardLabel\n</code></pre> <p>Adds a label to the card</p> PARAMETER DESCRIPTION <p>Label instance to add</p> <p> TYPE: <code>Label</code> </p> RETURNS DESCRIPTION <code>CardLabel</code> <p>New card label instance</p> <p> TYPE: <code>CardLabel</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def add_label(self, label: Label) -&gt; CardLabel:\n    \"\"\"Adds a label to the card\n\n    Args:\n        label (Label): Label instance to add\n\n    Returns:\n        CardLabel: New card label instance\n    \"\"\"\n    route = self.routes.post_card_label(cardId=self.id)\n    return CardLabel(**route(labelId=label.id, cardId=self.id)['item']).bind(self.routes)\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.add_label(label)","title":"<code>label</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.add_member","title":"add_member","text":"<pre><code>add_member(user: User) -&gt; CardMembership\n</code></pre> <p>Adds a user to the card</p> PARAMETER DESCRIPTION <p>User instance to add</p> <p> TYPE: <code>User</code> </p> RETURNS DESCRIPTION <code>CardMembership</code> <p>New card membership instance</p> <p> TYPE: <code>CardMembership</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def add_member(self, user: User) -&gt; CardMembership:\n    \"\"\"Adds a user to the card\n\n    Args:\n        user (User): User instance to add\n\n    Returns:\n        CardMembership: New card membership instance\n    \"\"\"\n    route = self.routes.post_card_membership(cardId=self.id)\n    return CardMembership(**route(userId=user.id, cardId=self.id)['item']).bind(self.routes)\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.add_member(user)","title":"<code>user</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.add_stopwatch","title":"add_stopwatch","text":"<pre><code>add_stopwatch() -&gt; Stopwatch\n</code></pre> <p>Adds a stopwatch to the card if there is not one already</p> Warning <p>The stopwatch stored in the Card instance dictionary is actually a dictionary that is used to update the stopwatch on Planka. When you access the stopwatch attribute with <code>card.stopwatch</code>, a <code>Stopwatch</code> instance is generated. This is an implementation detail to keep the stopwatch interface separate from the Card interface.</p> <p>Example:     <pre><code>&gt;&gt;&gt; card.add_stopwatch()\n&gt;&gt;&gt; card.stopwatch\nStopwatch(startedAt=None, total=0)\n\n&gt;&gt;&gt; card.__dict__['stopwatch']\n{'startedAt': None, 'total': 0}\n\n&gt;&gt;&gt; card.stopwatch.start()\n&gt;&gt;&gt; card.stopwatch\nStopwatch(startedAt=datetime.datetime(2024, 9, 30, 0, 0, 0), total=0)\n\n&gt;&gt;&gt; card.__dict__['stopwatch']\n{'startedAt': '2024-9-30T00:00:00Z', 'total': 0}\n</code></pre></p> RETURNS DESCRIPTION <code>Stopwatch</code> <p>A stopwatch instance used to track time on the card</p> <p> TYPE: <code>Stopwatch</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def add_stopwatch(self) -&gt; Stopwatch:\n    \"\"\"Adds a stopwatch to the card if there is not one already\n\n    Warning:\n        The stopwatch stored in the Card instance dictionary is actually a dictionary\n        that is used to update the stopwatch on Planka. When you access the stopwatch\n        attribute with `card.stopwatch`, a `Stopwatch` instance is generated. This is\n        an implementation detail to keep the stopwatch interface separate from the Card\n        interface.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; card.add_stopwatch()\n            &gt;&gt;&gt; card.stopwatch\n            Stopwatch(startedAt=None, total=0)\n\n            &gt;&gt;&gt; card.__dict__['stopwatch']\n            {'startedAt': None, 'total': 0}\n\n            &gt;&gt;&gt; card.stopwatch.start()\n            &gt;&gt;&gt; card.stopwatch\n            Stopwatch(startedAt=datetime.datetime(2024, 9, 30, 0, 0, 0), total=0)\n\n            &gt;&gt;&gt; card.__dict__['stopwatch']\n            {'startedAt': '2024-9-30T00:00:00Z', 'total': 0}\n            ```\n\n    Returns:\n        Stopwatch: A stopwatch instance used to track time on the card\n    \"\"\"\n    self.refresh()\n\n    if not self.stopwatch:\n        with self.editor():\n            self.stopwatch = {**Stopwatch(startedAt=None, total=0).stop()}\n    return self.stopwatch\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.add_task","title":"add_task","text":"<pre><code>add_task(task: Task) -&gt; Task\n</code></pre><pre><code>add_task(name: str, position: int = 0, isCompleted: bool = False, isDeleted: bool = False) -&gt; Task\n</code></pre> <pre><code>add_task(*args, **kwargs) -&gt; Task\n</code></pre> <p>Adds a task to the card</p> PARAMETER DESCRIPTION <p>Name of the task (required)</p> <p> TYPE: <code>str</code> </p> <p>Position of the task (default: 0)</p> <p> TYPE: <code>int</code> </p> <p>Whether the task is completed (default: False)</p> <p> TYPE: <code>bool</code> </p> <p>Whether the task is deleted (default: False)</p> <p> TYPE: <code>bool</code> </p> ALTERNATE DESCRIPTION <p>Task instance to create</p> <p> TYPE: <code>Task</code> </p> RETURNS DESCRIPTION <code>Task</code> <p>New task instance</p> <p> TYPE: <code>Task</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def add_task(self, *args, **kwargs) -&gt; Task:\n    \"\"\"Adds a task to the card\n\n    Args:\n        name (str): Name of the task (required)\n        position (int): Position of the task (default: 0)\n        isCompleted (bool): Whether the task is completed (default: False)\n        isDeleted (bool): Whether the task is deleted (default: False)\n\n    Args: Alternate\n        task (Task): Task instance to create\n\n    Returns:\n        Task: New task instance\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='task', \n        options=('name', 'position', 'isCompleted', 'isDeleted'), \n        required=('name',)) # Only name requires user provided value\n\n    route = self.routes.post_task(cardId=self.id)\n\n    # Required arguments with defaults must be manually assigned\n    overload['position'] = overload.get('position', 0)\n    overload['isCompleted'] = overload.get('isCompleted', False)\n    overload['isDeleted'] = overload.get('isDeleted', False)\n\n    return Task(**route(**overload)['item']).bind(self.routes)\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.add_task(name)","title":"<code>name</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.add_task(position)","title":"<code>position</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.add_task(isCompleted)","title":"<code>isCompleted</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.add_task(isDeleted)","title":"<code>isDeleted</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.add_task(task)","title":"<code>task</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.delete","title":"delete","text":"<pre><code>delete() -&gt; Card\n</code></pre> <p>Deletes the card</p> Danger <p>This action is irreversible and cannot be undone</p> RETURNS DESCRIPTION <code>Card</code> <p>The deleted card instance</p> <p> TYPE: <code>Card</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def delete(self) -&gt; Card:\n    \"\"\"Deletes the card\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        Card: The deleted card instance\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_card(id=self.id)\n    route()\n    return self\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.duplicate","title":"duplicate","text":"<pre><code>duplicate() -&gt; Card\n</code></pre> <p>Duplicates the card</p> Note <p>Duplicating a card will always insert it one slot below the original card</p> RETURNS DESCRIPTION <code>Card</code> <p>The duplicated card instance</p> <p> TYPE: <code>Card</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def duplicate(self) -&gt; Card:\n    \"\"\"Duplicates the card\n\n    Note:\n        Duplicating a card will always insert it one slot below the original card\n\n    Returns:\n        Card: The duplicated card instance\n    \"\"\"\n    route = self.routes.post_duplicate_card(id=self.id)\n    return Card(**route(**self)['item']).bind(self.routes)\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.move","title":"move","text":"<pre><code>move(list: List) -&gt; Card\n</code></pre> <p>Moves the card to a new list</p> PARAMETER DESCRIPTION <p>List instance to move the card to</p> <p> TYPE: <code>List</code> </p> RETURNS DESCRIPTION <code>Card</code> <p>The moved card instance</p> <p> TYPE: <code>Card</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def move(self, list: List) -&gt; Card:\n    \"\"\"Moves the card to a new list\n\n    Args:\n        list (List): List instance to move the card to\n\n    Returns:\n        Card: The moved card instance\n    \"\"\"\n    self.listId = list.id\n    self.boardId = list.boardId\n    self.update()\n    return self\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.move(list)","title":"<code>list</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>Refreshes the card data</p> Note <p>This method is used to update the card instance with the latest data from the server</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def refresh(self):\n    \"\"\"Refreshes the card data\n\n    Note:\n        This method is used to update the card instance with the latest data from the server\n    \"\"\"\n    route = self.routes.get_card(id=self.id)\n    self.__init__(**route()['item'])\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.remove_attachment","title":"remove_attachment","text":"<pre><code>remove_attachment(attachment: Attachment) -&gt; Attachment | None\n</code></pre> <p>Removes an attachment from the card</p> PARAMETER DESCRIPTION <p>Attachment instance to remove</p> <p> TYPE: <code>Attachment</code> </p> Note <p>This method will remove the attachment from the card, but the attachment itself will not be deleted</p> RETURNS DESCRIPTION <code>Card</code> <p>The card instance with the attachment removed</p> <p> TYPE: <code>Attachment | None</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def remove_attachment(self, attachment: Attachment) -&gt; Attachment | None:\n    \"\"\"Removes an attachment from the card\n\n    Args:\n        attachment (Attachment): Attachment instance to remove\n\n    Note:\n        This method will remove the attachment from the card, but the attachment itself will not be deleted\n\n    Returns:\n        Card: The card instance with the attachment removed\n    \"\"\"\n    for card_attachment in self.attachments:\n        if card_attachment.id == attachment.id:\n            return card_attachment.delete()\n    return None\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.remove_attachment(attachment)","title":"<code>attachment</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.remove_comment","title":"remove_comment","text":"<pre><code>remove_comment(comment_action: Action) -&gt; Card\n</code></pre> <p>Pass a comment from self.comments to remove it</p> PARAMETER DESCRIPTION <p>Comment instance to remove</p> <p> TYPE: <code>Action</code> </p> Note <p>This method will remove the comment from the card, but the comment itself will not be deleted</p> RETURNS DESCRIPTION <code>Card</code> <p>The card instance with the comment removed</p> <p> TYPE: <code>Card</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def remove_comment(self, comment_action: Action) -&gt; Card:\n    \"\"\"Pass a comment from self.comments to remove it\n\n    Args:\n        comment_action (Action): Comment instance to remove\n\n    Note:\n        This method will remove the comment from the card, but the comment itself will not be deleted\n\n    Returns:\n        Card: The card instance with the comment removed\n    \"\"\"\n    for comment in self.comments:\n        if comment.id == comment_action.id:\n            comment.delete()\n    return self\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.remove_comment(comment_action)","title":"<code>comment_action</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.remove_label","title":"remove_label","text":"<pre><code>remove_label(label: Label) -&gt; Card\n</code></pre> <p>Removes a label from the card</p> PARAMETER DESCRIPTION <p>Label instance to remove</p> <p> TYPE: <code>Label</code> </p> Note <p>This method will remove the label from the card, but the label itself will not be deleted</p> RETURNS DESCRIPTION <code>Card</code> <p>The card instance with the label removed</p> <p> TYPE: <code>Card</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def remove_label(self, label: Label) -&gt; Card:\n    \"\"\"Removes a label from the card\n\n    Args:\n        label (Label): Label instance to remove\n\n    Note:\n        This method will remove the label from the card, but the label itself will not be deleted\n\n    Returns:\n        Card: The card instance with the label removed   \n    \"\"\"\n    for card_label in self.board.cardLabels:\n        if card_label.cardId == self.id and card_label.labelId == label.id:\n            card_label.delete()\n    return self\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.remove_label(label)","title":"<code>label</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.remove_member","title":"remove_member","text":"<pre><code>remove_member(user: User) -&gt; Card\n</code></pre> <p>Removes a user from the card</p> PARAMETER DESCRIPTION <p>User instance to remove</p> <p> TYPE: <code>User</code> </p> Note <p>This method will remove the user from the card, but the user itself will not be deleted</p> RETURNS DESCRIPTION <code>Card</code> <p>The card instance with the user removed</p> <p> TYPE: <code>Card</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def remove_member(self, user: User) -&gt; Card:\n    \"\"\"Removes a user from the card\n\n    Args:\n        user (User): User instance to remove\n\n    Note:\n        This method will remove the user from the card, but the user itself will not be deleted\n\n    Returns:\n        Card: The card instance with the user removed\n    \"\"\"\n    for card_membership in self.board.cardMemberships:\n        if card_membership.cardId == self.id and card_membership.userId == user.id:\n            card_membership.delete()\n    return self\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.remove_member(user)","title":"<code>user</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.remove_stopwatch","title":"remove_stopwatch","text":"<pre><code>remove_stopwatch() -&gt; Stopwatch\n</code></pre> <p>Removes the stopwatch from the card</p> RETURNS DESCRIPTION <code>Stopwatch</code> <p>The stopwatch instance that was removed</p> <p> TYPE: <code>Stopwatch</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def remove_stopwatch(self) -&gt; Stopwatch:\n    \"\"\"Removes the stopwatch from the card\n\n    Returns:\n        Stopwatch: The stopwatch instance that was removed\n    \"\"\"\n    self.refresh()\n    with self.editor():\n        _stopwatch = self.stopwatch\n        self.stopwatch = None\n    return _stopwatch\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.set_due_date","title":"set_due_date","text":"<pre><code>set_due_date(due_date: datetime | None) -&gt; Card\n</code></pre> <p>Sets the due date of the card</p> PARAMETER DESCRIPTION <p>Due date of the card (None to remove)</p> <p> TYPE: <code>datetime</code> </p> RETURNS DESCRIPTION <code>Card</code> <p>The card instance with the due date set</p> <p> TYPE: <code>Card</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def set_due_date(self, due_date: datetime  | None) -&gt; Card:\n    \"\"\"Sets the due date of the card\n\n    Args:\n        dueDate (datetime): Due date of the card (None to remove)\n\n    Returns:\n        Card: The card instance with the due date set\n    \"\"\"\n    with self.editor():\n        self.dueDate = due_date.isoformat() if due_date else None\n    return self\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.set_due_date(dueDate)","title":"<code>dueDate</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.update","title":"update","text":"<pre><code>update() -&gt; Card\n</code></pre><pre><code>update(card: Card) -&gt; Card\n</code></pre><pre><code>update(name: str, position: int = 0, description: str = None, dueDate: datetime = None, isDueDateCompleted: bool = None, stopwatch: Stopwatch = None, boardId: int = None, listId: int = None, creatorUserId: int = None, coverAttachmentId: int = None, isSubscribed: bool = None) -&gt; Card\n</code></pre> <pre><code>update(*args, **kwargs) -&gt; Card\n</code></pre> <p>Updates the card with new values</p> Tip <p>It's recommended to use a <code>card.editor()</code> context manager to update the card</p> <p>Example: ```python</p> <p>with card.editor(): ...    card.name='New Name'</p> <p>card Card(name='New Name', ...) ``</p> PARAMETER DESCRIPTION <p>Name of the card (optional)</p> <p> TYPE: <code>str</code> </p> <p>Position of the card (optional)</p> <p> TYPE: <code>int</code> </p> <p>Description of the card (optional)</p> <p> TYPE: <code>str</code> </p> <p>Due date of the card (optional)</p> <p> TYPE: <code>datetime</code> </p> <p>Whether the due date is completed (optional)</p> <p> TYPE: <code>bool</code> </p> <p>Stopwatch of the card (optional)</p> <p> TYPE: <code>Stopwatch</code> </p> <p>Board id of the card (optional)</p> <p> TYPE: <code>int</code> </p> <p>List id of the card (optional)</p> <p> TYPE: <code>int</code> </p> <p>Creator user id of the card (optional)</p> <p> TYPE: <code>int</code> </p> <p>Cover attachment id of the card (optional)</p> <p> TYPE: <code>int</code> </p> <p>Whether the card is subscribed (optional)</p> <p> TYPE: <code>bool</code> </p> ALTERNATE DESCRIPTION <p>Card instance to update (required)</p> <p> TYPE: <code>Card</code> </p> Note <p>If no arguments are provided, the card will update itself with the current values stored in its attributes</p> RETURNS DESCRIPTION <code>Card</code> <p>Updated card instance</p> <p> TYPE: <code>Card</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def update(self, *args, **kwargs) -&gt; Card:\n    \"\"\"Updates the card with new values\n\n    Tip:\n        It's recommended to use a `card.editor()` context manager to update the card\n\n        Example:\n        ```python\n        &gt;&gt;&gt; with card.editor():\n        ...    card.name='New Name'\n\n        &gt;&gt;&gt; card\n        Card(name='New Name', ...)\n        ``\n\n    Args:\n        name (str): Name of the card (optional)\n        position (int): Position of the card (optional)\n        description (str): Description of the card (optional)\n        dueDate (datetime): Due date of the card (optional)\n        isDueDateCompleted (bool): Whether the due date is completed (optional)\n        stopwatch (Stopwatch): Stopwatch of the card (optional)\n        boardId (int): Board id of the card (optional)\n        listId (int): List id of the card (optional)\n        creatorUserId (int): Creator user id of the card (optional)\n        coverAttachmentId (int): Cover attachment id of the card (optional)\n        isSubscribed (bool): Whether the card is subscribed (optional)\n\n    Args: Alternate\n        card (Card): Card instance to update (required)\n\n    Note:\n        If no arguments are provided, the card will update itself with the current values stored in its attributes\n\n    Returns:\n        Card: Updated card instance\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='card', \n        options=('name', 'position', 'description', 'dueDate', \n                'isDueDateCompleted', 'stopwatch', \n                'creatorUserId', 'coverAttachmentId', \n                'isSubscribed'), \n        noarg=self)\n\n    route = self.routes.patch_card(id=self.id)\n    self.__init__(**route(**overload)['item'])\n    return self\n</code></pre>"},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.update(name)","title":"<code>name</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.update(position)","title":"<code>position</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.update(description)","title":"<code>description</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.update(dueDate)","title":"<code>dueDate</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.update(isDueDateCompleted)","title":"<code>isDueDateCompleted</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.update(stopwatch)","title":"<code>stopwatch</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.update(boardId)","title":"<code>boardId</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.update(listId)","title":"<code>listId</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.update(creatorUserId)","title":"<code>creatorUserId</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.update(coverAttachmentId)","title":"<code>coverAttachmentId</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.update(isSubscribed)","title":"<code>isSubscribed</code>","text":""},{"location":"v1/interfaces/Card/#plankapy.v1.interfaces.Card.update(card)","title":"<code>card</code>","text":""},{"location":"v1/interfaces/CardLabel/","title":"CardLabel","text":"<p>               Bases: <code>CardLabel_</code></p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Deletes the card label relationship</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>\"Refresh the model instance</p> <code>update</code> <p>Update the model instance</p> ATTRIBUTE DESCRIPTION <code>board</code> <p>Board the card belongs to</p> <p> TYPE: <code>Board</code> </p> <code>card</code> <p>Card the label is attached to</p> <p> TYPE: <code>Card</code> </p> <code>created_at</code> <p>Get the creation date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>deleted_at</code> <p>Get the deletion date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>label</code> <p>Label attached to the card</p> <p> TYPE: <code>Label</code> </p> <code>link</code> <p>Get the link to the model instance</p> <p> TYPE: <code>str | None</code> </p> <code>routes</code> <p>Get the routes for the model instance</p> <p> TYPE: <code>Routes</code> </p> <code>unique_name</code> <p>Generate a unique name for the model instance using the last 5 characters of the id</p> <p> TYPE: <code>str</code> </p> <code>updated_at</code> <p>Get the last update date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p>"},{"location":"v1/interfaces/CardLabel/#plankapy.v1.interfaces.CardLabel.board","title":"board  <code>property</code>","text":"<pre><code>board: Board\n</code></pre> <p>Board the card belongs to</p> RETURNS DESCRIPTION <code>Board</code> <p>Board instance</p> <p> TYPE: <code>Board</code> </p>"},{"location":"v1/interfaces/CardLabel/#plankapy.v1.interfaces.CardLabel.card","title":"card  <code>property</code>","text":"<pre><code>card: Card\n</code></pre> <p>Card the label is attached to</p> RETURNS DESCRIPTION <code>Card</code> <p>Card instance</p> <p> TYPE: <code>Card</code> </p>"},{"location":"v1/interfaces/CardLabel/#plankapy.v1.interfaces.CardLabel.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/interfaces/CardLabel/#plankapy.v1.interfaces.CardLabel.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/interfaces/CardLabel/#plankapy.v1.interfaces.CardLabel.label","title":"label  <code>property</code>","text":"<pre><code>label: Label\n</code></pre> <p>Label attached to the card</p> RETURNS DESCRIPTION <code>Label</code> <p>Label instance</p> <p> TYPE: <code>Label</code> </p>"},{"location":"v1/interfaces/CardLabel/#plankapy.v1.interfaces.CardLabel.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/interfaces/CardLabel/#plankapy.v1.interfaces.CardLabel.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/interfaces/CardLabel/#plankapy.v1.interfaces.CardLabel.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/interfaces/CardLabel/#plankapy.v1.interfaces.CardLabel.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/interfaces/CardLabel/#plankapy.v1.interfaces.CardLabel.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/interfaces/CardLabel/#plankapy.v1.interfaces.CardLabel.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/interfaces/CardLabel/#plankapy.v1.interfaces.CardLabel.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/interfaces/CardLabel/#plankapy.v1.interfaces.CardLabel.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/interfaces/CardLabel/#plankapy.v1.interfaces.CardLabel.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/interfaces/CardLabel/#plankapy.v1.interfaces.CardLabel.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/interfaces/CardLabel/#plankapy.v1.interfaces.CardLabel.delete","title":"delete","text":"<pre><code>delete() -&gt; tuple[Card, Label]\n</code></pre> <p>Deletes the card label relationship</p> Danger <p>This action is irreversible and cannot be undone</p> RETURNS DESCRIPTION <code>tuple[Card, Label]</code> <p>tuple[Card, Label]: The card and label that were removed from each other</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def delete(self) -&gt; tuple[Card, Label]:\n    \"\"\"Deletes the card label relationship\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        tuple[Card, Label]: The card and label that were removed from each other\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_card_label(cardId=self.card.id, labelId=self.labelId)\n    route()\n    return (self.card, self.label)\n</code></pre>"},{"location":"v1/interfaces/CardLabel/#plankapy.v1.interfaces.CardLabel.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/interfaces/CardLabel/#plankapy.v1.interfaces.CardLabel.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/interfaces/CardLabel/#plankapy.v1.interfaces.CardLabel.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/interfaces/CardLabel/#plankapy.v1.interfaces.CardLabel.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>\"Refresh the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def refresh(self): \n    \"\"\"\"Refresh the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/interfaces/CardLabel/#plankapy.v1.interfaces.CardLabel.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/interfaces/CardMembership/","title":"CardMembership","text":"<p>               Bases: <code>CardMembership_</code></p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Deletes the card membership</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>\"Refresh the model instance</p> <code>update</code> <p>Update the model instance</p> ATTRIBUTE DESCRIPTION <code>card</code> <p>Card the user is a member of</p> <p> TYPE: <code>Card</code> </p> <code>created_at</code> <p>Get the creation date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>deleted_at</code> <p>Get the deletion date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>link</code> <p>Get the link to the model instance</p> <p> TYPE: <code>str | None</code> </p> <code>routes</code> <p>Get the routes for the model instance</p> <p> TYPE: <code>Routes</code> </p> <code>unique_name</code> <p>Generate a unique name for the model instance using the last 5 characters of the id</p> <p> TYPE: <code>str</code> </p> <code>updated_at</code> <p>Get the last update date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>user</code> <p>User that is a member of the card</p> <p> TYPE: <code>User</code> </p>"},{"location":"v1/interfaces/CardMembership/#plankapy.v1.interfaces.CardMembership.card","title":"card  <code>property</code>","text":"<pre><code>card: Card\n</code></pre> <p>Card the user is a member of</p> RETURNS DESCRIPTION <code>Card</code> <p>Card instance</p> <p> TYPE: <code>Card</code> </p>"},{"location":"v1/interfaces/CardMembership/#plankapy.v1.interfaces.CardMembership.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/interfaces/CardMembership/#plankapy.v1.interfaces.CardMembership.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/interfaces/CardMembership/#plankapy.v1.interfaces.CardMembership.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/interfaces/CardMembership/#plankapy.v1.interfaces.CardMembership.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/interfaces/CardMembership/#plankapy.v1.interfaces.CardMembership.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/interfaces/CardMembership/#plankapy.v1.interfaces.CardMembership.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/interfaces/CardMembership/#plankapy.v1.interfaces.CardMembership.user","title":"user  <code>property</code>","text":"<pre><code>user: User\n</code></pre> <p>User that is a member of the card</p> RETURNS DESCRIPTION <code>User</code> <p>User instance</p> <p> TYPE: <code>User</code> </p>"},{"location":"v1/interfaces/CardMembership/#plankapy.v1.interfaces.CardMembership.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/interfaces/CardMembership/#plankapy.v1.interfaces.CardMembership.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/interfaces/CardMembership/#plankapy.v1.interfaces.CardMembership.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/interfaces/CardMembership/#plankapy.v1.interfaces.CardMembership.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/interfaces/CardMembership/#plankapy.v1.interfaces.CardMembership.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/interfaces/CardMembership/#plankapy.v1.interfaces.CardMembership.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/interfaces/CardMembership/#plankapy.v1.interfaces.CardMembership.delete","title":"delete","text":"<pre><code>delete() -&gt; tuple[User, Card]\n</code></pre> <p>Deletes the card membership</p> Danger <p>This action is irreversible and cannot be undone</p> RETURNS DESCRIPTION <code>tuple[User, Card]</code> <p>tuple[User, Card]: The user and card that were removed from each other</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def delete(self) -&gt; tuple[User, Card]:\n    \"\"\"Deletes the card membership\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        tuple[User, Card]: The user and card that were removed from each other\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_card_membership(id=self.id)\n    route()\n    return (self.user, self.card)\n</code></pre>"},{"location":"v1/interfaces/CardMembership/#plankapy.v1.interfaces.CardMembership.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/interfaces/CardMembership/#plankapy.v1.interfaces.CardMembership.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/interfaces/CardMembership/#plankapy.v1.interfaces.CardMembership.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/interfaces/CardMembership/#plankapy.v1.interfaces.CardMembership.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>\"Refresh the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def refresh(self): \n    \"\"\"\"Refresh the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/interfaces/CardMembership/#plankapy.v1.interfaces.CardMembership.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/interfaces/CardSubscription/","title":"CardSubscription","text":"<p>               Bases: <code>CardSubscription_</code></p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Delete the model instance</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>\"Refresh the model instance</p> <code>update</code> <p>Update the model instance</p> ATTRIBUTE DESCRIPTION <code>card</code> <p>Card the user is subscribed to</p> <p> TYPE: <code>Card</code> </p> <code>created_at</code> <p>Get the creation date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>deleted_at</code> <p>Get the deletion date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>link</code> <p>Get the link to the model instance</p> <p> TYPE: <code>str | None</code> </p> <code>routes</code> <p>Get the routes for the model instance</p> <p> TYPE: <code>Routes</code> </p> <code>unique_name</code> <p>Generate a unique name for the model instance using the last 5 characters of the id</p> <p> TYPE: <code>str</code> </p> <code>updated_at</code> <p>Get the last update date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>user</code> <p>User that is subscribed to the card</p> <p> TYPE: <code>User</code> </p>"},{"location":"v1/interfaces/CardSubscription/#plankapy.v1.interfaces.CardSubscription.card","title":"card  <code>property</code>","text":"<pre><code>card: Card\n</code></pre> <p>Card the user is subscribed to</p> RETURNS DESCRIPTION <code>Card</code> <p>Card instance</p> <p> TYPE: <code>Card</code> </p>"},{"location":"v1/interfaces/CardSubscription/#plankapy.v1.interfaces.CardSubscription.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/interfaces/CardSubscription/#plankapy.v1.interfaces.CardSubscription.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/interfaces/CardSubscription/#plankapy.v1.interfaces.CardSubscription.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/interfaces/CardSubscription/#plankapy.v1.interfaces.CardSubscription.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/interfaces/CardSubscription/#plankapy.v1.interfaces.CardSubscription.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/interfaces/CardSubscription/#plankapy.v1.interfaces.CardSubscription.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/interfaces/CardSubscription/#plankapy.v1.interfaces.CardSubscription.user","title":"user  <code>property</code>","text":"<pre><code>user: User\n</code></pre> <p>User that is subscribed to the card</p> RETURNS DESCRIPTION <code>User</code> <p>User instance</p> <p> TYPE: <code>User</code> </p>"},{"location":"v1/interfaces/CardSubscription/#plankapy.v1.interfaces.CardSubscription.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/interfaces/CardSubscription/#plankapy.v1.interfaces.CardSubscription.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/interfaces/CardSubscription/#plankapy.v1.interfaces.CardSubscription.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/interfaces/CardSubscription/#plankapy.v1.interfaces.CardSubscription.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/interfaces/CardSubscription/#plankapy.v1.interfaces.CardSubscription.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/interfaces/CardSubscription/#plankapy.v1.interfaces.CardSubscription.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/interfaces/CardSubscription/#plankapy.v1.interfaces.CardSubscription.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/interfaces/CardSubscription/#plankapy.v1.interfaces.CardSubscription.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/interfaces/CardSubscription/#plankapy.v1.interfaces.CardSubscription.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/interfaces/CardSubscription/#plankapy.v1.interfaces.CardSubscription.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/interfaces/CardSubscription/#plankapy.v1.interfaces.CardSubscription.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>\"Refresh the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def refresh(self): \n    \"\"\"\"Refresh the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/interfaces/CardSubscription/#plankapy.v1.interfaces.CardSubscription.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/interfaces/IdentityProviderUser/","title":"IdentityProviderUser","text":""},{"location":"v1/interfaces/Label/","title":"Label","text":"<p>               Bases: <code>Label_</code></p> <p>Interface for interacting with planka Labels</p> Note <p>Label Colors are defined in the <code>LabelColor</code> Literal currently:</p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Deletes the label</p> <code>editor</code> <p>Context manager for editing the model</p> <code>hex_color</code> <p>Returns the hex color of the label</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>Refreshes the label data</p> <code>update</code> <p>Updates the label with new values</p> ATTRIBUTE DESCRIPTION <code>board</code> <p>Board the label belongs to</p> <p> TYPE: <code>Board</code> </p> <code>cards</code> <p>All cards with the label in the board</p> <p> TYPE: <code>QueryableList[Card]</code> </p> <code>created_at</code> <p>Get the creation date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>deleted_at</code> <p>Get the deletion date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>link</code> <p>Get the link to the model instance</p> <p> TYPE: <code>str | None</code> </p> <code>routes</code> <p>Get the routes for the model instance</p> <p> TYPE: <code>Routes</code> </p> <code>unique_name</code> <p>Generate a unique name for the model instance using the last 5 characters of the id</p> <p> TYPE: <code>str</code> </p> <code>updated_at</code> <p>Get the last update date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p>"},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.board","title":"board  <code>property</code>","text":"<pre><code>board: Board\n</code></pre> <p>Board the label belongs to</p> RETURNS DESCRIPTION <code>Board</code> <p>Board instance</p> <p> TYPE: <code>Board</code> </p>"},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.cards","title":"cards  <code>property</code>","text":"<pre><code>cards: QueryableList[Card]\n</code></pre> <p>All cards with the label in the board</p> RETURNS DESCRIPTION <code>QueryableList[Card]</code> <p>Queryable List of all cards with the label in the board</p>"},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.delete","title":"delete","text":"<pre><code>delete() -&gt; Label\n</code></pre> <p>Deletes the label</p> Danger <p>This action is irreversible and cannot be undone</p> RETURNS DESCRIPTION <code>Label</code> <p>Deleted label instance</p> <p> TYPE: <code>Label</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def delete(self) -&gt; Label:\n    \"\"\"Deletes the label\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        Label: Deleted label instance\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_label(id=self.id)\n    route()\n    return self\n</code></pre>"},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.hex_color","title":"hex_color","text":"<pre><code>hex_color() -&gt; str\n</code></pre> <p>Returns the hex color of the label</p> RETURNS DESCRIPTION <code>str</code> <p>Hex color of the label</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def hex_color(self) -&gt; str:\n    \"\"\"Returns the hex color of the label\n\n    Returns:\n        str: Hex color of the label\n    \"\"\"\n    return self.colors_to_hex[self.color]\n</code></pre>"},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.refresh","title":"refresh","text":"<pre><code>refresh() -&gt; None\n</code></pre> <p>Refreshes the label data</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshes the label data\"\"\"\n    for label in self.board.labels:\n        if label.id == self.id:\n            self.__init__(**label)\n</code></pre>"},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.update","title":"update","text":"<pre><code>update() -&gt; Label\n</code></pre><pre><code>update(label: Label) -&gt; Label\n</code></pre><pre><code>update(name: str = None, color: LabelColor = None, position: int = None) -&gt; Label\n</code></pre> <pre><code>update(*args, **kwargs) -&gt; Label\n</code></pre> <p>Updates the label with new values</p> Tip <p>Use <code>.editor()</code> context manager to update the label with the user as an editor</p> <p>Example: ```python</p> <p>with label.editor(): ...    label.name = 'My New Label' ...    label.color = 'lagoon-blue'</p> <p>label Label(name='My New Label', color='lagoon-blue', position=0, ...) ``</p> PARAMETER DESCRIPTION <p>Name of the label (optional)</p> <p> TYPE: <code>str</code> </p> <p>Color of the label (optional)</p> <p> TYPE: <code>LabelColor</code> </p> <p>Position of the label (optional)</p> <p> TYPE: <code>int</code> </p> ALTERNATE DESCRIPTION <p>Label instance to update with</p> <p> TYPE: <code>Label</code> </p> RETURNS DESCRIPTION <code>Label</code> <p>Updated label instance</p> <p> TYPE: <code>Label</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the color is not in the available colors</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def update(self, *args, **kwargs) -&gt; Label:\n    \"\"\"Updates the label with new values\n\n    Tip:\n        Use `.editor()` context manager to update the label with the user as an editor\n\n        Example:\n        ```python\n        &gt;&gt;&gt; with label.editor():\n        ...    label.name = 'My New Label'\n        ...    label.color = 'lagoon-blue'\n\n        &gt;&gt;&gt; label\n        Label(name='My New Label', color='lagoon-blue', position=0, ...)\n        ``\n\n    Args:\n        name (str): Name of the label (optional)\n        color (LabelColor): Color of the label (optional)\n        position (int): Position of the label (optional)\n\n    Args: Alternate\n        label (Label): Label instance to update with\n\n    Returns:\n        Label: Updated label instance\n\n    Raises:\n        ValueError: If the color is not in the available colors\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='label', \n        options=('name', 'color', 'position'),\n        noarg=self)\n\n    if 'color' in overload and overload['color'] not in self.colors:\n        raise ValueError(\n            f\"Invalid color: {overload['color']}\\n\"\n            f\"Valid colors: {self.colors}\")\n\n    route = self.routes.patch_label(id=self.id)\n    self.__init__(**route(**overload)['item'])\n    return self\n</code></pre>"},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.update(name)","title":"<code>name</code>","text":""},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.update(color)","title":"<code>color</code>","text":""},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.update(position)","title":"<code>position</code>","text":""},{"location":"v1/interfaces/Label/#plankapy.v1.interfaces.Label.update(label)","title":"<code>label</code>","text":""},{"location":"v1/interfaces/List/","title":"List","text":"<p>               Bases: <code>List_</code></p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>create_card</code> <p>Creates a card in the list</p> <code>delete</code> <p>Deletes the list</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>Refreshes the list data</p> <code>set_color</code> <p>Sets the color of the list</p> <code>sort_by_due_date</code> <p>Sorts cards in the list by due date</p> <code>sort_by_name</code> <p>Sorts cards in the list by name</p> <code>sort_by_newest</code> <p>Sorts cards in the list by newest first</p> <code>sort_by_oldest</code> <p>Sorts cards in the list by oldest first</p> <code>update</code> <p>Updates the list with new values</p> ATTRIBUTE DESCRIPTION <code>board</code> <p>Board the list belongs to</p> <p> TYPE: <code>Board</code> </p> <code>cards</code> <p>All cards in the list</p> <p> TYPE: <code>QueryableList[Card]</code> </p> <code>created_at</code> <p>Get the creation date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>deleted_at</code> <p>Get the deletion date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>link</code> <p>Get the link to the model instance</p> <p> TYPE: <code>str | None</code> </p> <code>routes</code> <p>Get the routes for the model instance</p> <p> TYPE: <code>Routes</code> </p> <code>unique_name</code> <p>Generate a unique name for the model instance using the last 5 characters of the id</p> <p> TYPE: <code>str</code> </p> <code>updated_at</code> <p>Get the last update date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.board","title":"board  <code>property</code>","text":"<pre><code>board: Board\n</code></pre> <p>Board the list belongs to</p> RETURNS DESCRIPTION <code>Board</code> <p>Board instance</p> <p> TYPE: <code>Board</code> </p>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.cards","title":"cards  <code>property</code>","text":"<pre><code>cards: QueryableList[Card]\n</code></pre> <p>All cards in the list</p> RETURNS DESCRIPTION <code>QueryableList[Card]</code> <p>Queryable List of all cards in the list</p>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.create_card","title":"create_card","text":"<pre><code>create_card(card: Card) -&gt; Card\n</code></pre><pre><code>create_card(name: str, position: int = 0, description: str = None, dueDate: datetime = None, isDueDateCompleted: bool = None, stopwatch: Stopwatch = None, boardId: int = None, listId: int = None, creatorUserId: int = None, coverAttachmentId: int = None, isSubscribed: bool = None) -&gt; Card\n</code></pre> <pre><code>create_card(*args, **kwargs) -&gt; Card\n</code></pre> <p>Creates a card in the list</p> PARAMETER DESCRIPTION <p>Name of the card (required)</p> <p> TYPE: <code>str</code> </p> <p>Position of the card (default: 0)</p> <p> TYPE: <code>int</code> </p> <p>Description of the card (optional)</p> <p> TYPE: <code>str</code> </p> <p>Due date of the card (optional)</p> <p> TYPE: <code>datetime</code> </p> <p>Whether the due date is completed (optional)</p> <p> TYPE: <code>bool</code> </p> <p>Stopwatch of the card (optional)</p> <p> TYPE: <code>Stopwatch</code> </p> <p>Board id of the card (optional)</p> <p> TYPE: <code>int</code> </p> <p>List id of the card (optional)</p> <p> TYPE: <code>int</code> </p> <p>Creator user id of the card (optional)</p> <p> TYPE: <code>int</code> </p> <p>Cover attachment id of the card (optional)</p> <p> TYPE: <code>int</code> </p> <p>Whether the card is subscribed (optional)</p> <p> TYPE: <code>bool</code> </p> ALTERNATE DESCRIPTION <p>Card instance to create</p> <p> TYPE: <code>Card</code> </p> RETURNS DESCRIPTION <code>Card</code> <p>New card instance</p> <p> TYPE: <code>Card</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def create_card(self, *args, **kwargs) -&gt; Card:\n    \"\"\"Creates a card in the list\n\n    Args:\n        name (str): Name of the card (required)\n        position (int): Position of the card (default: 0)\n        description (str): Description of the card (optional)\n        dueDate (datetime): Due date of the card (optional)\n        isDueDateCompleted (bool): Whether the due date is completed (optional)\n        stopwatch (Stopwatch): Stopwatch of the card (optional)\n        boardId (int): Board id of the card (optional)\n        listId (int): List id of the card (optional)\n        creatorUserId (int): Creator user id of the card (optional)\n        coverAttachmentId (int): Cover attachment id of the card (optional)\n        isSubscribed (bool): Whether the card is subscribed (optional)\n\n    Args: Alternate\n        card (Card): Card instance to create\n\n    Returns:\n        Card: New card instance\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='card', \n        options=('name', 'position', 'description', 'dueDate', \n                'isDueDateCompleted', 'stopwatch', \n                'creatorUserId', 'coverAttachmentId', \n                'isSubscribed'), \n        required=('name',))\n\n    overload['boardId'] = self.boardId\n    overload['listId'] = self.id\n    overload['position'] = overload.get('position', 0)\n\n    route = self.routes.post_card(id=self.id)\n    return Card(**route(**overload)['item']).bind(self.routes)\n</code></pre>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.create_card(name)","title":"<code>name</code>","text":""},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.create_card(position)","title":"<code>position</code>","text":""},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.create_card(description)","title":"<code>description</code>","text":""},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.create_card(dueDate)","title":"<code>dueDate</code>","text":""},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.create_card(isDueDateCompleted)","title":"<code>isDueDateCompleted</code>","text":""},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.create_card(stopwatch)","title":"<code>stopwatch</code>","text":""},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.create_card(boardId)","title":"<code>boardId</code>","text":""},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.create_card(listId)","title":"<code>listId</code>","text":""},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.create_card(creatorUserId)","title":"<code>creatorUserId</code>","text":""},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.create_card(coverAttachmentId)","title":"<code>coverAttachmentId</code>","text":""},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.create_card(isSubscribed)","title":"<code>isSubscribed</code>","text":""},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.create_card(card)","title":"<code>card</code>","text":""},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.delete","title":"delete","text":"<pre><code>delete() -&gt; List\n</code></pre> <p>Deletes the list</p> Danger <p>This action is irreversible and cannot be undone</p> RETURNS DESCRIPTION <code>List</code> <p>Deleted list instance</p> <p> TYPE: <code>List</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def delete(self) -&gt; List:\n    \"\"\"Deletes the list\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        List: Deleted list instance\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_list(id=self.id)\n    route()\n    return self\n</code></pre>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.refresh","title":"refresh","text":"<pre><code>refresh() -&gt; None\n</code></pre> <p>Refreshes the list data</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshes the list data\"\"\"\n    for _list in self.board.lists:\n        if _list.id == self.id:\n            self.__init__(**_list)\n</code></pre>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.set_color","title":"set_color","text":"<pre><code>set_color(color: ListColors) -&gt; List\n</code></pre> <p>Sets the color of the list</p> Note <p>This method is only available in Planka 2.0.0 and later</p> PARAMETER DESCRIPTION <p>Color of the list</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>List</code> <p>The list instance with the color set</p> <p> TYPE: <code>List</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def set_color(self, color: ListColors) -&gt; List:\n    \"\"\"Sets the color of the list\n\n    Note:\n        This method is only available in Planka 2.0.0 and later\n\n    Args:\n        color (str): Color of the list\n\n    Returns:\n        List: The list instance with the color set\n    \"\"\"\n    if color not in ListColors.__args__:\n        raise ValueError(\n            f\"Invalid color: {color}\\n\"\n            f\"Valid colors: {ListColors.__args__}\")\n    with self.editor():\n        self.color = color\n    return self\n</code></pre>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.set_color(color)","title":"<code>color</code>","text":""},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.sort_by_due_date","title":"sort_by_due_date","text":"<pre><code>sort_by_due_date() -&gt; None\n</code></pre> <p>Sorts cards in the list by due date</p> Note <p>After sorting, a call to <code>list.cards</code> will return a sorted list of cards</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def sort_by_due_date(self) -&gt; None:\n    \"\"\"Sorts cards in the list by due date\n\n    Note:\n        After sorting, a call to `list.cards` will return a sorted list of cards\n    \"\"\"\n    self._sort('Due date')\n</code></pre>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.sort_by_name","title":"sort_by_name","text":"<pre><code>sort_by_name() -&gt; None\n</code></pre> <p>Sorts cards in the list by name</p> Note <p>After sorting, a call to <code>list.cards</code> will return a sorted list of cards</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def sort_by_name(self) -&gt; None:\n    \"\"\"Sorts cards in the list by name\n\n    Note:\n        After sorting, a call to `list.cards` will return a sorted list of cards\n    \"\"\"\n    self._sort('Name')\n</code></pre>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.sort_by_newest","title":"sort_by_newest","text":"<pre><code>sort_by_newest() -&gt; None\n</code></pre> <p>Sorts cards in the list by newest first</p> Note <p>After sorting, a call to <code>list.cards</code> will return a sorted list of cards</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def sort_by_newest(self) -&gt; None:\n    \"\"\"Sorts cards in the list by newest first\n\n    Note:\n        After sorting, a call to `list.cards` will return a sorted list of cards\n    \"\"\"\n    self._sort('Newest First')\n</code></pre>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.sort_by_oldest","title":"sort_by_oldest","text":"<pre><code>sort_by_oldest() -&gt; None\n</code></pre> <p>Sorts cards in the list by oldest first</p> Note <p>After sorting, a call to <code>list.cards</code> will return a sorted list of cards</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def sort_by_oldest(self) -&gt; None:\n    \"\"\"Sorts cards in the list by oldest first\n\n    Note:\n        After sorting, a call to `list.cards` will return a sorted list of cards\n    \"\"\"\n    self._sort('Oldest First')\n</code></pre>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.update","title":"update","text":"<pre><code>update() -&gt; List\n</code></pre><pre><code>update(list: List) -&gt; List\n</code></pre><pre><code>update(name: str = None, position: int = None) -&gt; List\n</code></pre> <pre><code>update(*args, **kwargs) -&gt; List\n</code></pre> <p>Updates the list with new values</p> Tip <p>If you want to update a list, it's better to use the <code>editor()</code> context manager</p> <p>Example: <pre><code>&gt;&gt;&gt; with list_.editor():\n...    list_.name = 'New List Name'\n...    list_.position = 1\n\n&gt;&gt;&gt; list\nList(id=1, name='New List Name', position=1, ...)\n</code></pre></p> PARAMETER DESCRIPTION <p>Name of the list (optional)</p> <p> TYPE: <code>str</code> </p> <p>Position of the list (optional)</p> <p> TYPE: <code>int</code> </p> ALTERNATE DESCRIPTION <p>List instance to update (required)</p> <p> TYPE: <code>List</code> </p> Note <p>If no arguments are provided, the list will update itself with the current values stored in its attributes</p> RETURNS DESCRIPTION <code>List</code> <p>Updated list instance</p> <p> TYPE: <code>List</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def update(self, *args, **kwargs) -&gt; List:\n    \"\"\"Updates the list with new values\n\n    Tip:\n        If you want to update a list, it's better to use the `editor()` context manager\n\n        Example:\n        ```python\n        &gt;&gt;&gt; with list_.editor():\n        ...    list_.name = 'New List Name'\n        ...    list_.position = 1\n\n        &gt;&gt;&gt; list\n        List(id=1, name='New List Name', position=1, ...)\n        ```\n\n    Args:\n        name (str): Name of the list (optional)\n        position (int): Position of the list (optional)\n\n    Args: Alternate\n        list (List): List instance to update (required)\n\n    Note:\n        If no arguments are provided, the list will update itself with the current values stored in its attributes\n\n    Returns:\n        List: Updated list instance\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='list', \n        options=('name', 'position'),\n        noarg=self)\n\n    route = self.routes.patch_list(id=self.id)\n    self.__init__(**route(**overload)['item'])\n    return self\n</code></pre>"},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.update(name)","title":"<code>name</code>","text":""},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.update(position)","title":"<code>position</code>","text":""},{"location":"v1/interfaces/List/#plankapy.v1.interfaces.List.update(list)","title":"<code>list</code>","text":""},{"location":"v1/interfaces/Notification/","title":"Notification","text":"<p>               Bases: <code>Notification_</code></p> <p>Interface for interacting with planka Notifications</p> Note <p>Only notifications that are associated with the current user can be accessed</p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Delete the model instance</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>mark_as_read</code> <p>Marks the notification as read</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>Refreshes the notification data</p> <code>update</code> <p>Updates the notification with new values</p> ATTRIBUTE DESCRIPTION <code>action</code> <p>Action that the notification is associated with</p> <p> TYPE: <code>Action</code> </p> <code>card</code> <p>Card that the notification is associated with</p> <p> TYPE: <code>Card</code> </p> <code>created_at</code> <p>Get the creation date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>deleted_at</code> <p>Get the deletion date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>link</code> <p>Get the link to the model instance</p> <p> TYPE: <code>str | None</code> </p> <code>routes</code> <p>Get the routes for the model instance</p> <p> TYPE: <code>Routes</code> </p> <code>unique_name</code> <p>Generate a unique name for the model instance using the last 5 characters of the id</p> <p> TYPE: <code>str</code> </p> <code>updated_at</code> <p>Get the last update date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>user</code> <p>User that the notification is associated with</p> <p> TYPE: <code>User</code> </p>"},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.action","title":"action  <code>property</code>","text":"<pre><code>action: Action\n</code></pre> <p>Action that the notification is associated with</p> RETURNS DESCRIPTION <code>Action</code> <p>Action instance</p> <p> TYPE: <code>Action</code> </p>"},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.card","title":"card  <code>property</code>","text":"<pre><code>card: Card\n</code></pre> <p>Card that the notification is associated with</p> RETURNS DESCRIPTION <code>Card</code> <p>Card instance</p> <p> TYPE: <code>Card</code> </p>"},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.user","title":"user  <code>property</code>","text":"<pre><code>user: User\n</code></pre> <p>User that the notification is associated with</p> RETURNS DESCRIPTION <code>User</code> <p>User instance</p> <p> TYPE: <code>User</code> </p>"},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.mark_as_read","title":"mark_as_read","text":"<pre><code>mark_as_read() -&gt; None\n</code></pre> <p>Marks the notification as read</p> Note <p>There is no way to delete a notification, only mark it as read</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def mark_as_read(self) -&gt; None:\n    \"\"\"Marks the notification as read\n\n    Note:\n        There is no way to delete a notification, only mark it as read\n    \"\"\"\n    with self.editor():\n        self.isRead = True\n</code></pre>"},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.refresh","title":"refresh","text":"<pre><code>refresh() -&gt; None\n</code></pre> <p>Refreshes the notification data</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshes the notification data\"\"\"\n    route = self.routes.get_notification(id=self.id)\n    self.__init__(**route()['item'])\n</code></pre>"},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.update","title":"update","text":"<pre><code>update()\n</code></pre><pre><code>update(notification: Notification)\n</code></pre><pre><code>update(isRead: bool = None)\n</code></pre> <pre><code>update(*args, **kwargs) -&gt; Notification\n</code></pre> <p>Updates the notification with new values</p> Note <p>The only value that can be updated is the 'isRead' value. There is no way to delete a notification use the <code>.mark_as_read()</code> method to mark the notification as read</p> PARAMETER DESCRIPTION <p>Whether the notification is read (default: None)</p> <p> TYPE: <code>bool</code> </p> ALTERNATE DESCRIPTION <p>Notification instance to update with</p> <p> TYPE: <code>Notification</code> </p> Note <p>If no arguments are provided, the notification will update itself with the current values stored in its attributes</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def update(self, *args, **kwargs) -&gt; Notification:\n    \"\"\"Updates the notification with new values\n\n    Note:\n        The only value that can be updated is the 'isRead' value. There is no way to delete a notification\n        use the `.mark_as_read()` method to mark the notification as read\n\n    Args:\n        isRead (bool): Whether the notification is read (default: None)\n\n    Args: Alternate\n        notification (Notification): Notification instance to update with\n\n    Note:\n        If no arguments are provided, the notification will update itself with the current values stored in its attributes\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='notification', \n        options=('isRead',),\n        noarg=self)\n\n    route = self.routes.patch_notification(id=self.id)\n    self.__init__(**route(**overload)['item'])\n    return self\n</code></pre>"},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.update(isRead)","title":"<code>isRead</code>","text":""},{"location":"v1/interfaces/Notification/#plankapy.v1.interfaces.Notification.update(notification)","title":"<code>notification</code>","text":""},{"location":"v1/interfaces/Planka/","title":"Planka","text":"<p>Root object for interacting with the Planka API</p> ATTRIBUTE DESCRIPTION <code>auth</code> <p>Authentication method</p> <p> TYPE: <code>Type[BaseAuth]</code> </p> <code>url</code> <p>Base url for the Planka instance</p> <p> TYPE: <code>str</code> </p> <code>handler</code> <p>JSONHandler instance for making requests</p> <p> TYPE: <code>JSONHandler</code> </p> Note <p>All objects that return a list of objects will return a <code>QueryableList</code> object. This object is a subclass of <code>list</code> see the <code>QueryableList</code> docs for more information</p> Note <p>All implemented public properties return API responses with accessed. This means that the values are not cached  and will be updated on every access. If you wish to cache values, you are responsible for doing so. By default,  property access will always provide the most up to date information.</p> <p>Example:     <pre><code>&gt;&gt;&gt; len(project.cards)\n5\n&gt;&gt;&gt; project.create_card('My Card')\n&gt;&gt;&gt; len(project.cards)\n6\n</code></pre></p> Example <pre><code>&gt;&gt;&gt; from plankapy import Planka, PasswordAuth\n\n&gt;&gt;&gt; auth = PasswordAuth('username', 'password')\n&gt;&gt;&gt; planka = Planka('https://planka.example.com', auth)\n\n&gt;&gt;&gt; planka.me\nUser(id=...9234, name='username', ...)\n</code></pre> Tip <p>If you want to store a property chain to update later, but dont want to call it by full name, you can use a lambda</p> <p>Example:     <pre><code>&gt;&gt;&gt; card = lambda: planka.project[0].boards[0].lists[0].cards[0]\n&gt;&gt;&gt; comments = lambda: card().comments\n&gt;&gt;&gt; len(comments())\n2\n\n&gt;&gt;&gt; card().add_comment('My Comment')\n&gt;&gt;&gt; len(comments())\n3\n</code></pre></p> Tip <p>All objects inherit the <code>editor</code> context manager from the <code>Model</code> class except <code>Planka</code>. This means if you want to make changes to something, you can do it directly to attributes in an editor context instead of calling the model's <code>update</code> method</p> <p>Example:     <pre><code>&gt;&gt;&gt; with card.editor():\n...    card.name = 'My New Card'\n...    card.description = 'My New Description'\n\n&gt;&gt;&gt; card.name\n'My New Card'\n</code></pre></p> METHOD DESCRIPTION <code>create_project</code> <p>Creates a new project</p> <code>create_user</code> <p>Create a new user</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def __init__(self, url: str, auth: Type[BaseAuth]):        \n    self._url = url\n    self._auth = auth\n    self._create_session()\n</code></pre>"},{"location":"v1/interfaces/Planka/#plankapy.v1.interfaces.Planka.auth","title":"auth  <code>property</code> <code>writable</code>","text":"<pre><code>auth: Type[BaseAuth]\n</code></pre> <p>Current authentication instance</p> RETURNS DESCRIPTION <code>Type[BaseAuth]</code> <p>Authentication method</p>"},{"location":"v1/interfaces/Planka/#plankapy.v1.interfaces.Planka.config","title":"config  <code>property</code>","text":"<pre><code>config: JSONResponse\n</code></pre> <p>Planka Configuration</p> RETURNS DESCRIPTION <code>JSONResponse</code> <p>Configuration data</p>"},{"location":"v1/interfaces/Planka/#plankapy.v1.interfaces.Planka.me","title":"me  <code>property</code>","text":"<pre><code>me: User\n</code></pre> <p>Current Logged in User</p> RETURNS DESCRIPTION <code>User</code> <p>Current user</p>"},{"location":"v1/interfaces/Planka/#plankapy.v1.interfaces.Planka.notifications","title":"notifications  <code>property</code>","text":"<pre><code>notifications: QueryableList[Notification]\n</code></pre> <p>Queryable List of all notifications for the current user</p> RETURNS DESCRIPTION <code>QueryableList[Notification]</code> <p>Queryable List of all notifications</p>"},{"location":"v1/interfaces/Planka/#plankapy.v1.interfaces.Planka.project_background_images","title":"project_background_images  <code>property</code>","text":"<pre><code>project_background_images: QueryableList[BackgroundImage]\n</code></pre> <p>Get Project Background Images</p> RETURNS DESCRIPTION <code>QueryableList[BackgroundImage]</code> <p>Queryable List of all project background images</p>"},{"location":"v1/interfaces/Planka/#plankapy.v1.interfaces.Planka.projects","title":"projects  <code>property</code>","text":"<pre><code>projects: QueryableList[Project]\n</code></pre> <p>Queryable List of all projects on the Planka instance</p> RETURNS DESCRIPTION <code>QueryableList[Project]</code> <p>Queryable List of all projects</p>"},{"location":"v1/interfaces/Planka/#plankapy.v1.interfaces.Planka.url","title":"url  <code>property</code> <code>writable</code>","text":"<pre><code>url: str\n</code></pre> <p>The current planka url</p> RETURNS DESCRIPTION <code>str</code> <p>Planka url</p>"},{"location":"v1/interfaces/Planka/#plankapy.v1.interfaces.Planka.user_avatars","title":"user_avatars  <code>property</code>","text":"<pre><code>user_avatars: list[str]\n</code></pre> <p>Get User Avatars</p> RETURNS DESCRIPTION <code>list[str]</code> <p>Queryable List of all user avatar links</p>"},{"location":"v1/interfaces/Planka/#plankapy.v1.interfaces.Planka.users","title":"users  <code>property</code>","text":"<pre><code>users: QueryableList[User]\n</code></pre> <p>Queryable List of all users on the Planka instance</p> RETURNS DESCRIPTION <code>QueryableList[User]</code> <p>Queryable List of all users</p>"},{"location":"v1/interfaces/Planka/#plankapy.v1.interfaces.Planka.create_project","title":"create_project","text":"<pre><code>create_project(project: Project) -&gt; Project\n</code></pre><pre><code>create_project(name: str, position: int = None, background: Gradient = None) -&gt; Project\n</code></pre> <pre><code>create_project(*args, **kwargs) -&gt; Project\n</code></pre> <p>Creates a new project</p> Note <p>If no background is provided, a random gradient will be assigned</p> <p>If no position is provided, the project will be created at position 0</p> PARAMETER DESCRIPTION <p>Name of the project (required)</p> <p> TYPE: <code>str</code> </p> <p>Position of the project (default: 0)</p> <p> TYPE: <code>int</code> </p> <p>Background gradient of the project (default: None)</p> <p> TYPE: <code>Gradient</code> </p> ALTERNATE DESCRIPTION <p>Project instance to create</p> <p> TYPE: <code>Project</code> </p> RETURNS DESCRIPTION <code>Project</code> <p>New project instance</p> <p> TYPE: <code>Project</code> </p> Example <pre><code>&gt;&gt;&gt; new_project = planka.create_project('My Project')\n&gt;&gt;&gt; new_project.set_background_gradient('blue-xchange') # Set background gradient\n&gt;&gt;&gt; new_project.add_project_manager(planka.me) # Add current user as project manager\n</code></pre> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def create_project(self, *args, **kwargs) -&gt; Project:\n    \"\"\"Creates a new project\n\n    Note:\n        If no background is provided, a random gradient will be assigned\n\n        If no position is provided, the project will be created at position 0\n\n    Args:\n        name (str): Name of the project (required)\n        position (int): Position of the project (default: 0)\n        background (Gradient): Background gradient of the project (default: None)\n\n    Args: Alternate\n        project (Project): Project instance to create\n\n    Returns:\n        Project: New project instance\n\n    Example:\n        ```python\n        &gt;&gt;&gt; new_project = planka.create_project('My Project')\n        &gt;&gt;&gt; new_project.set_background_gradient('blue-xchange') # Set background gradient\n        &gt;&gt;&gt; new_project.add_project_manager(planka.me) # Add current user as project manager\n        ```\n    \"\"\"\n    overload = parse_overload(args, kwargs, model='project', \n                              options=('name', 'position', 'background'), \n                              required=('name',))\n\n    overload['position'] = overload.get('position', 0)\n\n    style = overload.get('background', None)\n    route = self.routes.post_project()\n    project = Project(**route(**overload)['item']).bind(self.routes)\n\n    with project.editor(): # Project POST does not accept background, so we set it after creation\n        project.set_background_gradient(style or choice(Project.gradients))\n\n    return project\n</code></pre>"},{"location":"v1/interfaces/Planka/#plankapy.v1.interfaces.Planka.create_project(name)","title":"<code>name</code>","text":""},{"location":"v1/interfaces/Planka/#plankapy.v1.interfaces.Planka.create_project(position)","title":"<code>position</code>","text":""},{"location":"v1/interfaces/Planka/#plankapy.v1.interfaces.Planka.create_project(background)","title":"<code>background</code>","text":""},{"location":"v1/interfaces/Planka/#plankapy.v1.interfaces.Planka.create_project(project)","title":"<code>project</code>","text":""},{"location":"v1/interfaces/Planka/#plankapy.v1.interfaces.Planka.create_user","title":"create_user","text":"<pre><code>create_user(username: str, email: str, password: str, name: str = None) -&gt; User\n</code></pre> <p>Create a new user</p> Note <p>Planka will reject insecure passwords! If creating a user with a specific password fails,  try a more secure password</p> Note <p>If the username is not lowercase, it will be converted to lowercase</p> PARAMETER DESCRIPTION <p>Username of the user (required)</p> <p> TYPE: <code>str</code> </p> <p>Email address of the user (required)</p> <p> TYPE: <code>str</code> </p> <p>Password for the user (required)</p> <p> TYPE: <code>str</code> </p> <p>Full name of the user (default: <code>username</code>)</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the username or email already exists</p> <code>ValueError</code> <p>If password is insecure or a 400 code is returned</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def create_user(self, username: str, email: str, password: str, name: str=None) -&gt; User:\n    \"\"\"Create a new user\n\n    Note:\n        Planka will reject insecure passwords! If creating a user with a specific password fails, \n        try a more secure password\n\n    Note:\n        If the username is not lowercase, it will be converted to lowercase\n\n    Args:\n        username (str): Username of the user (required)\n        email (str): Email address of the user (required)\n        password (str): Password for the user (required)\n        name (str): Full name of the user (default: `username`)\n\n    Raises:\n        ValueError: If the username or email already exists\n        ValueError: If password is insecure or a 400 code is returned\n    \"\"\"\n\n    username = username.strip()\n    if not username.islower():\n        print('Warning: Usernames are converted to lowercase')\n        username = username.lower()\n\n    for user in self.users:\n        if user.username == username:\n            raise ValueError(f'Username {username} already exists. '\n                             'Please use a different username')\n        if user.email == email:\n            raise ValueError(f'Email {email} already exists. '\n                             'Please use a different email address')\n\n    route = self.routes.post_user()\n    try:\n        return User(**route(username=username, name=name or username, password=password, email=email)['item']).bind(self.routes)\n    except HTTPError as e:\n        if e.code == 400: # Invalid password, email, or username\n            raise ValueError(\n                f'Failed to create user {username}:\\n'\n                '\\tTry: \\n'\n                '\\t\\tA more secure password\\n'\n                '\\t\\tValidating the user\\'s email address\\n'\n                '\\t\\tChecking that the username has no whitespace') from e\n        else: # Unknown error\n            raise e\n</code></pre>"},{"location":"v1/interfaces/Planka/#plankapy.v1.interfaces.Planka.create_user(username)","title":"<code>username</code>","text":""},{"location":"v1/interfaces/Planka/#plankapy.v1.interfaces.Planka.create_user(email)","title":"<code>email</code>","text":""},{"location":"v1/interfaces/Planka/#plankapy.v1.interfaces.Planka.create_user(password)","title":"<code>password</code>","text":""},{"location":"v1/interfaces/Planka/#plankapy.v1.interfaces.Planka.create_user(name)","title":"<code>name</code>","text":""},{"location":"v1/interfaces/Project/","title":"Project","text":"<p>               Bases: <code>Project_</code></p> <p>Interface for interacting with planka Projects and their included sub-objects</p> ATTRIBUTE DESCRIPTION <code>gradients</code> <p>All available gradients</p> <p> TYPE: <code>list[Gradient]</code> </p> <code>gradient_to_css</code> <p>Mapping of gradient names to CSS values</p> <p> TYPE: <code>dict[Gradient, str]</code> </p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>add_project_manager</code> <p>Creates a new project manager in the project</p> <code>bind</code> <p>Bind routes to the model</p> <code>create_board</code> <p>Creates a new board in the project from a name and position or a Board instance</p> <code>delete</code> <p>Deletes the project</p> <code>download_background_image</code> <p>Download a background image from the project</p> <code>editor</code> <p>Context manager for editing the model</p> <code>gradient_css</code> <p>Get the CSS value for the project gradient</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>Refreshes the project data</p> <code>remove_background_image</code> <p>Remove the background image from the project</p> <code>set_background_gradient</code> <p>Set a background gradient for the project</p> <code>set_background_image</code> <p>Add a background image to the project</p> <code>update</code> <p>Updates the project with new values</p>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.boardMemberships","title":"boardMemberships  <code>property</code>","text":"<pre><code>boardMemberships: QueryableList[BoardMembership]\n</code></pre> <p>All board memberships and roles in the project</p> Note <p>This property is not a list of users, but a list of <code>BoardMembership</code> objects that define the user's role in the project boards. This is used to remove memberships in associated project boards and will likely never be used directly</p> RETURNS DESCRIPTION <code>QueryableList[BoardMembership]</code> <p>Queryable List of all board membership relations in the project</p>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.boards","title":"boards  <code>property</code>","text":"<pre><code>boards: QueryableList[Board]\n</code></pre> <p>All boards in the project</p> RETURNS DESCRIPTION <code>QueryableList[Board]</code> <p>Queryable List of all boards</p>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.managers","title":"managers  <code>property</code>","text":"<pre><code>managers: QueryableList[User]\n</code></pre> <p>All project managers (Users)</p> RETURNS DESCRIPTION <code>QueryableList[User]</code> <p>Queryable List of all project managers</p>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.projectManagers","title":"projectManagers  <code>property</code>","text":"<pre><code>projectManagers: QueryableList[ProjectManager]\n</code></pre> <p>All project managers (ProjectManager Relations)</p> Note <p>This property is not a list of users, but a list of <code>ProjectManager</code> objects that define the user's role in the project. This is used to remove managers in associated project boards and will likely never be used directly</p> RETURNS DESCRIPTION <code>QueryableList[ProjectManager]</code> <p>Queryable List of all project manager relations</p>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.users","title":"users  <code>property</code>","text":"<pre><code>users: QueryableList[User]\n</code></pre> <p>All users in the project</p> RETURNS DESCRIPTION <code>QueryableList[User]</code> <p>Queryable List of all users</p>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.add_project_manager","title":"add_project_manager","text":"<pre><code>add_project_manager(user: User) -&gt; ProjectManager\n</code></pre><pre><code>add_project_manager(userId: int) -&gt; ProjectManager\n</code></pre> <pre><code>add_project_manager(*args, **kwargs) -&gt; ProjectManager\n</code></pre> <p>Creates a new project manager in the project</p> Note <p>This method has overloaded arguments, You can pass a <code>User</code> instance or provide a required <code>userId</code> argument</p> PARAMETER DESCRIPTION <p>id of the user to make project manager (required)</p> <p> TYPE: <code>int</code> </p> ALTERNATE     DESCRIPTION <p>User instance to create (required)</p> <p> TYPE: <code>User</code> </p> RETURNS DESCRIPTION <code>ProjectManager</code> <p>New project manager instance</p> <p> TYPE: <code>ProjectManager</code> </p> Example <pre><code>&gt;&gt;&gt; new_manager = project.create_project_manager(planka.me)\n&gt;&gt;&gt; other_manager = project.create_project_manager(userId='...1234')\n</code></pre> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def add_project_manager(self, *args, **kwargs) -&gt; ProjectManager:\n    \"\"\"Creates a new project manager in the project\n\n    Note:\n        This method has overloaded arguments,\n        You can pass a `User` instance or provide a required `userId` argument\n\n    Args:\n        userId (int): id of the user to make project manager (required)\n\n    Args: Alternate    \n        user (User): User instance to create (required)\n\n    Returns:\n        ProjectManager: New project manager instance\n\n    Example:\n        ```python\n        &gt;&gt;&gt; new_manager = project.create_project_manager(planka.me)\n        &gt;&gt;&gt; other_manager = project.create_project_manager(userId='...1234')\n        ```\n\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='user', \n        options=('userId',), \n        required=('userId',))\n\n    userId = overload.get('userId', None)\n\n    if not userId: # Get id from passed User\n        userId = overload.get('id')\n\n    # Don't assign a manager twice (raises HTTP 409 - Conflict)\n    if userId in [manager.id for manager in self.managers]:\n        return\n\n    route = self.routes.post_project_manager(projectId=self.id)\n    return ProjectManager(**route(userId=userId, projectId=self.id)['item']).bind(self.routes)\n</code></pre>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.add_project_manager(userId)","title":"<code>userId</code>","text":""},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.add_project_manager(user)","title":"<code>user</code>","text":""},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.create_board","title":"create_board","text":"<pre><code>create_board(board: Board) -&gt; Board\n</code></pre><pre><code>create_board(name: str, position: int = 0) -&gt; Board\n</code></pre> <pre><code>create_board(*args, **kwargs) -&gt; Board\n</code></pre> <p>Creates a new board in the project from a name and position or a Board instance</p> PARAMETER DESCRIPTION <p>Name of the board</p> <p> TYPE: <code>str</code> </p> <p>Position of the board (default: 0)</p> <p> TYPE: <code>int</code> </p> ALTERNATE DESCRIPTION <p>Board instance to create</p> <p> TYPE: <code>Board</code> </p> RETURNS DESCRIPTION <code>Board</code> <p>New board instance</p> <p> TYPE: <code>Board</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def create_board(self, *args, **kwargs) -&gt; Board:\n    \"\"\"Creates a new board in the project from a name and position or a Board instance\n\n    Args:\n        name (str): Name of the board\n        position (int): Position of the board (default: 0)\n\n    Args: Alternate\n        board (Board): Board instance to create\n\n    Returns:\n        Board: New board instance\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='board', \n        options=('name', 'position'), \n        required=('name',))\n\n    overload['position'] = overload.get('position', 0)\n    overload['projectId'] = self.id\n\n    route = self.routes.post_board(projectId=self.id)\n    return Board(**route(**overload)['item']).bind(self.routes)\n</code></pre>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.create_board(name)","title":"<code>name</code>","text":""},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.create_board(position)","title":"<code>position</code>","text":""},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.create_board(board)","title":"<code>board</code>","text":""},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.delete","title":"delete","text":"<pre><code>delete() -&gt; Project\n</code></pre> <p>Deletes the project</p> Danger <p>This action is irreversible and cannot be undone</p> RETURNS DESCRIPTION <code>Project</code> <p>Deleted project instance</p> <p> TYPE: <code>Project</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def delete(self) -&gt; Project:\n    \"\"\"Deletes the project\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        Project: Deleted project instance\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_project(id=self.id)\n    route()\n    return self\n</code></pre>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.download_background_image","title":"download_background_image","text":"<pre><code>download_background_image(path: Path) -&gt; Path | None\n</code></pre> <p>Download a background image from the project</p> PARAMETER DESCRIPTION <p>Path to save the image file</p> <p> TYPE: <code>Path</code> </p> RETURNS DESCRIPTION <code>Path</code> <p>Path to the downloaded image file or None if no background image is set</p> <p> TYPE: <code>Path | None</code> </p> Example <pre><code>&gt;&gt;&gt; project.download_background_image('/home/user/downloads/background.jpg')\n</code></pre> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def download_background_image(self, path: Path) -&gt; Path | None:\n    \"\"\"Download a background image from the project\n\n    Args:\n        path (Path): Path to save the image file\n\n    Returns:\n        Path: Path to the downloaded image file or None if no background image is set\n\n    Example:\n        ```python\n        &gt;&gt;&gt; project.download_background_image('/home/user/downloads/background.jpg')\n        ```\n    \"\"\"\n    if not self.backgroundImage:\n        return None\n\n    path = Path(path)\n    path.write_bytes(self.routes.handler._get_file(self.backgroundImage['url']))\n    return path\n</code></pre>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.download_background_image(path)","title":"<code>path</code>","text":""},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.gradient_css","title":"gradient_css","text":"<pre><code>gradient_css() -&gt; str | None\n</code></pre> <p>Get the CSS value for the project gradient</p> Note <p>If the project has no gradient set, this will return <code>None</code></p> RETURNS DESCRIPTION <code>str | None</code> <p>CSS value for the gradient</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def gradient_css(self) -&gt; str | None:\n    \"\"\"Get the CSS value for the project gradient\n\n    Note:\n        If the project has no gradient set, this will return `None`\n\n    Returns:\n        CSS value for the gradient\n    \"\"\"\n    gradient = self.background\n    if gradient.type != 'gradient':\n        return None\n    return self.gradient_to_css[gradient.name]\n</code></pre>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.refresh","title":"refresh","text":"<pre><code>refresh() -&gt; None\n</code></pre> <p>Refreshes the project data</p> Note <p>All objects accessed by properties are always up to date, but the root object that contains those properties keeps a cache of its own data. This method refreshes the root object data.</p> <p>FUTURE: This method might be removed or disabled in the future if I can get a getattr implementation to work without causing infinite recursion updating the root object when properties are accessed</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshes the project data\n\n    Note:\n        All objects accessed by properties are always up to date, but the root object that contains those\n        properties keeps a cache of its own data. This method refreshes the root object data.\n\n        FUTURE: This method might be removed or disabled in the future if I can get a __getattr__ implementation\n        to work without causing infinite recursion updating the root object when properties are accessed\n\n    \"\"\"\n    route = self.routes.get_project(id=self.id)\n    self.__init__(**route()['item'])\n</code></pre>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.remove_background_image","title":"remove_background_image","text":"<pre><code>remove_background_image() -&gt; None\n</code></pre> <p>Remove the background image from the project</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def remove_background_image(self) -&gt; None:\n    \"\"\"Remove the background image from the project\"\"\"\n    with self.editor():\n        if self.backgroundImage:\n            self.backgroundImage = None\n            self.background = {'name': f'{choice(self.gradients)}', 'type': 'gradient'}\n</code></pre>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.set_background_gradient","title":"set_background_gradient","text":"<pre><code>set_background_gradient(gradient: Gradient) -&gt; Project\n</code></pre> <p>Set a background gradient for the project</p> PARAMETER DESCRIPTION <p>Background gradient to set</p> <p> TYPE: <code>Gradient</code> </p> RETURNS DESCRIPTION <code>Project</code> <p>Updated project instance</p> <p> TYPE: <code>Project</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the gradient name is not in the available gradients</p> Example <pre><code>&gt;&gt;&gt; project.set_background_gradient('blue-xchange')\n</code></pre> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def set_background_gradient(self, gradient: Gradient) -&gt; Project:\n    \"\"\"Set a background gradient for the project\n\n    Args:\n        gradient (Gradient): Background gradient to set\n\n    Returns:\n        Project: Updated project instance\n\n    Raises:\n        ValueError: If the gradient name is not in the available gradients\n\n    Example:\n        ```python\n        &gt;&gt;&gt; project.set_background_gradient('blue-xchange')\n        ```\n    \"\"\"\n    if gradient not in self.gradients:\n        raise ValueError(\n            f'Invalid gradient: {gradient}'\n            f'Available gradients: {self.gradients}')\n\n    with self.editor():\n        self.backgroundImage = None            \n        self.background = {'name': gradient, 'type': 'gradient'}\n\n    return self\n</code></pre>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.set_background_gradient(gradient)","title":"<code>gradient</code>","text":""},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.set_background_image","title":"set_background_image","text":"<pre><code>set_background_image(image: Path) -&gt; BackgroundImage\n</code></pre> <p>Add a background image to the project</p> PARAMETER DESCRIPTION <p>Path to the image file</p> <p> TYPE: <code>Path</code> </p> RETURNS DESCRIPTION <code>BackgroundImage</code> <p>New background image</p> <p> TYPE: <code>BackgroundImage</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def set_background_image(self, image: Path) -&gt; BackgroundImage:\n    \"\"\"Add a background image to the project\n\n    Args:\n        image (Path): Path to the image file\n\n    Returns:\n        BackgroundImage: New background image\n    \"\"\"\n    route = self.routes.post_project_background_image(id=self.id)\n    return BackgroundImage(**route(_file=image)['item']['backgroundImage'])\n</code></pre>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.set_background_image(image)","title":"<code>image</code>","text":""},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.update","title":"update","text":"<pre><code>update(project: Project) -&gt; Project\n</code></pre><pre><code>update(name: str = None) -&gt; Project\n</code></pre> <pre><code>update(*args, **kwargs) -&gt; Project\n</code></pre> <p>Updates the project with new values</p> Note <p>To set background image, use the <code>set_background_image</code> method To set a background gradient, use the <code>set_background_gradient</code> method</p> PARAMETER DESCRIPTION <p>Name of the project (required)</p> <p> TYPE: <code>str</code> </p> ALTERNATE DESCRIPTION <p>Project instance to update (required)</p> <p> TYPE: <code>Project</code> </p> RETURNS DESCRIPTION <code>Project</code> <p>Updated project instance</p> <p> TYPE: <code>Project</code> </p> Example <pre><code>&gt;&gt;&gt; project.update(name='My New Project', background='blue-xchange'))\n</code></pre> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def update(self, *args, **kwargs) -&gt; Project:\n    \"\"\"Updates the project with new values\n\n    Note:\n        To set background image, use the `set_background_image` method\n        To set a background gradient, use the `set_background_gradient` method\n\n    Args:\n        name (str): Name of the project (required)\n\n    Args: Alternate\n        project (Project): Project instance to update (required)\n\n    Returns:\n        Project: Updated project instance\n\n    Example:\n        ```python\n        &gt;&gt;&gt; project.update(name='My New Project', background='blue-xchange'))\n        ```\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, model='project', \n        options=('name',),\n        noarg=self)\n\n    # Keep it backwards compatible\n    # Allow setting gradient directly by name\n    if 'background' in overload and isinstance(overload['background'], str):\n        bg = overload.pop('background') # Remove background from overload\n        if bg in self.gradients:\n            self.set_background_gradient(bg) # Set the gradient if it's valid\n\n    route = self.routes.patch_project(id=self.id)\n    self.__init__(**route(**overload)['item'])\n    return self\n</code></pre>"},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.update(name)","title":"<code>name</code>","text":""},{"location":"v1/interfaces/Project/#plankapy.v1.interfaces.Project.update(project)","title":"<code>project</code>","text":""},{"location":"v1/interfaces/ProjectManager/","title":"ProjectManager","text":"<p>               Bases: <code>ProjectManager_</code></p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Deletes the project manager relationship</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>Refreshes the project manager data</p> <code>update</code> <p>Update the model instance</p> ATTRIBUTE DESCRIPTION <code>created_at</code> <p>Get the creation date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>deleted_at</code> <p>Get the deletion date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>link</code> <p>Get the link to the model instance</p> <p> TYPE: <code>str | None</code> </p> <code>project</code> <p>Project the user is a manager of</p> <p> TYPE: <code>Project</code> </p> <code>routes</code> <p>Get the routes for the model instance</p> <p> TYPE: <code>Routes</code> </p> <code>unique_name</code> <p>Generate a unique name for the model instance using the last 5 characters of the id</p> <p> TYPE: <code>str</code> </p> <code>updated_at</code> <p>Get the last update date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>user</code> <p>User that is a manager of the project</p> <p> TYPE: <code>User</code> </p>"},{"location":"v1/interfaces/ProjectManager/#plankapy.v1.interfaces.ProjectManager.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/interfaces/ProjectManager/#plankapy.v1.interfaces.ProjectManager.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/interfaces/ProjectManager/#plankapy.v1.interfaces.ProjectManager.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/interfaces/ProjectManager/#plankapy.v1.interfaces.ProjectManager.project","title":"project  <code>property</code>","text":"<pre><code>project: Project\n</code></pre> <p>Project the user is a manager of</p> RETURNS DESCRIPTION <code>Project</code> <p>Project instance</p> <p> TYPE: <code>Project</code> </p>"},{"location":"v1/interfaces/ProjectManager/#plankapy.v1.interfaces.ProjectManager.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/interfaces/ProjectManager/#plankapy.v1.interfaces.ProjectManager.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/interfaces/ProjectManager/#plankapy.v1.interfaces.ProjectManager.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/interfaces/ProjectManager/#plankapy.v1.interfaces.ProjectManager.user","title":"user  <code>property</code>","text":"<pre><code>user: User\n</code></pre> <p>User that is a manager of the project</p> RETURNS DESCRIPTION <code>User</code> <p>User instance</p> <p> TYPE: <code>User</code> </p>"},{"location":"v1/interfaces/ProjectManager/#plankapy.v1.interfaces.ProjectManager.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/interfaces/ProjectManager/#plankapy.v1.interfaces.ProjectManager.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/interfaces/ProjectManager/#plankapy.v1.interfaces.ProjectManager.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/interfaces/ProjectManager/#plankapy.v1.interfaces.ProjectManager.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/interfaces/ProjectManager/#plankapy.v1.interfaces.ProjectManager.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/interfaces/ProjectManager/#plankapy.v1.interfaces.ProjectManager.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/interfaces/ProjectManager/#plankapy.v1.interfaces.ProjectManager.delete","title":"delete","text":"<pre><code>delete() -&gt; tuple[User, Project]\n</code></pre> <p>Deletes the project manager relationship</p> Danger <p>This action is irreversible and cannot be undone</p> RETURNS DESCRIPTION <code>tuple[User, Project]</code> <p>tuple[User, Project]: The user and project that the user was manager of</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def delete(self) -&gt; tuple[User, Project]:\n    \"\"\"Deletes the project manager relationship\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        tuple[User, Project]: The user and project that the user was manager of\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_project_manager(id=self.id)\n    route()\n    return (self.user, self.project)\n</code></pre>"},{"location":"v1/interfaces/ProjectManager/#plankapy.v1.interfaces.ProjectManager.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/interfaces/ProjectManager/#plankapy.v1.interfaces.ProjectManager.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/interfaces/ProjectManager/#plankapy.v1.interfaces.ProjectManager.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/interfaces/ProjectManager/#plankapy.v1.interfaces.ProjectManager.refresh","title":"refresh","text":"<pre><code>refresh() -&gt; None\n</code></pre> <p>Refreshes the project manager data</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshes the project manager data\"\"\"\n    for manager in self.project.managers:\n        if manager.id == self.id:\n            self.__init__(**manager)\n</code></pre>"},{"location":"v1/interfaces/ProjectManager/#plankapy.v1.interfaces.ProjectManager.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/interfaces/Stopwatch/","title":"Stopwatch","text":"<p>               Bases: <code>Model</code></p> <p>Stopwatch Model</p> Note <p>The stopwatch model is not a regular interface and instead is dynamically generated on Access through the <code>Card</code> <code>.stopwatch</code> attribute. There is an override that intercepts <code>__getitem__</code> to return a <code>Stopwatch</code>. </p> <p>All <code>Stopwatch</code> methods directly update the <code>.stopwatch</code> attribute of the linked <code>Card</code>  instance.</p> ATTRIBUTE DESCRIPTION <code>startedAt</code> <p>The start date of the stopwatch</p> <p> TYPE: <code>datetime</code> </p> <code>total</code> <p>The total time of the stopwatch (in seconds)</p> <p> TYPE: <code>int</code> </p> <code>_card</code> <p>The card the stopwatch is associated with (Managed by the <code>Card</code> class)</p> <p> TYPE: <code>Card</code> </p> Returned by: <ul> <li> Plankapy v1 Card Interfaces Card <ul> <li> <code></code>\u00a0add_stopwatch </li> <li> <code></code>\u00a0remove_stopwatch </li> </ul> </li> </ul> Used by: <ul> <li> Plankapy v1 <ul> <li> Card Interfaces Card <code></code>\u00a0update </li> <li> Board Interfaces List <code></code>\u00a0create_card </li> <li> Models <code></code>\u00a0Card_ </li> </ul> </li> </ul> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Delete the model instance</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>set</code> <p>Set an amount of time for the stopwatch</p> <code>start</code> <p>Starts the stopwatch</p> <code>start_time</code> <p>Returns the datetime the stopwatch was started</p> <code>stop</code> <p>Stops the stopwatch</p> <code>update</code> <p>Update the model instance</p>"},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.set","title":"set","text":"<pre><code>set(hours: int = 0, minutes: int = 0, seconds: int = 0) -&gt; None\n</code></pre> <p>Set an amount of time for the stopwatch</p> PARAMETER DESCRIPTION <p>Hours to set</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <p>Minutes to set</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <p>Seconds to set</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def set(self, hours: int=0, minutes: int=0, seconds: int=0) -&gt; None:\n    \"\"\"Set an amount of time for the stopwatch\n\n    Args:\n        hours (int): Hours to set\n        minutes (int): Minutes to set\n        seconds (int): Seconds to set\n    \"\"\"\n    self.total = (hours * 3600) + (minutes * 60) + seconds\n    with self._card.editor():\n        self._card.stopwatch = self\n</code></pre>"},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.set(hours)","title":"<code>hours</code>","text":""},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.set(minutes)","title":"<code>minutes</code>","text":""},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.set(seconds)","title":"<code>seconds</code>","text":""},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Starts the stopwatch</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Starts the stopwatch\"\"\"\n    self.refresh()\n    if self.startedAt:\n        return\n    self.startedAt = datetime.now().isoformat()\n    with self._card.editor():\n        self._card.stopwatch = self\n</code></pre>"},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.start_time","title":"start_time","text":"<pre><code>start_time() -&gt; datetime\n</code></pre> <p>Returns the datetime the stopwatch was started</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def start_time(self) -&gt; datetime:\n    \"\"\"Returns the datetime the stopwatch was started\"\"\"\n    self.refresh()\n    return datetime.fromisoformat(self.startedAt) if self.startedAt else None\n</code></pre>"},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.stop","title":"stop","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stops the stopwatch</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stops the stopwatch\"\"\"\n    self.refresh()\n    if not self.startedAt:\n        return\n\n    now = datetime.now()\n    started = datetime.fromisoformat(self.startedAt)\n    self.total += int(now.timestamp() - started.timestamp())\n    self.startedAt = None\n    with self._card.editor():\n        self._card.stopwatch = self\n</code></pre>"},{"location":"v1/interfaces/Stopwatch/#plankapy.v1.models.Stopwatch.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/interfaces/Task/","title":"Task","text":"<p>               Bases: <code>Task_</code></p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Deletes the task</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>Refreshes the task data</p> <code>update</code> <p>Updates the task with new values</p> ATTRIBUTE DESCRIPTION <code>created_at</code> <p>Get the creation date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>deleted_at</code> <p>Get the deletion date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>link</code> <p>Get the link to the model instance</p> <p> TYPE: <code>str | None</code> </p> <code>routes</code> <p>Get the routes for the model instance</p> <p> TYPE: <code>Routes</code> </p> <code>unique_name</code> <p>Generate a unique name for the model instance using the last 5 characters of the id</p> <p> TYPE: <code>str</code> </p> <code>updated_at</code> <p>Get the last update date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p>"},{"location":"v1/interfaces/Task/#plankapy.v1.interfaces.Task.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/interfaces/Task/#plankapy.v1.interfaces.Task.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/interfaces/Task/#plankapy.v1.interfaces.Task.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/interfaces/Task/#plankapy.v1.interfaces.Task.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/interfaces/Task/#plankapy.v1.interfaces.Task.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/interfaces/Task/#plankapy.v1.interfaces.Task.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/interfaces/Task/#plankapy.v1.interfaces.Task.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/interfaces/Task/#plankapy.v1.interfaces.Task.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/interfaces/Task/#plankapy.v1.interfaces.Task.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/interfaces/Task/#plankapy.v1.interfaces.Task.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/interfaces/Task/#plankapy.v1.interfaces.Task.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/interfaces/Task/#plankapy.v1.interfaces.Task.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/interfaces/Task/#plankapy.v1.interfaces.Task.delete","title":"delete","text":"<pre><code>delete() -&gt; Task\n</code></pre> <p>Deletes the task</p> Danger <p>This action is irreversible and cannot be undone</p> RETURNS DESCRIPTION <code>Task</code> <p>Deleted task instance</p> <p> TYPE: <code>Task</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def delete(self) -&gt; Task:\n    \"\"\"Deletes the task\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        Task: Deleted task instance\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_task(id=self.id)\n    route()\n    return self\n</code></pre>"},{"location":"v1/interfaces/Task/#plankapy.v1.interfaces.Task.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/interfaces/Task/#plankapy.v1.interfaces.Task.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/interfaces/Task/#plankapy.v1.interfaces.Task.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/interfaces/Task/#plankapy.v1.interfaces.Task.refresh","title":"refresh","text":"<pre><code>refresh() -&gt; None\n</code></pre> <p>Refreshes the task data</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshes the task data\"\"\"\n    tasks = self.card.board.tasks\n    for task in tasks:\n        if task.id == self.id:\n            self.__init__(**task)\n</code></pre>"},{"location":"v1/interfaces/Task/#plankapy.v1.interfaces.Task.update","title":"update","text":"<pre><code>update()\n</code></pre><pre><code>update(task: Task)\n</code></pre><pre><code>update(name: str = None, isCompleted: bool = None) -&gt; Task\n</code></pre> <pre><code>update(*args, **kwargs) -&gt; Task\n</code></pre> <p>Updates the task with new values</p> Tip <p>If you want to update a task, it's better to use the <code>editor()</code> context manager</p> <p>Example: <pre><code>&gt;&gt;&gt; with task.editor():\n...    task.name = 'New Task Name'\n...    task.isCompleted = True\n\n&gt;&gt;&gt; task\nTask(id=1, name='New Task Name', isCompleted=True, ...)\n</code></pre></p> PARAMETER DESCRIPTION <p>Name of the task (optional)</p> <p> TYPE: <code>str</code> </p> <p>Whether the task is completed (optional)</p> <p> TYPE: <code>bool</code> </p> ALTERNATE DESCRIPTION <p>Task instance to update (required)</p> <p> TYPE: <code>Task</code> </p> Note <p>If no arguments are provided, the task will update itself with the current values stored in its attributes</p> RETURNS DESCRIPTION <code>Task</code> <p>Updated task instance</p> <p> TYPE: <code>Task</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def update(self, *args, **kwargs) -&gt; Task:\n    \"\"\"Updates the task with new values\n\n    Tip:\n        If you want to update a task, it's better to use the `editor()` context manager\n\n        Example:\n        ```python\n        &gt;&gt;&gt; with task.editor():\n        ...    task.name = 'New Task Name'\n        ...    task.isCompleted = True\n\n        &gt;&gt;&gt; task\n        Task(id=1, name='New Task Name', isCompleted=True, ...)\n        ```\n\n    Args:\n        name (str): Name of the task (optional)\n        isCompleted (bool): Whether the task is completed (optional)\n\n    Args: Alternate\n        task (Task): Task instance to update (required)\n\n    Note:\n        If no arguments are provided, the task will update itself with the current values stored in its attributes\n\n    Returns:\n        Task: Updated task instance\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='task', \n        options=('name', 'isCompleted'),\n        noarg=self)\n\n    route = self.routes.patch_task(id=self.id)\n    self.__init__(**route(**overload)['item'])\n    return self\n</code></pre>"},{"location":"v1/interfaces/Task/#plankapy.v1.interfaces.Task.update(name)","title":"<code>name</code>","text":""},{"location":"v1/interfaces/Task/#plankapy.v1.interfaces.Task.update(isCompleted)","title":"<code>isCompleted</code>","text":""},{"location":"v1/interfaces/Task/#plankapy.v1.interfaces.Task.update(task)","title":"<code>task</code>","text":""},{"location":"v1/interfaces/User/","title":"User","text":"<p>               Bases: <code>User_</code></p> <p>Interface for interacting with planka Users and their included sub-objects</p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Deletes the user</p> <code>download_avatar</code> <p>Download the user's avatar to a file</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>Refreshes the user data</p> <code>remove_avatar</code> <p>Remove the user's avatar</p> <code>set_avatar</code> <p>Set the user's avatar</p> <code>update</code> <p>Updates the user with new values</p> ATTRIBUTE DESCRIPTION <code>boards</code> <p>All boards the user is a member of</p> <p> TYPE: <code>QueryableList[Board]</code> </p> <code>cards</code> <p>All cards assigned to the user in all projects</p> <p> TYPE: <code>QueryableList[Card]</code> </p> <code>created_at</code> <p>Get the creation date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>deleted_at</code> <p>Get the deletion date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>link</code> <p>Get the link to the model instance</p> <p> TYPE: <code>str | None</code> </p> <code>manager_of</code> <p>All projects the user is a manager of</p> <p> TYPE: <code>QueryableList[Project]</code> </p> <code>notifications</code> <p>All notifications for the user</p> <p> TYPE: <code>QueryableList[Notification]</code> </p> <code>projects</code> <p>All projects the user is a member of</p> <p> TYPE: <code>QueryableList[Project]</code> </p> <code>routes</code> <p>Get the routes for the model instance</p> <p> TYPE: <code>Routes</code> </p> <code>unique_name</code> <p>Generate a unique name for the model instance using the last 5 characters of the id</p> <p> TYPE: <code>str</code> </p> <code>updated_at</code> <p>Get the last update date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.boards","title":"boards  <code>property</code>","text":"<pre><code>boards: QueryableList[Board]\n</code></pre> <p>All boards the user is a member of</p> RETURNS DESCRIPTION <code>QueryableList[Board]</code> <p>Queryable List of all boards the user is a member of</p>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.cards","title":"cards  <code>property</code>","text":"<pre><code>cards: QueryableList[Card]\n</code></pre> <p>All cards assigned to the user in all projects</p> RETURNS DESCRIPTION <code>QueryableList[Card]</code> <p>Queryable List of all cards assigned to the user</p>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.manager_of","title":"manager_of  <code>property</code>","text":"<pre><code>manager_of: QueryableList[Project]\n</code></pre> <p>All projects the user is a manager of</p> RETURNS DESCRIPTION <code>QueryableList[Project]</code> <p>Queryable List of all projects the user is a manager of</p>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.notifications","title":"notifications  <code>property</code>","text":"<pre><code>notifications: QueryableList[Notification]\n</code></pre> <p>All notifications for the user</p> RETURNS DESCRIPTION <code>QueryableList[Notification]</code> <p>Queryable List of all notifications for the user</p>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.projects","title":"projects  <code>property</code>","text":"<pre><code>projects: QueryableList[Project]\n</code></pre> <p>All projects the user is a member of</p> RETURNS DESCRIPTION <code>QueryableList[Project]</code> <p>Queryable List of all projects the user is a member of</p>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.delete","title":"delete","text":"<pre><code>delete() -&gt; User\n</code></pre> <p>Deletes the user</p> Danger <p>This action is irreversible and cannot be undone</p> RETURNS DESCRIPTION <code>User</code> <p>Deleted user instance</p> <p> TYPE: <code>User</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def delete(self) -&gt; User:\n    \"\"\"Deletes the user\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        User: Deleted user instance\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_user(id=self.id)\n    route()\n    return self\n</code></pre>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.download_avatar","title":"download_avatar","text":"<pre><code>download_avatar(path: Path) -&gt; Path | None\n</code></pre> <p>Download the user's avatar to a file</p> PARAMETER DESCRIPTION <p>Path to save the avatar image</p> <p> TYPE: <code>Path</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the user has no avatar</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def download_avatar(self, path: Path) -&gt; Path | None:\n    \"\"\"Download the user's avatar to a file\n\n    Args:\n        path (Path): Path to save the avatar image\n\n    Raises:\n        ValueError: If the user has no avatar\n    \"\"\"\n    if self.avatarUrl is None:\n        return None\n\n    path = Path(path)\n    path.write_bytes(self.routes.handler._get_file(self.avatarUrl))\n    return path\n</code></pre>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.download_avatar(path)","title":"<code>path</code>","text":""},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.refresh","title":"refresh","text":"<pre><code>refresh() -&gt; None\n</code></pre> <p>Refreshes the user data</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshes the user data\n    \"\"\"\n    route = self.routes.get_user(id=self.id)\n    self.__init__(**route()['item'])\n</code></pre>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.remove_avatar","title":"remove_avatar","text":"<pre><code>remove_avatar() -&gt; None\n</code></pre> <p>Remove the user's avatar</p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def remove_avatar(self) -&gt; None:\n    \"\"\"Remove the user's avatar\"\"\"\n    with self.editor():\n        self.avatarUrl = None\n</code></pre>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.set_avatar","title":"set_avatar","text":"<pre><code>set_avatar(image: Path) -&gt; User\n</code></pre> <p>Set the user's avatar</p> Note <p>The image path can be a local filepath or a URL.</p> PARAMETER DESCRIPTION <p>Path to the image file</p> <p> TYPE: <code>Path</code> </p> RETURNS DESCRIPTION <code>User</code> <p>Updated user instance</p> <p> TYPE: <code>User</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def set_avatar(self, image: Path) -&gt; User:\n    \"\"\"Set the user's avatar\n\n    Note:\n        The image path can be a local filepath or a URL.\n\n    Args:\n        image (Path): Path to the image file\n\n    Returns:\n        User: Updated user instance\n    \"\"\"\n    route = self.routes.post_user_avatar(id=self.id)\n    return User(**route(_file=image)['item']).bind(self.routes)\n</code></pre>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.set_avatar(image)","title":"<code>image</code>","text":""},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.update","title":"update","text":"<pre><code>update() -&gt; User\n</code></pre><pre><code>update(user: User) -&gt; User\n</code></pre><pre><code>update(name: str = None, username: str = None, email: str = None, language: str = None, organization: str = None, phone: str = None, avatarUrl: str = None, isAdmin: bool = None, isDeletionLocked: bool = None, isLocked: bool = None, isRoleLocked: bool = None, isUsernameLocked: bool = None, subscribeToOwnCards: bool = None) -&gt; User\n</code></pre> <pre><code>update(*args, **kwargs) -&gt; User\n</code></pre> <p>Updates the user with new values</p> PARAMETER DESCRIPTION <p>Name of the user (optional)</p> <p> TYPE: <code>str</code> </p> <p>Username of the user (optional)</p> <p> TYPE: <code>str</code> </p> <p>Email of the user (optional)</p> <p> TYPE: <code>str</code> </p> <p>Language of the user (optional)</p> <p> TYPE: <code>str</code> </p> <p>Organization of the user (optional)</p> <p> TYPE: <code>str</code> </p> <p>Phone number of the user (optional)</p> <p> TYPE: <code>str</code> </p> <p>Avatar url of the user (optional)</p> <p> TYPE: <code>str</code> </p> <p>Whether the user is an admin (optional)</p> <p> TYPE: <code>bool</code> </p> <p>Whether the user is deletion locked (optional)</p> <p> TYPE: <code>bool</code> </p> <p>Whether the user is locked (optional)</p> <p> TYPE: <code>bool</code> </p> <p>Whether the user is role locked (optional)</p> <p> TYPE: <code>bool</code> </p> <p>Whether the user is username locked (optional)</p> <p> TYPE: <code>bool</code> </p> <p>Whether the user is subscribed to their own cards (optional)</p> <p> TYPE: <code>bool</code> </p> ALTERNATE DESCRIPTION <p>User instance to update (required)</p> <p> TYPE: <code>User</code> </p> Note <p>If no arguments are provided, the user will update itself with the current values stored in its attributes</p> RETURNS DESCRIPTION <code>User</code> <p>Updated user instance</p> <p> TYPE: <code>User</code> </p> Source code in <code>src/plankapy/v1/interfaces.py</code> <pre><code>def update(self, *args, **kwargs) -&gt; User:\n    \"\"\"Updates the user with new values\n\n    Args:\n        name (str): Name of the user (optional)\n        username (str): Username of the user (optional)\n        email (str): Email of the user (optional)\n        language (str): Language of the user (optional)\n        organization (str): Organization of the user (optional)\n        phone (str): Phone number of the user (optional)\n        avatarUrl (str): Avatar url of the user (optional)\n        isAdmin (bool): Whether the user is an admin (optional)\n        isDeletionLocked (bool): Whether the user is deletion locked (optional)\n        isLocked (bool): Whether the user is locked (optional)\n        isRoleLocked (bool): Whether the user is role locked (optional)\n        isUsernameLocked (bool): Whether the user is username locked (optional)\n        subscribeToOwnCards (bool): Whether the user is subscribed to their own cards (optional)\n\n    Args: Alternate\n        user (User): User instance to update (required)\n\n    Note:\n        If no arguments are provided, the user will update itself with the current values stored in its attributes\n\n    Returns:\n        User: Updated user instance\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='user', \n        options=('name', 'username', 'email', 'language', \n                 'organization', 'phone', 'avatarUrl', \n                 'isAdmin', 'isDeletionLocked', 'isLocked', \n                 'isRoleLocked', 'isUsernameLocked', \n                 'subscribeToOwnCards'),\n        noarg=self)\n    route = self.routes.patch_user(id=self.id)\n    self.__init__(**route(**overload)['item'])\n    return self\n</code></pre>"},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.update(name)","title":"<code>name</code>","text":""},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.update(username)","title":"<code>username</code>","text":""},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.update(email)","title":"<code>email</code>","text":""},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.update(language)","title":"<code>language</code>","text":""},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.update(organization)","title":"<code>organization</code>","text":""},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.update(phone)","title":"<code>phone</code>","text":""},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.update(avatarUrl)","title":"<code>avatarUrl</code>","text":""},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.update(isAdmin)","title":"<code>isAdmin</code>","text":""},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.update(isDeletionLocked)","title":"<code>isDeletionLocked</code>","text":""},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.update(isLocked)","title":"<code>isLocked</code>","text":""},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.update(isRoleLocked)","title":"<code>isRoleLocked</code>","text":""},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.update(isUsernameLocked)","title":"<code>isUsernameLocked</code>","text":""},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.update(subscribeToOwnCards)","title":"<code>subscribeToOwnCards</code>","text":""},{"location":"v1/interfaces/User/#plankapy.v1.interfaces.User.update(user)","title":"<code>user</code>","text":""},{"location":"v1/models/QueryableList/","title":"QueryableList","text":"<p>               Bases: <code>list[M]</code>, <code>Generic[M]</code></p> <p>A list of Queryable objects</p> <p>This class is a subclass of the built-in <code>list</code> class that allows for querying the list of objects.</p> Returned by: <ul> <li> Plankapy v1 <ul> <li> Board Interfaces <ul> <li> Board <ul> <li> <code></code>\u00a0attachments </li> <li> <code></code>\u00a0boardMemberships </li> <li> <code></code>\u00a0cardLabels </li> <li> <code></code>\u00a0cardMemberships </li> <li> <code></code>\u00a0cards </li> <li> <code></code>\u00a0editors </li> <li> <code></code>\u00a0labels </li> <li> <code></code>\u00a0lists </li> <li> <code></code>\u00a0tasks </li> <li> <code></code>\u00a0users </li> <li> <code></code>\u00a0viewers </li> </ul> </li> <li> Label <code></code>\u00a0cards </li> <li> List <code></code>\u00a0cards </li> </ul> </li> <li> Card Interfaces Card <ul> <li> <code></code>\u00a0attachments </li> <li> <code></code>\u00a0comments </li> <li> <code></code>\u00a0labels </li> <li> <code></code>\u00a0members </li> <li> <code></code>\u00a0tasks </li> </ul> </li> <li> Models <code></code>\u00a0QueryableList <ul> <li> <code></code>\u00a0filter_where </li> <li> <code></code>\u00a0order_by </li> <li> <code></code>\u00a0select_where </li> <li> <code></code>\u00a0take </li> </ul> </li> <li> Planka <ul> <li> <code></code>\u00a0notifications </li> <li> <code></code>\u00a0project_background_images </li> <li> <code></code>\u00a0projects </li> <li> <code></code>\u00a0users </li> </ul> </li> <li> Project Interfaces Project <ul> <li> <code></code>\u00a0boardMemberships </li> <li> <code></code>\u00a0boards </li> <li> <code></code>\u00a0managers </li> <li> <code></code>\u00a0projectManagers </li> <li> <code></code>\u00a0users </li> </ul> </li> <li> QueryableList <ul> <li> <code></code>\u00a0filter_where </li> <li> <code></code>\u00a0order_by </li> <li> <code></code>\u00a0select_where </li> <li> <code></code>\u00a0take </li> </ul> </li> <li> User Interfaces User <ul> <li> <code></code>\u00a0boards </li> <li> <code></code>\u00a0cards </li> <li> <code></code>\u00a0manager_of </li> <li> <code></code>\u00a0notifications </li> <li> <code></code>\u00a0projects </li> </ul> </li> </ul> </li> </ul> METHOD DESCRIPTION <code>filter_where</code> <p>Filter the list of objects by keyword arguments</p> <code>order_by</code> <p>Order the list by a key</p> <code>pop_where</code> <p>Get the first object that matches the filter</p> <code>select_where</code> <p>Select objects from the list that match a function</p> <code>take</code> <p>Take the first n objects from the list</p>"},{"location":"v1/models/QueryableList/#plankapy.v1.models.QueryableList.filter_where","title":"filter_where","text":"<pre><code>filter_where(**kwargs) -&gt; QueryableList[M] | None\n</code></pre> <p>Filter the list of objects by keyword arguments</p> PARAMETER DESCRIPTION <p>See Model for the available attributes</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>QueryableList[M] | None</code> <p>QueryableList[M]: The objects that match the filter or None if no objects match</p> <p>Example: <pre><code>&gt;&gt;&gt; users = QueryableList(project.users)\n&gt;&gt;&gt; users\n[User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Bob')]\n\n&gt;&gt;&gt; users.filter_where(name='Bob')\n[User(id=1, name='Bob'), User(id=3, name='Bob')]\n</code></pre></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def filter_where(self, **kwargs) -&gt; QueryableList[M] | None:\n    \"\"\"Filter the list of objects by keyword arguments\n\n    Args:\n        **kwargs: See Model for the available attributes\n\n    Returns:\n        QueryableList[M]: The objects that match the filter or None if no objects match\n\n    Example:\n    ```python\n    &gt;&gt;&gt; users = QueryableList(project.users)\n    &gt;&gt;&gt; users\n    [User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Bob')]\n\n    &gt;&gt;&gt; users.filter_where(name='Bob')\n    [User(id=1, name='Bob'), User(id=3, name='Bob')]\n    ```\n    \"\"\"\n    return QueryableList(item for item in self if all(getattr(item, key) == value for key, value in kwargs.items())) or None\n</code></pre>"},{"location":"v1/models/QueryableList/#plankapy.v1.models.QueryableList.filter_where(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"v1/models/QueryableList/#plankapy.v1.models.QueryableList.order_by","title":"order_by","text":"<pre><code>order_by(key: str, desc: bool = False) -&gt; QueryableList[M]\n</code></pre> <p>Order the list by a key</p> PARAMETER DESCRIPTION <p>The key to order by</p> <p> TYPE: <code>str</code> </p> <p>True to order in descending order, False otherwise</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>QueryableList[M]</code> <p>QueryableList[M]: The list of objects ordered by the key</p> <p>Example: <pre><code>&gt;&gt;&gt; users = QueryableList(project.users)\n&gt;&gt;&gt; users\n[User(name='Bob'), User(name='Alice')]\n\n&gt;&gt;&gt; users = users.order_by('name')\n&gt;&gt;&gt; users\n[User(name='Alice'), User(name='Bob')]\n\n&gt;&gt;&gt; users = users.order_by('name', desc=True)\n&gt;&gt;&gt; users\n[User(name='Bob'), User(name='Alice')]\n</code></pre></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def order_by(self, key: str, desc: bool=False) -&gt; QueryableList[M]:\n    \"\"\"Order the list by a key\n\n    Args:\n        key (str): The key to order by\n        desc (bool): True to order in descending order, False otherwise\n\n    Returns:\n        QueryableList[M]: The list of objects ordered by the key\n\n    Example:\n    ```python\n    &gt;&gt;&gt; users = QueryableList(project.users)\n    &gt;&gt;&gt; users\n    [User(name='Bob'), User(name='Alice')]\n\n    &gt;&gt;&gt; users = users.order_by('name')\n    &gt;&gt;&gt; users\n    [User(name='Alice'), User(name='Bob')]\n\n    &gt;&gt;&gt; users = users.order_by('name', desc=True)\n    &gt;&gt;&gt; users\n    [User(name='Bob'), User(name='Alice')]\n    ```\n    \"\"\"\n    return QueryableList(sorted(self, key=lambda x: getattr(x, key), reverse=desc))\n</code></pre>"},{"location":"v1/models/QueryableList/#plankapy.v1.models.QueryableList.order_by(key)","title":"<code>key</code>","text":""},{"location":"v1/models/QueryableList/#plankapy.v1.models.QueryableList.order_by(desc)","title":"<code>desc</code>","text":""},{"location":"v1/models/QueryableList/#plankapy.v1.models.QueryableList.pop_where","title":"pop_where","text":"<pre><code>pop_where(**kwargs) -&gt; M | None\n</code></pre> <p>Get the first object that matches the filter</p> PARAMETER DESCRIPTION <p>Keyword arguments to filter the list by</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>M</code> <p>The first object that matches the filter</p> <p> TYPE: <code>M | None</code> </p> <p>Example: <pre><code>&gt;&gt;&gt; users = QueryableList(project.users)\n&gt;&gt;&gt; users\n[User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Bob')]\n\n&gt;&gt;&gt; users.pop_where(name='Bob')\nUser(id=1, name='Bob')\n\n&gt;&gt;&gt; user = users.pop_where(name='Frank')\n&gt;&gt;&gt; user\nNone\n</code></pre></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pop_where(self, **kwargs) -&gt; M | None:\n    \"\"\"Get the first object that matches the filter\n\n    Args:\n        **kwargs: Keyword arguments to filter the list by\n\n    Returns:\n        M: The first object that matches the filter\n\n    Example:\n    ```python\n    &gt;&gt;&gt; users = QueryableList(project.users)\n    &gt;&gt;&gt; users\n    [User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Bob')]\n\n    &gt;&gt;&gt; users.pop_where(name='Bob')\n    User(id=1, name='Bob')\n\n    &gt;&gt;&gt; user = users.pop_where(name='Frank')\n    &gt;&gt;&gt; user\n    None\n    ```\n    \"\"\"\n    vals = self.filter_where(**kwargs)\n    return vals[0] if vals else None\n</code></pre>"},{"location":"v1/models/QueryableList/#plankapy.v1.models.QueryableList.pop_where(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"v1/models/QueryableList/#plankapy.v1.models.QueryableList.select_where","title":"select_where","text":"<pre><code>select_where(predicate: Callable[[M], bool]) -&gt; QueryableList[M]\n</code></pre> <p>Select objects from the list that match a function</p> PARAMETER DESCRIPTION <p>A function that takes an object and returns a boolean</p> <p> TYPE: <code>Callable[[M], bool]</code> </p> RETURNS DESCRIPTION <code>QueryableList[M]</code> <p>QueryableList[M]: The objects that match the function</p> <p>Example: <pre><code>&gt;&gt;&gt; users = QueryableList(project.users)\n&gt;&gt;&gt; users\n[User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Frank')]\n\n&gt;&gt;&gt; users = users.select_where(lambda x: x.name in ('Bob', 'Alice'))\n&gt;&gt;&gt; users\n[User(id=1, name='Bob'), User(id=2, name='Alice')]\n</code></pre></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def select_where(self, predicate: Callable[[M], bool]) -&gt; QueryableList[M]:\n    \"\"\"Select objects from the list that match a function\n\n    Args:\n        predicate: A function that takes an object and returns a boolean\n\n    Returns:\n        QueryableList[M]: The objects that match the function\n\n    Example:\n    ```python\n    &gt;&gt;&gt; users = QueryableList(project.users)\n    &gt;&gt;&gt; users\n    [User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Frank')]\n\n    &gt;&gt;&gt; users = users.select_where(lambda x: x.name in ('Bob', 'Alice'))\n    &gt;&gt;&gt; users\n    [User(id=1, name='Bob'), User(id=2, name='Alice')]\n    ```\n    \"\"\"\n    return QueryableList(item for item in self if predicate(item))\n</code></pre>"},{"location":"v1/models/QueryableList/#plankapy.v1.models.QueryableList.select_where(predicate)","title":"<code>predicate</code>","text":""},{"location":"v1/models/QueryableList/#plankapy.v1.models.QueryableList.take","title":"take","text":"<pre><code>take(n: int) -&gt; QueryableList[M]\n</code></pre> <p>Take the first n objects from the list</p> PARAMETER DESCRIPTION <p>The number of objects to take</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>QueryableList[M]</code> <p>QueryableList[M]: The first n objects in the list, if n is greater than the length of the list, the list is padded with <code>None</code></p> <p>Example: <pre><code>&gt;&gt;&gt; users = QueryableList(project.users)\n&gt;&gt;&gt; users.take(2)\n[User(name='Alice'), User(name='Bob')]\n\n&gt;&gt;&gt; users.take(3)\n[User(name='Alice'), User(name='Bob'), None]\n</code></pre></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def take(self, n: int) -&gt; QueryableList[M]:\n    \"\"\"Take the first n objects from the list\n\n    Args:\n        n (int): The number of objects to take\n\n    Returns:\n        QueryableList[M]: The first n objects in the list, if n is greater than the length of the list, the list is padded with `None`\n\n    Example:\n    ```python\n    &gt;&gt;&gt; users = QueryableList(project.users)\n    &gt;&gt;&gt; users.take(2)\n    [User(name='Alice'), User(name='Bob')]\n\n    &gt;&gt;&gt; users.take(3)\n    [User(name='Alice'), User(name='Bob'), None]\n    ```\n    \"\"\"\n    if n &gt; len(self):\n        return self + [None] * (n - len(self))\n    return self[:n]\n</code></pre>"},{"location":"v1/models/QueryableList/#plankapy.v1.models.QueryableList.take(n)","title":"<code>n</code>","text":""},{"location":"v1/models/models/","title":"Models","text":"CLASS DESCRIPTION <code>Action_</code> <p>Action Model</p> <code>Archive_</code> <p>Archive Model</p> <code>Attachment_</code> <p>Attachment Model</p> <code>BoardMembership_</code> <p>Board Membership Model</p> <code>Board_</code> <p>Board Model</p> <code>CardLabel_</code> <p>Card Label Model</p> <code>CardMembership_</code> <p>Card Membership Model</p> <code>CardSubscription_</code> <p>Card Subscription Model</p> <code>Card_</code> <p>Card Model</p> <code>IdentityProviderUser_</code> <p>Identity Provider User Model</p> <code>Label_</code> <p>Label Model</p> <code>List_</code> <p>List Model</p> <code>Model</code> <p>Implements common magic methods for all Models</p> <code>Notification_</code> <p>Notification Model</p> <code>ProjectManager_</code> <p>Project Manager Model</p> <code>Project_</code> <p>Project Model</p> <code>QueryableList</code> <p>A list of Queryable objects</p> <code>Stopwatch</code> <p>Stopwatch Model</p> <code>Task_</code> <p>Task Model</p> <code>User_</code> <p>User Model</p>"},{"location":"v1/models/models/#plankapy.v1.models.Action_","title":"Action_  <code>dataclass</code>","text":"<pre><code>Action_(id: int | None = Unset, type: ActionType | None = Required, data: dict | None = Required, cardId: int | None = Required, userId: int | None = Required, createdAt: str | None = Unset, updatedAt: str | None = Unset)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Action Model</p> ATTRIBUTE DESCRIPTION <code>id</code> <p>The ID of the action</p> <p> TYPE: <code>int</code> </p> <code>type</code> <p>The type of the action</p> <p> TYPE: <code>ActionType</code> </p> <code>data</code> <p>The data of the action</p> <p> TYPE: <code>dict</code> </p> <code>cardId</code> <p>The ID of the card the action is associated with</p> <p> TYPE: <code>int</code> </p> <code>userId</code> <p>The ID of the user who created the action</p> <p> TYPE: <code>int</code> </p> <code>createdAt</code> <p>The creation date of the action</p> <p> TYPE: <code>datetime</code> </p> <code>updatedAt</code> <p>The last update date of the action</p> <p> TYPE: <code>datetime</code> </p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Delete the model instance</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>\"Refresh the model instance</p> <code>update</code> <p>Update the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Action_.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Action_.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Action_.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Action_.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Action_.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Action_.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Action_.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Action_.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.Action_.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Action_.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Action_.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Action_.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Action_.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Action_.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Action_.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Action_.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Action_.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>\"Refresh the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def refresh(self): \n    \"\"\"\"Refresh the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Action_.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Archive_","title":"Archive_  <code>dataclass</code>","text":"<pre><code>Archive_(fromModel: str | None = Required, originalRecordId: int | None = Required, originalRecord: dict | None = Required)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Archive Model</p> Warning <p>This model is currently unavailable in the Planka API</p> ATTRIBUTE DESCRIPTION <code>fromModel</code> <p>The model the archive is from</p> <p> TYPE: <code>str</code> </p> <code>originalRecordId</code> <p>The ID of the original record</p> <p> TYPE: <code>int</code> </p> <code>originalRecord</code> <p>The original record</p> <p> TYPE: <code>dict</code> </p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Delete the model instance</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>\"Refresh the model instance</p> <code>update</code> <p>Update the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Archive_.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Archive_.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Archive_.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Archive_.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Archive_.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Archive_.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Archive_.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Archive_.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.Archive_.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Archive_.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Archive_.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Archive_.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Archive_.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Archive_.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Archive_.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Archive_.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Archive_.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>\"Refresh the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def refresh(self): \n    \"\"\"\"Refresh the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Archive_.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Attachment_","title":"Attachment_  <code>dataclass</code>","text":"<pre><code>Attachment_(id: int | None = Unset, name: str | None = Required, dirname: Literal['public', 'private/attachments'] | None = Required, filename: str | None = Required, image: dict | None = Unset, url: str | None = Unset, coverUrl: str | None = Unset, cardId: int | None = Required, creatorUserId: int | None = Unset, createdAt: str | None = Unset, updatedAt: str | None = Unset)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Attachment Model</p> ATTRIBUTE DESCRIPTION <code>id</code> <p>The ID of the attachment</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>The name of the attachment</p> <p> TYPE: <code>str</code> </p> <code>url</code> <p>The URL of the attachment</p> <p> TYPE: <code>str</code> </p> <code>cardId</code> <p>The ID of the card the attachment is associated with</p> <p> TYPE: <code>int</code> </p> <code>dirname</code> <p>The directory name of the attachment</p> <p> TYPE: <code>str</code> </p> <code>filename</code> <p>The filename of the attachment</p> <p> TYPE: <code>str</code> </p> <code>image</code> <p>The image of the attachment in the format <code>{'width': int, 'height': int}</code></p> <p> TYPE: <code>dict</code> </p> <code>url</code> <p>The URL of the attachment</p> <p> TYPE: <code>str</code> </p> <code>coverUrl</code> <p>The cover URL of the attachment</p> <p> TYPE: <code>str</code> </p> <code>cardId</code> <p>The ID of the card the attachment is associated with</p> <p> TYPE: <code>int</code> </p> <code>creatorUserId</code> <p>The ID of the user who created the attachment</p> <p> TYPE: <code>int</code> </p> <code>createdAt</code> <p>The creation date of the attachment</p> <p> TYPE: <code>datetime</code> </p> <code>updatedAt</code> <p>The last update date of the attachment</p> <p> TYPE: <code>datetime</code> </p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Delete the model instance</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>\"Refresh the model instance</p> <code>update</code> <p>Update the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Attachment_.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Attachment_.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Attachment_.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Attachment_.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Attachment_.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Attachment_.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Attachment_.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Attachment_.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.Attachment_.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Attachment_.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Attachment_.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Attachment_.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Attachment_.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Attachment_.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Attachment_.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Attachment_.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Attachment_.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>\"Refresh the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def refresh(self): \n    \"\"\"\"Refresh the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Attachment_.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.BoardMembership_","title":"BoardMembership_  <code>dataclass</code>","text":"<pre><code>BoardMembership_(id: int | None = Unset, role: BoardRole | None = Required, canComment: bool | None = Unset, boardId: int | None = Required, userId: int | None = Required, createdAt: str | None = Unset, updatedAt: str | None = Unset)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Board Membership Model</p> ATTRIBUTE DESCRIPTION <code>id</code> <p>The ID of the board membership</p> <p> TYPE: <code>int</code> </p> <code>role</code> <p>The role of the board membership</p> <p> TYPE: <code>BoardRole</code> </p> <code>canComment</code> <p>The comment permission of the board membership</p> <p> TYPE: <code>bool</code> </p> <code>boardId</code> <p>The ID of the board the membership is associated with</p> <p> TYPE: <code>int</code> </p> <code>userId</code> <p>The ID of the user the membership is associated with</p> <p> TYPE: <code>int</code> </p> <code>createdAt</code> <p>The creation date of the board membership</p> <p> TYPE: <code>datetime</code> </p> <code>updatedAt</code> <p>The last update date of the board membership</p> <p> TYPE: <code>datetime</code> </p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Delete the model instance</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>\"Refresh the model instance</p> <code>update</code> <p>Update the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.BoardMembership_.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.BoardMembership_.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.BoardMembership_.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.BoardMembership_.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.BoardMembership_.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.BoardMembership_.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.BoardMembership_.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.BoardMembership_.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.BoardMembership_.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.BoardMembership_.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.BoardMembership_.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.BoardMembership_.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.BoardMembership_.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.BoardMembership_.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.BoardMembership_.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.BoardMembership_.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.BoardMembership_.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>\"Refresh the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def refresh(self): \n    \"\"\"\"Refresh the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.BoardMembership_.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Board_","title":"Board_  <code>dataclass</code>","text":"<pre><code>Board_(id: int | None = Unset, name: str | None = Required, position: int | None = Required, projectId: int | None = Required, createdAt: str | None = Unset, updatedAt: str | None = Unset)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Board Model</p> ATTRIBUTE DESCRIPTION <code>id</code> <p>The ID of the board</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>The name of the board</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>The description of the board</p> <p> TYPE: <code>str</code> </p> <code>isClosed</code> <p>The closed status of the board</p> <p> TYPE: <code>bool</code> </p> <code>isStarred</code> <p>The starred status of the board</p> <p> TYPE: <code>bool</code> </p> <code>createdAt</code> <p>The creation date of the board</p> <p> TYPE: <code>datetime</code> </p> <code>updatedAt</code> <p>The last update date of the board</p> <p> TYPE: <code>datetime</code> </p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Delete the model instance</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>\"Refresh the model instance</p> <code>update</code> <p>Update the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Board_.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Board_.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Board_.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Board_.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Board_.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Board_.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Board_.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Board_.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.Board_.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Board_.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Board_.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Board_.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Board_.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Board_.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Board_.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Board_.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Board_.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>\"Refresh the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def refresh(self): \n    \"\"\"\"Refresh the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Board_.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardLabel_","title":"CardLabel_  <code>dataclass</code>","text":"<pre><code>CardLabel_(id: int | None = Unset, cardId: int | None = Required, labelId: int | None = Required, createdAt: str | None = Unset, updatedAt: str | None = Unset)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Card Label Model</p> ATTRIBUTE DESCRIPTION <code>id</code> <p>The ID of the card label</p> <p> TYPE: <code>int</code> </p> <code>cardId</code> <p>The ID of the card the label is associated with</p> <p> TYPE: <code>int</code> </p> <code>labelId</code> <p>The ID of the label the card is associated with</p> <p> TYPE: <code>int</code> </p> <code>createdAt</code> <p>The creation date of the card label</p> <p> TYPE: <code>datetime</code> </p> <code>updatedAt</code> <p>The last update date of the card label</p> <p> TYPE: <code>datetime</code> </p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Delete the model instance</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>\"Refresh the model instance</p> <code>update</code> <p>Update the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.CardLabel_.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.CardLabel_.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.CardLabel_.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.CardLabel_.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.CardLabel_.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.CardLabel_.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.CardLabel_.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardLabel_.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.CardLabel_.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardLabel_.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardLabel_.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardLabel_.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardLabel_.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardLabel_.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardLabel_.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardLabel_.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardLabel_.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>\"Refresh the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def refresh(self): \n    \"\"\"\"Refresh the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardLabel_.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardMembership_","title":"CardMembership_  <code>dataclass</code>","text":"<pre><code>CardMembership_(id: int | None = Unset, cardId: int | None = Required, userId: int | None = Required, createdAt: str | None = Unset, updatedAt: str | None = Unset)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Card Membership Model</p> ATTRIBUTE DESCRIPTION <code>id</code> <p>The ID of the card membership</p> <p> TYPE: <code>int</code> </p> <code>cardId</code> <p>The ID of the card the membership is associated with</p> <p> TYPE: <code>int</code> </p> <code>userId</code> <p>The ID of the user the membership is associated with</p> <p> TYPE: <code>int</code> </p> <code>createdAt</code> <p>The creation date of the card membership</p> <p> TYPE: <code>datetime</code> </p> <code>updatedAt</code> <p>The last update date of the card membership</p> <p> TYPE: <code>datetime</code> </p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Delete the model instance</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>\"Refresh the model instance</p> <code>update</code> <p>Update the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.CardMembership_.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.CardMembership_.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.CardMembership_.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.CardMembership_.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.CardMembership_.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.CardMembership_.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.CardMembership_.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardMembership_.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.CardMembership_.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardMembership_.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardMembership_.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardMembership_.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardMembership_.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardMembership_.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardMembership_.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardMembership_.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardMembership_.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>\"Refresh the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def refresh(self): \n    \"\"\"\"Refresh the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardMembership_.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardSubscription_","title":"CardSubscription_  <code>dataclass</code>","text":"<pre><code>CardSubscription_(id: int | None = Unset, cardId: int | None = Required, userId: int | None = Required, isPermanent: bool | None = Unset, createdAt: str | None = Unset, updatedAt: str | None = Unset)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Card Subscription Model</p> ATTRIBUTE DESCRIPTION <code>id</code> <p>The ID of the card subscription</p> <p> TYPE: <code>int</code> </p> <code>cardId</code> <p>The ID of the card the subscription is associated with</p> <p> TYPE: <code>int</code> </p> <code>userId</code> <p>The ID of the user the subscription is associated with</p> <p> TYPE: <code>int</code> </p> <code>createdAt</code> <p>The creation date of the card subscription</p> <p> TYPE: <code>datetime</code> </p> <code>updatedAt</code> <p>The last update date of the card subscription</p> <p> TYPE: <code>datetime</code> </p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Delete the model instance</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>\"Refresh the model instance</p> <code>update</code> <p>Update the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.CardSubscription_.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.CardSubscription_.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.CardSubscription_.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.CardSubscription_.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.CardSubscription_.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.CardSubscription_.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.CardSubscription_.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardSubscription_.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.CardSubscription_.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardSubscription_.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardSubscription_.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardSubscription_.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardSubscription_.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardSubscription_.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardSubscription_.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardSubscription_.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardSubscription_.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>\"Refresh the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def refresh(self): \n    \"\"\"\"Refresh the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.CardSubscription_.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Card_","title":"Card_  <code>dataclass</code>","text":"<pre><code>Card_(id: int | None = Unset, name: str | None = Required, position: int | None = Required, description: str | None = Unset, dueDate: str | None = Unset, isDueDateCompleted: bool | None = Unset, stopwatch: Stopwatch | None = Unset, boardId: int | None = Required, listId: int | None = Required, creatorUserId: int | None = Unset, coverAttachmentId: int | None = Unset, isSubscribed: bool | None = Unset, createdAt: str | None = Unset, updatedAt: str | None = Unset)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Card Model</p> ATTRIBUTE DESCRIPTION <code>id</code> <p>The ID of the card</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>The name of the card</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>The position of the card</p> <p> TYPE: <code>int</code> </p> <code>description</code> <p>The description of the card</p> <p> TYPE: <code>str</code> </p> <code>dueDate</code> <p>The due date of the card</p> <p> TYPE: <code>datetime</code> </p> <code>isDueDateCompleted</code> <p>The due date completion status of the card</p> <p> TYPE: <code>bool</code> </p> <code>stopwatch</code> <p>The stopwatch associated with the card</p> <p> TYPE: <code>_Stopwatch</code> </p> <code>boardId</code> <p>The ID of the board the card is associated with</p> <p> TYPE: <code>int</code> </p> <code>listId</code> <p>The ID of the list the card is associated with</p> <p> TYPE: <code>int</code> </p> <code>creatorUserId</code> <p>The ID of the user who created the card</p> <p> TYPE: <code>int</code> </p> <code>coverAttachmentId</code> <p>The ID of the cover attachment of the card</p> <p> TYPE: <code>int</code> </p> <code>isSubscribed</code> <p>The current user's subscription status with the card</p> <p> TYPE: <code>bool</code> </p> <code>createdAt</code> <p>The creation date of the card</p> <p> TYPE: <code>datetime</code> </p> <code>updatedAt</code> <p>The last update date of the card</p> <p> TYPE: <code>datetime</code> </p> Used by: <ul> <li> Plankapy v1 Models <code></code>\u00a0Stopwatch </li> </ul> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Delete the model instance</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>\"Refresh the model instance</p> <code>update</code> <p>Update the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Card_.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Card_.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Card_.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Card_.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Card_.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Card_.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Card_.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Card_.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.Card_.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Card_.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Card_.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Card_.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Card_.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Card_.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Card_.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Card_.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Card_.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>\"Refresh the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def refresh(self): \n    \"\"\"\"Refresh the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Card_.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.IdentityProviderUser_","title":"IdentityProviderUser_  <code>dataclass</code>","text":"<pre><code>IdentityProviderUser_(id: int | None = Unset, issuer: str | None = Unset, sub: str | None = Unset, userId: int | None = Required, createdAt: str | None = Unset, updatedAt: str | None = Unset)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Identity Provider User Model</p> ATTRIBUTE DESCRIPTION <code>id</code> <p>The ID of the identity provider user</p> <p> TYPE: <code>int</code> </p> <code>issuer</code> <p>The issuer of the identity provider user</p> <p> TYPE: <code>str</code> </p> <code>sub</code> <p>The sub of the identity provider user</p> <p> TYPE: <code>str</code> </p> <code>userId</code> <p>The ID of the user the identity provider user is associated with</p> <p> TYPE: <code>int</code> </p> <code>createdAt</code> <p>The creation date of the identity provider user</p> <p> TYPE: <code>datetime</code> </p> <code>updatedAt</code> <p>The last update date of the identity provider user</p> <p> TYPE: <code>datetime</code> </p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Delete the model instance</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>\"Refresh the model instance</p> <code>update</code> <p>Update the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.IdentityProviderUser_.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.IdentityProviderUser_.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.IdentityProviderUser_.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.IdentityProviderUser_.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.IdentityProviderUser_.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.IdentityProviderUser_.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.IdentityProviderUser_.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.IdentityProviderUser_.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.IdentityProviderUser_.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.IdentityProviderUser_.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.IdentityProviderUser_.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.IdentityProviderUser_.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.IdentityProviderUser_.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.IdentityProviderUser_.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.IdentityProviderUser_.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.IdentityProviderUser_.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.IdentityProviderUser_.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>\"Refresh the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def refresh(self): \n    \"\"\"\"Refresh the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.IdentityProviderUser_.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Label_","title":"Label_  <code>dataclass</code>","text":"<pre><code>Label_(id: int | None = Unset, name: str | None = Required, position: int | None = Required, color: str | None = Required, boardId: int | None = Required, createdAt: str | None = Unset, updatedAt: str | None = Unset)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Label Model</p> ATTRIBUTE DESCRIPTION <code>id</code> <p>The ID of the label</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>The name of the label</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>The position of the label</p> <p> TYPE: <code>int</code> </p> <code>color</code> <p>The color of the label</p> <p> TYPE: <code>str</code> </p> <code>boardId</code> <p>The ID of the board the label is associated with</p> <p> TYPE: <code>int</code> </p> <code>createdAt</code> <p>The creation date of the label</p> <p> TYPE: <code>datetime</code> </p> <code>updatedAt</code> <p>The last update date of the label</p> <p> TYPE: <code>datetime</code> </p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Delete the model instance</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>\"Refresh the model instance</p> <code>update</code> <p>Update the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Label_.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Label_.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Label_.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Label_.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Label_.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Label_.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Label_.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Label_.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.Label_.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Label_.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Label_.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Label_.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Label_.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Label_.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Label_.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Label_.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Label_.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>\"Refresh the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def refresh(self): \n    \"\"\"\"Refresh the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Label_.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.List_","title":"List_  <code>dataclass</code>","text":"<pre><code>List_(id: int | None = Unset, name: str | None = Required, position: int | None = Required, boardId: int | None = Required, color: str | None = Unset, createdAt: str | None = Unset, updatedAt: str | None = Unset)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>List Model</p> ATTRIBUTE DESCRIPTION <code>id</code> <p>The ID of the list</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>The name of the list</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>The position of the list</p> <p> TYPE: <code>int</code> </p> <code>boardId</code> <p>The ID of the board the list is associated with</p> <p> TYPE: <code>int</code> </p> <code>color</code> <p>The color of the list</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>The creation date of the list</p> <p> TYPE: <code>datetime</code> </p> <code>updatedAt</code> <p>The last update date of the list</p> <p> TYPE: <code>datetime</code> </p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Delete the model instance</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>\"Refresh the model instance</p> <code>update</code> <p>Update the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.List_.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.List_.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.List_.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.List_.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.List_.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.List_.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.List_.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.List_.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.List_.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.List_.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.List_.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.List_.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.List_.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.List_.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.List_.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.List_.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.List_.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>\"Refresh the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def refresh(self): \n    \"\"\"\"Refresh the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.List_.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Model","title":"Model","text":"<p>               Bases: <code>Mapping</code></p> <p>Implements common magic methods for all Models</p> Subclassed by: <ul> <li> Plankapy v1 Models <ul> <li> <code></code>\u00a0Action_ </li> <li> <code></code>\u00a0Archive_ </li> <li> <code></code>\u00a0Attachment_ </li> <li> <code></code>\u00a0BoardMembership_ </li> <li> <code></code>\u00a0Board_ </li> <li> <code></code>\u00a0CardLabel_ </li> <li> <code></code>\u00a0CardMembership_ </li> <li> <code></code>\u00a0CardSubscription_ </li> <li> <code></code>\u00a0Card_ </li> <li> <code></code>\u00a0IdentityProviderUser_ </li> <li> <code></code>\u00a0Label_ </li> <li> <code></code>\u00a0List_ </li> <li> <code></code>\u00a0Notification_ </li> <li> <code></code>\u00a0ProjectManager_ </li> <li> <code></code>\u00a0Project_ </li> <li> <code></code>\u00a0Stopwatch </li> <li> <code></code>\u00a0Task_ </li> <li> <code></code>\u00a0User_ </li> </ul> </li> </ul> Used by: <ul> <li> Archive <code></code>\u00a0__eq__ </li> <li> Plankapy v1 <ul> <li> Models <ul> <li> <code></code>\u00a0Action_ <code></code>\u00a0__eq__ </li> <li> <code></code>\u00a0Archive_ <code></code>\u00a0__eq__ </li> <li> <code></code>\u00a0Attachment_ <code></code>\u00a0__eq__ </li> <li> <code></code>\u00a0BoardMembership_ <code></code>\u00a0__eq__ </li> <li> <code></code>\u00a0Board_ <code></code>\u00a0__eq__ </li> <li> <code></code>\u00a0CardLabel_ <code></code>\u00a0__eq__ </li> <li> <code></code>\u00a0CardMembership_ <code></code>\u00a0__eq__ </li> <li> <code></code>\u00a0CardSubscription_ <code></code>\u00a0__eq__ </li> <li> <code></code>\u00a0Card_ <code></code>\u00a0__eq__ </li> <li> <code></code>\u00a0IdentityProviderUser_ <code></code>\u00a0__eq__ </li> <li> <code></code>\u00a0Label_ <code></code>\u00a0__eq__ </li> <li> <code></code>\u00a0List_ <code></code>\u00a0__eq__ </li> <li> <code></code>\u00a0Model <code></code>\u00a0__eq__ </li> <li> <code></code>\u00a0Notification_ <code></code>\u00a0__eq__ </li> <li> <code></code>\u00a0ProjectManager_ <code></code>\u00a0__eq__ </li> <li> <code></code>\u00a0Project_ <code></code>\u00a0__eq__ </li> <li> <code></code>\u00a0Stopwatch <code></code>\u00a0__eq__ </li> <li> <code></code>\u00a0Task_ <code></code>\u00a0__eq__ </li> <li> <code></code>\u00a0User_ <code></code>\u00a0__eq__ </li> </ul> </li> <li> User Interfaces <ul> <li> Notification <code></code>\u00a0__eq__ </li> <li> User <code></code>\u00a0__eq__ </li> </ul> </li> <li> Card Interfaces <ul> <li> Action <code></code>\u00a0__eq__ </li> <li> Attachment <code></code>\u00a0__eq__ </li> <li> Card <code></code>\u00a0__eq__ </li> <li> CardLabel <code></code>\u00a0__eq__ </li> <li> CardMembership <code></code>\u00a0__eq__ </li> <li> CardSubscription <code></code>\u00a0__eq__ </li> <li> Stopwatch <code></code>\u00a0__eq__ </li> <li> Task <code></code>\u00a0__eq__ </li> </ul> </li> <li> Board Interfaces <ul> <li> Board <code></code>\u00a0__eq__ </li> <li> BoardMembership <code></code>\u00a0__eq__ </li> <li> Label <code></code>\u00a0__eq__ </li> <li> List <code></code>\u00a0__eq__ </li> </ul> </li> <li> Project Interfaces <ul> <li> Project <code></code>\u00a0__eq__ </li> <li> ProjectManager <code></code>\u00a0__eq__ </li> </ul> </li> </ul> </li> </ul> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Delete the model instance</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>\"Refresh the model instance</p> <code>update</code> <p>Update the model instance</p> ATTRIBUTE DESCRIPTION <code>created_at</code> <p>Get the creation date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>deleted_at</code> <p>Get the deletion date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p> <code>link</code> <p>Get the link to the model instance</p> <p> TYPE: <code>str | None</code> </p> <code>routes</code> <p>Get the routes for the model instance</p> <p> TYPE: <code>Routes</code> </p> <code>unique_name</code> <p>Generate a unique name for the model instance using the last 5 characters of the id</p> <p> TYPE: <code>str</code> </p> <code>updated_at</code> <p>Get the last update date of the model instance</p> <p> TYPE: <code>datetime | None</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Model.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Model.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Model.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Model.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Model.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Model.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Model.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Model.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.Model.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Model.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Model.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Model.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Model.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Model.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Model.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Model.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Model.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>\"Refresh the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def refresh(self): \n    \"\"\"\"Refresh the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Model.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Notification_","title":"Notification_  <code>dataclass</code>","text":"<pre><code>Notification_(id: int | None = Unset, isRead: bool = Required, userId: int | None = Required, actionId: int | None = Required, cardId: int | None = Required, createdAt: str | None = Unset, updatedAt: str | None = Unset)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Notification Model</p> ATTRIBUTE DESCRIPTION <code>id</code> <p>The ID of the notification</p> <p> TYPE: <code>int</code> </p> <code>isRead</code> <p>The read status of the notification</p> <p> TYPE: <code>bool</code> </p> <code>userId</code> <p>The ID of the user the notification is associated with</p> <p> TYPE: <code>int</code> </p> <code>actionId</code> <p>The ID of the action the notification is associated with</p> <p> TYPE: <code>int</code> </p> <code>cardId</code> <p>The ID of the card the notification is associated with</p> <p> TYPE: <code>int</code> </p> <code>createdAt</code> <p>The creation date of the notification</p> <p> TYPE: <code>datetime</code> </p> <code>updatedAt</code> <p>The last update date of the notification</p> <p> TYPE: <code>datetime</code> </p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Delete the model instance</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>\"Refresh the model instance</p> <code>update</code> <p>Update the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Notification_.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Notification_.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Notification_.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Notification_.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Notification_.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Notification_.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Notification_.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Notification_.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.Notification_.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Notification_.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Notification_.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Notification_.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Notification_.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Notification_.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Notification_.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Notification_.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Notification_.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>\"Refresh the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def refresh(self): \n    \"\"\"\"Refresh the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Notification_.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.ProjectManager_","title":"ProjectManager_  <code>dataclass</code>","text":"<pre><code>ProjectManager_(id: int | None = Unset, projectId: int | None = Required, userId: int | None = Required, createdAt: str | None = Unset, updatedAt: str | None = Unset)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Project Manager Model</p> ATTRIBUTE DESCRIPTION <code>id</code> <p>The ID of the project manager</p> <p> TYPE: <code>int</code> </p> <code>projectId</code> <p>The ID of the project the manager is associated with</p> <p> TYPE: <code>int</code> </p> <code>userId</code> <p>The ID of the user the manager is associated with</p> <p> TYPE: <code>int</code> </p> <code>createdAt</code> <p>The creation date of the project manager</p> <p> TYPE: <code>datetime</code> </p> <code>updatedAt</code> <p>The last update date of the project manager</p> <p> TYPE: <code>datetime</code> </p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Delete the model instance</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>\"Refresh the model instance</p> <code>update</code> <p>Update the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.ProjectManager_.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.ProjectManager_.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.ProjectManager_.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.ProjectManager_.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.ProjectManager_.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.ProjectManager_.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.ProjectManager_.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.ProjectManager_.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.ProjectManager_.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.ProjectManager_.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.ProjectManager_.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.ProjectManager_.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.ProjectManager_.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.ProjectManager_.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.ProjectManager_.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.ProjectManager_.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.ProjectManager_.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>\"Refresh the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def refresh(self): \n    \"\"\"\"Refresh the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.ProjectManager_.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Project_","title":"Project_  <code>dataclass</code>","text":"<pre><code>Project_(id: int | None = Unset, name: str | None = Required, background: dict | None = Unset, backgroundImage: BackgroundImage | None = Unset, createdAt: str | None = Unset, updatedAt: str | None = Unset)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Project Model</p> ATTRIBUTE DESCRIPTION <code>id</code> <p>The ID of the project</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>The name of the project</p> <p> TYPE: <code>str</code> </p> <code>background</code> <p>The background of the project</p> <p> TYPE: <code>Background</code> </p> <code>backgroundImage</code> <p>The background image of the project</p> <p> TYPE: <code>BackgroundImage</code> </p> <code>createdAt</code> <p>The creation date of the project</p> <p> TYPE: <code>datetime</code> </p> <code>updatedAt</code> <p>The last update date of the project</p> <p> TYPE: <code>datetime</code> </p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Delete the model instance</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>\"Refresh the model instance</p> <code>update</code> <p>Update the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Project_.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Project_.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Project_.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Project_.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Project_.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Project_.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Project_.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Project_.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.Project_.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Project_.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Project_.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Project_.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Project_.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Project_.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Project_.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Project_.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Project_.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>\"Refresh the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def refresh(self): \n    \"\"\"\"Refresh the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Project_.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.QueryableList","title":"QueryableList","text":"<p>               Bases: <code>list[M]</code>, <code>Generic[M]</code></p> <p>A list of Queryable objects</p> <p>This class is a subclass of the built-in <code>list</code> class that allows for querying the list of objects.</p> Returned by: <ul> <li> Plankapy v1 <ul> <li> Board Interfaces <ul> <li> Board <ul> <li> <code></code>\u00a0attachments </li> <li> <code></code>\u00a0boardMemberships </li> <li> <code></code>\u00a0cardLabels </li> <li> <code></code>\u00a0cardMemberships </li> <li> <code></code>\u00a0cards </li> <li> <code></code>\u00a0editors </li> <li> <code></code>\u00a0labels </li> <li> <code></code>\u00a0lists </li> <li> <code></code>\u00a0tasks </li> <li> <code></code>\u00a0users </li> <li> <code></code>\u00a0viewers </li> </ul> </li> <li> Label <code></code>\u00a0cards </li> <li> List <code></code>\u00a0cards </li> </ul> </li> <li> Card Interfaces Card <ul> <li> <code></code>\u00a0attachments </li> <li> <code></code>\u00a0comments </li> <li> <code></code>\u00a0labels </li> <li> <code></code>\u00a0members </li> <li> <code></code>\u00a0tasks </li> </ul> </li> <li> Models <code></code>\u00a0QueryableList <ul> <li> <code></code>\u00a0filter_where </li> <li> <code></code>\u00a0order_by </li> <li> <code></code>\u00a0select_where </li> <li> <code></code>\u00a0take </li> </ul> </li> <li> Planka <ul> <li> <code></code>\u00a0notifications </li> <li> <code></code>\u00a0project_background_images </li> <li> <code></code>\u00a0projects </li> <li> <code></code>\u00a0users </li> </ul> </li> <li> Project Interfaces Project <ul> <li> <code></code>\u00a0boardMemberships </li> <li> <code></code>\u00a0boards </li> <li> <code></code>\u00a0managers </li> <li> <code></code>\u00a0projectManagers </li> <li> <code></code>\u00a0users </li> </ul> </li> <li> QueryableList <ul> <li> <code></code>\u00a0filter_where </li> <li> <code></code>\u00a0order_by </li> <li> <code></code>\u00a0select_where </li> <li> <code></code>\u00a0take </li> </ul> </li> <li> User Interfaces User <ul> <li> <code></code>\u00a0boards </li> <li> <code></code>\u00a0cards </li> <li> <code></code>\u00a0manager_of </li> <li> <code></code>\u00a0notifications </li> <li> <code></code>\u00a0projects </li> </ul> </li> </ul> </li> </ul> METHOD DESCRIPTION <code>filter_where</code> <p>Filter the list of objects by keyword arguments</p> <code>order_by</code> <p>Order the list by a key</p> <code>pop_where</code> <p>Get the first object that matches the filter</p> <code>select_where</code> <p>Select objects from the list that match a function</p> <code>take</code> <p>Take the first n objects from the list</p>"},{"location":"v1/models/models/#plankapy.v1.models.QueryableList.filter_where","title":"filter_where","text":"<pre><code>filter_where(**kwargs) -&gt; QueryableList[M] | None\n</code></pre> <p>Filter the list of objects by keyword arguments</p> PARAMETER DESCRIPTION <p>See Model for the available attributes</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>QueryableList[M] | None</code> <p>QueryableList[M]: The objects that match the filter or None if no objects match</p> <p>Example: <pre><code>&gt;&gt;&gt; users = QueryableList(project.users)\n&gt;&gt;&gt; users\n[User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Bob')]\n\n&gt;&gt;&gt; users.filter_where(name='Bob')\n[User(id=1, name='Bob'), User(id=3, name='Bob')]\n</code></pre></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def filter_where(self, **kwargs) -&gt; QueryableList[M] | None:\n    \"\"\"Filter the list of objects by keyword arguments\n\n    Args:\n        **kwargs: See Model for the available attributes\n\n    Returns:\n        QueryableList[M]: The objects that match the filter or None if no objects match\n\n    Example:\n    ```python\n    &gt;&gt;&gt; users = QueryableList(project.users)\n    &gt;&gt;&gt; users\n    [User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Bob')]\n\n    &gt;&gt;&gt; users.filter_where(name='Bob')\n    [User(id=1, name='Bob'), User(id=3, name='Bob')]\n    ```\n    \"\"\"\n    return QueryableList(item for item in self if all(getattr(item, key) == value for key, value in kwargs.items())) or None\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.QueryableList.filter_where(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.QueryableList.order_by","title":"order_by","text":"<pre><code>order_by(key: str, desc: bool = False) -&gt; QueryableList[M]\n</code></pre> <p>Order the list by a key</p> PARAMETER DESCRIPTION <p>The key to order by</p> <p> TYPE: <code>str</code> </p> <p>True to order in descending order, False otherwise</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>QueryableList[M]</code> <p>QueryableList[M]: The list of objects ordered by the key</p> <p>Example: <pre><code>&gt;&gt;&gt; users = QueryableList(project.users)\n&gt;&gt;&gt; users\n[User(name='Bob'), User(name='Alice')]\n\n&gt;&gt;&gt; users = users.order_by('name')\n&gt;&gt;&gt; users\n[User(name='Alice'), User(name='Bob')]\n\n&gt;&gt;&gt; users = users.order_by('name', desc=True)\n&gt;&gt;&gt; users\n[User(name='Bob'), User(name='Alice')]\n</code></pre></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def order_by(self, key: str, desc: bool=False) -&gt; QueryableList[M]:\n    \"\"\"Order the list by a key\n\n    Args:\n        key (str): The key to order by\n        desc (bool): True to order in descending order, False otherwise\n\n    Returns:\n        QueryableList[M]: The list of objects ordered by the key\n\n    Example:\n    ```python\n    &gt;&gt;&gt; users = QueryableList(project.users)\n    &gt;&gt;&gt; users\n    [User(name='Bob'), User(name='Alice')]\n\n    &gt;&gt;&gt; users = users.order_by('name')\n    &gt;&gt;&gt; users\n    [User(name='Alice'), User(name='Bob')]\n\n    &gt;&gt;&gt; users = users.order_by('name', desc=True)\n    &gt;&gt;&gt; users\n    [User(name='Bob'), User(name='Alice')]\n    ```\n    \"\"\"\n    return QueryableList(sorted(self, key=lambda x: getattr(x, key), reverse=desc))\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.QueryableList.order_by(key)","title":"<code>key</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.QueryableList.order_by(desc)","title":"<code>desc</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.QueryableList.pop_where","title":"pop_where","text":"<pre><code>pop_where(**kwargs) -&gt; M | None\n</code></pre> <p>Get the first object that matches the filter</p> PARAMETER DESCRIPTION <p>Keyword arguments to filter the list by</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>M</code> <p>The first object that matches the filter</p> <p> TYPE: <code>M | None</code> </p> <p>Example: <pre><code>&gt;&gt;&gt; users = QueryableList(project.users)\n&gt;&gt;&gt; users\n[User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Bob')]\n\n&gt;&gt;&gt; users.pop_where(name='Bob')\nUser(id=1, name='Bob')\n\n&gt;&gt;&gt; user = users.pop_where(name='Frank')\n&gt;&gt;&gt; user\nNone\n</code></pre></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pop_where(self, **kwargs) -&gt; M | None:\n    \"\"\"Get the first object that matches the filter\n\n    Args:\n        **kwargs: Keyword arguments to filter the list by\n\n    Returns:\n        M: The first object that matches the filter\n\n    Example:\n    ```python\n    &gt;&gt;&gt; users = QueryableList(project.users)\n    &gt;&gt;&gt; users\n    [User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Bob')]\n\n    &gt;&gt;&gt; users.pop_where(name='Bob')\n    User(id=1, name='Bob')\n\n    &gt;&gt;&gt; user = users.pop_where(name='Frank')\n    &gt;&gt;&gt; user\n    None\n    ```\n    \"\"\"\n    vals = self.filter_where(**kwargs)\n    return vals[0] if vals else None\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.QueryableList.pop_where(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.QueryableList.select_where","title":"select_where","text":"<pre><code>select_where(predicate: Callable[[M], bool]) -&gt; QueryableList[M]\n</code></pre> <p>Select objects from the list that match a function</p> PARAMETER DESCRIPTION <p>A function that takes an object and returns a boolean</p> <p> TYPE: <code>Callable[[M], bool]</code> </p> RETURNS DESCRIPTION <code>QueryableList[M]</code> <p>QueryableList[M]: The objects that match the function</p> <p>Example: <pre><code>&gt;&gt;&gt; users = QueryableList(project.users)\n&gt;&gt;&gt; users\n[User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Frank')]\n\n&gt;&gt;&gt; users = users.select_where(lambda x: x.name in ('Bob', 'Alice'))\n&gt;&gt;&gt; users\n[User(id=1, name='Bob'), User(id=2, name='Alice')]\n</code></pre></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def select_where(self, predicate: Callable[[M], bool]) -&gt; QueryableList[M]:\n    \"\"\"Select objects from the list that match a function\n\n    Args:\n        predicate: A function that takes an object and returns a boolean\n\n    Returns:\n        QueryableList[M]: The objects that match the function\n\n    Example:\n    ```python\n    &gt;&gt;&gt; users = QueryableList(project.users)\n    &gt;&gt;&gt; users\n    [User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Frank')]\n\n    &gt;&gt;&gt; users = users.select_where(lambda x: x.name in ('Bob', 'Alice'))\n    &gt;&gt;&gt; users\n    [User(id=1, name='Bob'), User(id=2, name='Alice')]\n    ```\n    \"\"\"\n    return QueryableList(item for item in self if predicate(item))\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.QueryableList.select_where(predicate)","title":"<code>predicate</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.QueryableList.take","title":"take","text":"<pre><code>take(n: int) -&gt; QueryableList[M]\n</code></pre> <p>Take the first n objects from the list</p> PARAMETER DESCRIPTION <p>The number of objects to take</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>QueryableList[M]</code> <p>QueryableList[M]: The first n objects in the list, if n is greater than the length of the list, the list is padded with <code>None</code></p> <p>Example: <pre><code>&gt;&gt;&gt; users = QueryableList(project.users)\n&gt;&gt;&gt; users.take(2)\n[User(name='Alice'), User(name='Bob')]\n\n&gt;&gt;&gt; users.take(3)\n[User(name='Alice'), User(name='Bob'), None]\n</code></pre></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def take(self, n: int) -&gt; QueryableList[M]:\n    \"\"\"Take the first n objects from the list\n\n    Args:\n        n (int): The number of objects to take\n\n    Returns:\n        QueryableList[M]: The first n objects in the list, if n is greater than the length of the list, the list is padded with `None`\n\n    Example:\n    ```python\n    &gt;&gt;&gt; users = QueryableList(project.users)\n    &gt;&gt;&gt; users.take(2)\n    [User(name='Alice'), User(name='Bob')]\n\n    &gt;&gt;&gt; users.take(3)\n    [User(name='Alice'), User(name='Bob'), None]\n    ```\n    \"\"\"\n    if n &gt; len(self):\n        return self + [None] * (n - len(self))\n    return self[:n]\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.QueryableList.take(n)","title":"<code>n</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch","title":"Stopwatch  <code>dataclass</code>","text":"<pre><code>Stopwatch(_card: Card_ | None = Unset, startedAt: str | None = Unset, total: int | None = Unset)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Stopwatch Model</p> Note <p>The stopwatch model is not a regular interface and instead is dynamically generated on Access through the <code>Card</code> <code>.stopwatch</code> attribute. There is an override that intercepts <code>__getitem__</code> to return a <code>Stopwatch</code>. </p> <p>All <code>Stopwatch</code> methods directly update the <code>.stopwatch</code> attribute of the linked <code>Card</code>  instance.</p> ATTRIBUTE DESCRIPTION <code>startedAt</code> <p>The start date of the stopwatch</p> <p> TYPE: <code>datetime</code> </p> <code>total</code> <p>The total time of the stopwatch (in seconds)</p> <p> TYPE: <code>int</code> </p> <code>_card</code> <p>The card the stopwatch is associated with (Managed by the <code>Card</code> class)</p> <p> TYPE: <code>Card</code> </p> Returned by: <ul> <li> Plankapy v1 Card Interfaces Card <ul> <li> <code></code>\u00a0add_stopwatch </li> <li> <code></code>\u00a0remove_stopwatch </li> </ul> </li> </ul> Used by: <ul> <li> Plankapy v1 <ul> <li> Card Interfaces Card <code></code>\u00a0update </li> <li> Board Interfaces List <code></code>\u00a0create_card </li> <li> Models <code></code>\u00a0Card_ </li> </ul> </li> </ul> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Delete the model instance</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>set</code> <p>Set an amount of time for the stopwatch</p> <code>start</code> <p>Starts the stopwatch</p> <code>start_time</code> <p>Returns the datetime the stopwatch was started</p> <code>stop</code> <p>Stops the stopwatch</p> <code>update</code> <p>Update the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.set","title":"set","text":"<pre><code>set(hours: int = 0, minutes: int = 0, seconds: int = 0) -&gt; None\n</code></pre> <p>Set an amount of time for the stopwatch</p> PARAMETER DESCRIPTION <p>Hours to set</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <p>Minutes to set</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <p>Seconds to set</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def set(self, hours: int=0, minutes: int=0, seconds: int=0) -&gt; None:\n    \"\"\"Set an amount of time for the stopwatch\n\n    Args:\n        hours (int): Hours to set\n        minutes (int): Minutes to set\n        seconds (int): Seconds to set\n    \"\"\"\n    self.total = (hours * 3600) + (minutes * 60) + seconds\n    with self._card.editor():\n        self._card.stopwatch = self\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.set(hours)","title":"<code>hours</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.set(minutes)","title":"<code>minutes</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.set(seconds)","title":"<code>seconds</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Starts the stopwatch</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Starts the stopwatch\"\"\"\n    self.refresh()\n    if self.startedAt:\n        return\n    self.startedAt = datetime.now().isoformat()\n    with self._card.editor():\n        self._card.stopwatch = self\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.start_time","title":"start_time","text":"<pre><code>start_time() -&gt; datetime\n</code></pre> <p>Returns the datetime the stopwatch was started</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def start_time(self) -&gt; datetime:\n    \"\"\"Returns the datetime the stopwatch was started\"\"\"\n    self.refresh()\n    return datetime.fromisoformat(self.startedAt) if self.startedAt else None\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.stop","title":"stop","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stops the stopwatch</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stops the stopwatch\"\"\"\n    self.refresh()\n    if not self.startedAt:\n        return\n\n    now = datetime.now()\n    started = datetime.fromisoformat(self.startedAt)\n    self.total += int(now.timestamp() - started.timestamp())\n    self.startedAt = None\n    with self._card.editor():\n        self._card.stopwatch = self\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Stopwatch.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Task_","title":"Task_  <code>dataclass</code>","text":"<pre><code>Task_(id: int | None = Unset, name: str | None = Required, position: int | None = Required, isCompleted: bool = Unset, cardId: int | None = Unset, createdAt: str | None = Unset, updatedAt: str | None = Unset)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Task Model</p> ATTRIBUTE DESCRIPTION <code>id</code> <p>The ID of the task</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>The name of the task</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>The position of the task</p> <p> TYPE: <code>int</code> </p> <code>isCompleted</code> <p>The completion status of the task</p> <p> TYPE: <code>bool</code> </p> <code>cardId</code> <p>The ID of the card the task is associated with</p> <p> TYPE: <code>int</code> </p> <code>createdAt</code> <p>The creation date of the task</p> <p> TYPE: <code>datetime</code> </p> <code>updatedAt</code> <p>The last update date of the task</p> <p> TYPE: <code>datetime</code> </p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Delete the model instance</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>\"Refresh the model instance</p> <code>update</code> <p>Update the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Task_.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Task_.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Task_.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Task_.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Task_.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.Task_.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.Task_.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Task_.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.Task_.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Task_.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Task_.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Task_.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Task_.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Task_.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Task_.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Task_.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Task_.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>\"Refresh the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def refresh(self): \n    \"\"\"\"Refresh the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.Task_.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.User_","title":"User_  <code>dataclass</code>","text":"<pre><code>User_(id: int | None = Unset, name: str | None = Required, username: str | None = Unset, email: str | None = Required, language: str | None = Unset, organization: str | None = Unset, phone: str | None = Unset, avatarUrl: str | None = Unset, isSso: bool | None = Unset, isAdmin: bool = Unset, isDeletionLocked: bool = Unset, isLocked: bool = Unset, isRoleLocked: bool = Unset, isUsernameLocked: bool = Unset, subscribeToOwnCards: bool = Unset, createdAt: str | None = Unset, updatedAt: str | None = Unset, deletedAt: str | None = Unset)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>User Model</p> ATTRIBUTE DESCRIPTION <code>id</code> <p>The ID of the user</p> <p> TYPE: <code>int</code> </p> <code>name</code> <p>The name of the user</p> <p> TYPE: <code>str</code> </p> <code>username</code> <p>The username of the user</p> <p> TYPE: <code>str</code> </p> <code>email</code> <p>The email of the user</p> <p> TYPE: <code>str</code> </p> <code>language</code> <p>The language of the user</p> <p> TYPE: <code>str</code> </p> <code>organization</code> <p>The organization of the user</p> <p> TYPE: <code>str</code> </p> <code>phone</code> <p>The phone of the user</p> <p> TYPE: <code>str</code> </p> <code>avatarUrl</code> <p>The avatar URL of the user</p> <p> TYPE: <code>str</code> </p> <code>isSso</code> <p>The SSO status of the user</p> <p> TYPE: <code>bool</code> </p> <code>isAdmin</code> <p>The admin status of the user</p> <p> TYPE: <code>bool</code> </p> <code>isDeletionLocked</code> <p>The deletion lock status of the user</p> <p> TYPE: <code>bool</code> </p> <code>isLocked</code> <p>The lock status of the user</p> <p> TYPE: <code>bool</code> </p> <code>isRoleLocked</code> <p>The role lock status of the user</p> <p> TYPE: <code>bool</code> </p> <code>isUsernameLocked</code> <p>The username lock status of the user</p> <p> TYPE: <code>bool</code> </p> <code>subscribeToOwnCards</code> <p>The subscription status of the user</p> <p> TYPE: <code>bool</code> </p> <code>createdAt</code> <p>The creation date of the user</p> <p> TYPE: <code>datetime</code> </p> <code>updatedAt</code> <p>The last update date of the user</p> <p> TYPE: <code>datetime</code> </p> <code>deletedAt</code> <p>The deletion date of the user</p> <p> TYPE: <code>datetime</code> </p> METHOD DESCRIPTION <code>__eq__</code> <p>Check if two model instances are equal</p> <code>__getitem__</code> <p>Get the value of an attribute</p> <code>__hash__</code> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> <code>__iter__</code> <p>Iterate over public, assigned model attribute names</p> <code>bind</code> <p>Bind routes to the model</p> <code>delete</code> <p>Delete the model instance</p> <code>editor</code> <p>Context manager for editing the model</p> <code>json</code> <p>Dump the model properties to a JSON string</p> <code>pickle</code> <p>Pickle the model, preserving as much of its state as possible</p> <code>refresh</code> <p>\"Refresh the model instance</p> <code>update</code> <p>Update the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.User_.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime | None\n</code></pre> <p>Get the creation date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.User_.deleted_at","title":"deleted_at  <code>property</code>","text":"<pre><code>deleted_at: datetime | None\n</code></pre> <p>Get the deletion date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.User_.link","title":"link  <code>property</code>","text":"<pre><code>link: str | None\n</code></pre> <p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> RETURNS DESCRIPTION <code>str</code> <p>The link to the model instance</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.User_.routes","title":"routes  <code>property</code> <code>writable</code>","text":"<pre><code>routes: Routes\n</code></pre> <p>Get the routes for the model instance</p> RETURNS DESCRIPTION <code>Routes</code> <p>The routes bound to the model instance</p> <p> TYPE: <code>Routes</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.User_.unique_name","title":"unique_name  <code>property</code>","text":"<pre><code>unique_name: str\n</code></pre> <p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> RETURNS DESCRIPTION <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p> <p> TYPE: <code>str</code> </p>"},{"location":"v1/models/models/#plankapy.v1.models.User_.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime | None\n</code></pre> <p>Get the last update date of the model instance</p> RETURNS DESCRIPTION <code>datetime | None</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"v1/models/models/#plankapy.v1.models.User_.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Model) -&gt; bool\n</code></pre> <p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> PARAMETER DESCRIPTION <p>The other model instance to compare</p> <p> TYPE: <code>Model</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the model instances are equal, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.User_.__eq__(other)","title":"<code>other</code>","text":""},{"location":"v1/models/models/#plankapy.v1.models.User_.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key) -&gt; Any\n</code></pre> <p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.User_.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> RETURNS DESCRIPTION <code>int</code> <p>The hash value of the model instance</p> <p> TYPE: <code>int</code> </p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.User_.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> RETURNS DESCRIPTION <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.User_.bind","title":"bind","text":"<pre><code>bind(routes: Routes) -&gt; Self\n</code></pre> <p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> RETURNS DESCRIPTION <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.User_.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.User_.editor","title":"editor","text":"<pre><code>editor() -&gt; Generator[Self, None, None]\n</code></pre> <p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.User_.json","title":"json","text":"<pre><code>json() -&gt; str\n</code></pre> <p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> RETURNS DESCRIPTION <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.User_.pickle","title":"pickle","text":"<pre><code>pickle() -&gt; bytes\n</code></pre> <p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> RETURNS DESCRIPTION <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.User_.refresh","title":"refresh","text":"<pre><code>refresh()\n</code></pre> <p>\"Refresh the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def refresh(self): \n    \"\"\"\"Refresh the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/models/models/#plankapy.v1.models.User_.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/v1/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"v1/routes/routes/","title":"Routes","text":"CLASS DESCRIPTION <code>Route</code> <p>Wraps a JSONHandler method with a specific HTTP method and endpoint.</p> <code>Routes</code> <p>Container for all routes in the Planka API.</p>"},{"location":"v1/routes/routes/#plankapy.v1.routes.Route","title":"Route","text":"<pre><code>Route(method: RequestType, endpoint: str, handler: JSONHandler)\n</code></pre> <p>Wraps a JSONHandler method with a specific HTTP method and endpoint. On call, it delegates the request to the wrapped method.</p> <p>Usage:</p> <p>route = Route('GET', '/api/projects', handler) route()  Source code in <code>src/plankapy/v1/routes.py</code> <pre><code>def __init__(self, method: RequestType, endpoint: str, handler: JSONHandler):\n    self.handler = handler\n    self.method = method\n    self.endpoint = endpoint\n</code></pre>"},{"location":"v1/routes/routes/#plankapy.v1.routes.Routes","title":"Routes","text":"<pre><code>Routes(handler: JSONHandler)\n</code></pre> <p>Container for all routes in the Planka API. Each method returns a Route object that can be called to make a request.</p> <p>Usage:</p> <p>routes = Routes(handler) route = routes.index() route()  <p>update_card = routes.cards_update(1) update_card(name='Updated name')  Returned by: <ul> <li> Archive <code></code>\u00a0routes </li> <li> Plankapy v1 <ul> <li> Board Interfaces <ul> <li> Board <code></code>\u00a0routes </li> <li> BoardMembership <code></code>\u00a0routes </li> <li> Label <code></code>\u00a0routes </li> <li> List <code></code>\u00a0routes </li> </ul> </li> <li> Card Interfaces <ul> <li> Action <code></code>\u00a0routes </li> <li> Attachment <code></code>\u00a0routes </li> <li> Card <code></code>\u00a0routes </li> <li> CardLabel <code></code>\u00a0routes </li> <li> CardMembership <code></code>\u00a0routes </li> <li> CardSubscription <code></code>\u00a0routes </li> <li> Stopwatch <code></code>\u00a0routes </li> <li> Task <code></code>\u00a0routes </li> </ul> </li> <li> Project Interfaces <ul> <li> Project <code></code>\u00a0routes </li> <li> ProjectManager <code></code>\u00a0routes </li> </ul> </li> <li> User Interfaces <ul> <li> Notification <code></code>\u00a0routes </li> <li> User <code></code>\u00a0routes </li> </ul> </li> <li> Models <ul> <li> <code></code>\u00a0Action_ <code></code>\u00a0routes </li> <li> <code></code>\u00a0Archive_ <code></code>\u00a0routes </li> <li> <code></code>\u00a0Attachment_ <code></code>\u00a0routes </li> <li> <code></code>\u00a0BoardMembership_ <code></code>\u00a0routes </li> <li> <code></code>\u00a0Board_ <code></code>\u00a0routes </li> <li> <code></code>\u00a0CardLabel_ <code></code>\u00a0routes </li> <li> <code></code>\u00a0CardMembership_ <code></code>\u00a0routes </li> <li> <code></code>\u00a0CardSubscription_ <code></code>\u00a0routes </li> <li> <code></code>\u00a0Card_ <code></code>\u00a0routes </li> <li> <code></code>\u00a0IdentityProviderUser_ <code></code>\u00a0routes </li> <li> <code></code>\u00a0Label_ <code></code>\u00a0routes </li> <li> <code></code>\u00a0List_ <code></code>\u00a0routes </li> <li> <code></code>\u00a0Model <code></code>\u00a0routes </li> <li> <code></code>\u00a0Notification_ <code></code>\u00a0routes </li> <li> <code></code>\u00a0ProjectManager_ <code></code>\u00a0routes </li> <li> <code></code>\u00a0Project_ <code></code>\u00a0routes </li> <li> <code></code>\u00a0Stopwatch <code></code>\u00a0routes </li> <li> <code></code>\u00a0Task_ <code></code>\u00a0routes </li> <li> <code></code>\u00a0User_ <code></code>\u00a0routes </li> </ul> </li> </ul> </li> </ul> Used by: <ul> <li> Archive <code></code>\u00a0bind </li> <li> Plankapy v1 <ul> <li> Board Interfaces <ul> <li> Board <code></code>\u00a0bind </li> <li> BoardMembership <code></code>\u00a0bind </li> <li> Label <code></code>\u00a0bind </li> <li> List <code></code>\u00a0bind </li> </ul> </li> <li> Card Interfaces <ul> <li> Action <code></code>\u00a0bind </li> <li> Attachment <code></code>\u00a0bind </li> <li> Card <code></code>\u00a0bind </li> <li> CardLabel <code></code>\u00a0bind </li> <li> CardMembership <code></code>\u00a0bind </li> <li> CardSubscription <code></code>\u00a0bind </li> <li> Stopwatch <code></code>\u00a0bind </li> <li> Task <code></code>\u00a0bind </li> </ul> </li> <li> User Interfaces <ul> <li> Notification <code></code>\u00a0bind </li> <li> User <code></code>\u00a0bind </li> </ul> </li> <li> Project Interfaces <ul> <li> Project <code></code>\u00a0bind </li> <li> ProjectManager <code></code>\u00a0bind </li> </ul> </li> <li> Models <ul> <li> <code></code>\u00a0Action_ <code></code>\u00a0bind </li> <li> <code></code>\u00a0Archive_ <code></code>\u00a0bind </li> <li> <code></code>\u00a0Attachment_ <code></code>\u00a0bind </li> <li> <code></code>\u00a0BoardMembership_ <code></code>\u00a0bind </li> <li> <code></code>\u00a0Board_ <code></code>\u00a0bind </li> <li> <code></code>\u00a0CardLabel_ <code></code>\u00a0bind </li> <li> <code></code>\u00a0CardMembership_ <code></code>\u00a0bind </li> <li> <code></code>\u00a0CardSubscription_ <code></code>\u00a0bind </li> <li> <code></code>\u00a0Card_ <code></code>\u00a0bind </li> <li> <code></code>\u00a0IdentityProviderUser_ <code></code>\u00a0bind </li> <li> <code></code>\u00a0Label_ <code></code>\u00a0bind </li> <li> <code></code>\u00a0List_ <code></code>\u00a0bind </li> <li> <code></code>\u00a0Model <code></code>\u00a0bind </li> <li> <code></code>\u00a0Notification_ <code></code>\u00a0bind </li> <li> <code></code>\u00a0ProjectManager_ <code></code>\u00a0bind </li> <li> <code></code>\u00a0Project_ <code></code>\u00a0bind </li> <li> <code></code>\u00a0Stopwatch <code></code>\u00a0bind </li> <li> <code></code>\u00a0Task_ <code></code>\u00a0bind </li> <li> <code></code>\u00a0User_ <code></code>\u00a0bind </li> </ul> </li> </ul> </li> </ul> Source code in <code>src/plankapy/v1/routes.py</code> <pre><code>def __init__(self, handler: JSONHandler) -&gt; None:\n    self.handler = handler\n</code></pre>"},{"location":"v2/interface/","title":"Planka Interface","text":""},{"location":"v2/interface/#plankapy.v2.interface","title":"interface","text":"<p>Base interface for Planka</p> <p>When reading the documentation, all returned <code>list[PlankaModel]</code> types are  actually <code>models.ModelLists</code> at runtime. These will also be properly type hinted by  your static type checker and expose some alternate ways of indexing into model lists:</p> <p>Example: <pre><code>&gt;&gt;&gt; type(planka.projects)\nModelList\n\n# Using an exact schema filter\n&gt;&gt;&gt; planka.projects[{'name': 'My Project'}]\n[Project(name='My Project', ...)]\n\n# Using a functional schema filter (name is replaced with the value of name)\n&gt;&gt;&gt; planka.projects[{'name': lambda name: 'My' in name}]\n[Project(name='My Project', ...), Project(name='My Other Project', ...)]\n\n# Using a model filter\n&gt;&gt;&gt; planka.projects[lambda project: project.owner == planka.me]\n[&lt;previous results&gt;..., Project('Another Project I Own', ...)]\n</code></pre></p> <p>All dictionary based schema filtering can be done per key and the model will only  be included in the output if all filters match.</p> <p>Additionally, a <code>dpop</code> method is included that allows popping from a model list with  a default value if no results <pre><code>&gt;&gt;&gt; filtered = to_do_list.cards[lambda c: c.due_date and (c.due_date - datetime.now()).days &lt; 4]\n&gt;&gt;&gt; if next_card := filtered.dpop():\n...     print(next_card.url)\n...     print(next_card.name)\n... else:\n...     print('No results')\nhttps://planka.mydomain.com/cards/1234...\n'Critical Project'\n--or--\nNo results\n</code></pre></p> CLASS DESCRIPTION <code>Planka</code> <p>Root object for connecting to a Planka instance</p>"},{"location":"v2/interface/#plankapy.v2.interface.Planka","title":"Planka","text":"<pre><code>Planka(base_url: str | URL | None = None, *, client: Client | None = None, timezone: timezone = utc)\n</code></pre> <p>Root object for connecting to a Planka instance</p> <p>A Planka instance can be initialized using a <code>base_url</code> or a <code>httpx.Client</code> objcet. If both arguments are passed, the <code>base_url</code> of the passed client will be overriden with the url passed to the <code>base_url</code> argument</p> Example <pre><code># Using the default client\n&gt;&gt;&gt; planka = Planka('https://planka.example.com')\n... planka.client\n&lt;httpx.Client object at 0x...&gt;\n\n&gt;&gt;&gt; planka.client.base_url\nURL('https://planka.example.com')\n\n# Using a pre-configured client\n&gt;&gt;&gt; hooks = {'request': [hook1, hook2], 'response': [hook3, hook4]}\n... client = Client(event_hooks=hooks)\n... planka = Planka('https://planka.example.com', client=client)\n... planka.client.event_hooks\n{'request': [&lt;hook1&gt;, &lt;hook2&gt;], 'response': [&lt;hook3&gt;, &lt;hook4&gt;]}\n</code></pre> <p>All Planka sessions will respect the configuration of the passed client object. For more configuration  options, see the httpx docs: https://www.python-httpx.org/advanced/clients/</p> <p>After initializing, the Planka instance required the authorization flow to  take place using the <code>login</code> method</p> Example <p><pre><code>&gt;&gt;&gt; # Using an API key\n... planka.login(api_key='&lt;my_api_key&gt;')\n... planka.projects\n[Project(...), Project(...), ...]\n</code></pre> <pre><code>&gt;&gt;&gt; # First time login (accept instance ToS)\n... planka.login(username='me@email.com', password='mypassword', accept_terms=True)\nTERMS OF SERVICE\n--- More ToS ---\n\n&gt;&gt;&gt; planka.projects\n[Project(...), Project(...), ...]\n</code></pre></p> <p>Logging in with a username and password will work, but it's best practice to authenticate  using an api key, which you can get from your instance administrator.</p> PARAMETER DESCRIPTION <p>The base url of the instance (e.g. <code>https://planka.app</code>)</p> <p> TYPE: <code>str | URL | None</code> DEFAULT: <code>None</code> </p> <p>An optional pre-configured <code>httpx.Client</code> object to use as the session client</p> <p> TYPE: <code>Client | None</code> DEFAULT: <code>None</code> </p> <p>An optional timezone to cast all datetimes to for date math</p> <p> TYPE: <code>timezone</code> DEFAULT: <code>utc</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If no base_url or no client with a base_url</p> Used by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0snapshot </li> <li> models <ul> <li> Action <code></code>\u00a0Action </li> <li> Attachment <code></code>\u00a0Attachment </li> <li> Background Image <code></code>\u00a0BackgroundImage </li> <li> Base Custom Field Group <code></code>\u00a0BaseCustomFieldGroup </li> <li> Board <code></code>\u00a0Board </li> <li> Board Membership <code></code>\u00a0BoardMembership </li> <li> Card <code></code>\u00a0Card </li> <li> Card Label <code></code>\u00a0CardLabel </li> <li> Card Membership <code></code>\u00a0CardMembership </li> <li> Comment <code></code>\u00a0Comment </li> <li> Config <code></code>\u00a0Config </li> <li> Custom Field <code></code>\u00a0CustomField </li> <li> Custom Field Group <code></code>\u00a0CustomFieldGroup </li> <li> Custom Field Value <code></code>\u00a0CustomFieldValue </li> <li> Label <code></code>\u00a0Label </li> <li> List <code></code>\u00a0List </li> <li> Notification <code></code>\u00a0Notification </li> <li> Notification Service <code></code>\u00a0NotificationService </li> <li> Planka Base Model <code></code>\u00a0PlankaModel </li> <li> Project <code></code>\u00a0Project </li> <li> Project Manager <code></code>\u00a0ProjectManager </li> <li> Task <code></code>\u00a0Task </li> <li> Task List <code></code>\u00a0TaskList </li> <li> User <code></code>\u00a0User </li> <li> Webhook <code></code>\u00a0Webhook </li> </ul> </li> </ul> </li> </ul> METHOD DESCRIPTION <code>accept_terms</code> <p>If the User has never logged on, or is required to accept new terms, allow them to do so</p> <code>create_project</code> <p>Creates a project. The current user automatically becomes a project manager.</p> <code>create_user</code> <p>Creates a user account. Requires admin privileges.</p> <code>create_webhook</code> <p>Create a Webhook. Requires admin</p> <code>login</code> <p>Authenticate with the planka instance</p> <code>logout</code> <p>Logout the current User</p> <code>read_notifications</code> <p>Read all Notifications for the current User</p> ATTRIBUTE DESCRIPTION <code>config</code> <p>Get the configuration info for the current Planka server</p> <p> TYPE: <code>Config</code> </p> <code>me</code> <p>Get the User object for the currently logged in user</p> <p> TYPE: <code>User</code> </p> <code>notifications</code> <p>Get all notifications for the current User</p> <p> TYPE: <code>list[Notification]</code> </p> <code>projects</code> <p>Get all Projects available to the current user</p> <p> TYPE: <code>list[Project]</code> </p> <code>unread_notifications</code> <p>Get all unread Notifications for the current user</p> <p> TYPE: <code>list[Notification]</code> </p> <code>users</code> <p>Get all Users on the current instance (requires admin or projectOwner role)</p> <p> TYPE: <code>list[User]</code> </p> <code>webhooks</code> <p>Get all configured Webhooks (requires admin)</p> <p> TYPE: <code>list[Webhook]</code> </p> Source code in <code>src/plankapy/v2/interface.py</code> <pre><code>def __init__(self, \n             base_url: str|URL|None=None, \n             *, \n             client: Client|None=None, \n             timezone: timezone = timezone.utc) -&gt; None:\n    \"\"\"\n    Args:\n        base_url: The base url of the instance (e.g. `https://planka.app`)\n        client: An optional pre-configured `httpx.Client` object to use as the session client\n        timezone: An optional timezone to cast all datetimes to for date math\n\n    Raises:\n        ValueError: If no base_url or no client with a base_url\n    \"\"\"\n    if client is None and base_url:\n        self.client = Client(base_url=base_url)\n    elif client and base_url is None:\n        if not client.base_url:\n            raise ValueError(\n                f'If using a client, the client\\'s base_url attribute must be set '\n                'or a base_url must be passed to the Planka initializer'\n            )\n        self.client = client\n    elif base_url and client:\n        self.client = client\n        self.client.base_url = base_url\n    else:\n        raise ValueError(f'base_url and/or client must be passed')\n\n    self.endpoints = PlankaEndpoints(self.client)\n    self.timezone = timezone\n\n    # Assigned after login() is called\n    self.current_role: UserRole | None = None\n    self.current_id : str | None = None\n</code></pre>"},{"location":"v2/interface/#plankapy.v2.interface.Planka(base_url)","title":"<code>base_url</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka(client)","title":"<code>client</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka(timezone)","title":"<code>timezone</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.config","title":"config  <code>cached</code> <code>property</code>","text":"<pre><code>config: Config\n</code></pre> <p>Get the configuration info for the current Planka server</p>"},{"location":"v2/interface/#plankapy.v2.interface.Planka.me","title":"me  <code>cached</code> <code>property</code>","text":"<pre><code>me: User\n</code></pre> <p>Get the User object for the currently logged in user</p>"},{"location":"v2/interface/#plankapy.v2.interface.Planka.notifications","title":"notifications  <code>property</code>","text":"<pre><code>notifications: list[Notification]\n</code></pre> <p>Get all notifications for the current User</p>"},{"location":"v2/interface/#plankapy.v2.interface.Planka.projects","title":"projects  <code>property</code>","text":"<pre><code>projects: list[Project]\n</code></pre> <p>Get all Projects available to the current user</p> Note <p>admins will get all instance Projects projectOwners will get all owned projects and shared projects all others will get only assigned and shared projects</p>"},{"location":"v2/interface/#plankapy.v2.interface.Planka.unread_notifications","title":"unread_notifications  <code>property</code>","text":"<pre><code>unread_notifications: list[Notification]\n</code></pre> <p>Get all unread Notifications for the current user</p>"},{"location":"v2/interface/#plankapy.v2.interface.Planka.users","title":"users  <code>property</code>","text":"<pre><code>users: list[User]\n</code></pre> <p>Get all Users on the current instance (requires admin or projectOwner role)</p> Note <p>projectOwners will only get Users in their Projects admins will get all instance Users all others will get an empty list</p>"},{"location":"v2/interface/#plankapy.v2.interface.Planka.webhooks","title":"webhooks  <code>property</code>","text":"<pre><code>webhooks: list[Webhook]\n</code></pre> <p>Get all configured Webhooks (requires admin)</p>"},{"location":"v2/interface/#plankapy.v2.interface.Planka.accept_terms","title":"accept_terms","text":"<pre><code>accept_terms(pending_token: str, terms_type: TermsType = 'general', lang: Language = 'en-US')\n</code></pre> <p>If the User has never logged on, or is required to accept new terms, allow them to do so</p> Source code in <code>src/plankapy/v2/interface.py</code> <pre><code>def accept_terms(self, pending_token: str, terms_type: TermsType='general', lang: Language='en-US'):\n    \"\"\"If the User has never logged on, or is required to accept new terms, allow them to do so\"\"\"\n    terms = self.endpoints.getTerms(type=terms_type, language=lang)['item']\n    print(terms['content'])\n    sig = terms['signature']\n    self.endpoints.acceptTerms(pendingToken=pending_token, signature=sig)\n</code></pre>"},{"location":"v2/interface/#plankapy.v2.interface.Planka.create_project","title":"create_project","text":"<pre><code>create_project(*, name: str, type: ProjectType, description: str | None = None) -&gt; Project\n</code></pre> <p>Creates a project. The current user automatically becomes a project manager.</p> <p>Must be a Project Owner or an Admin</p> PARAMETER DESCRIPTION <p>Type of the project</p> <p> TYPE: <code>ProjectType</code> </p> <p>Name/title of the project</p> <p> TYPE: <code>str</code> </p> <p>Detailed description of the project</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/plankapy/v2/interface.py</code> <pre><code>def create_project(self, \n                   *,\n                   name: str,\n                   type: ProjectType,\n                   description: str|None=None) -&gt; Project:\n    \"\"\"Creates a project. The current user automatically becomes a project manager.\n\n    Must be a Project Owner or an Admin\n\n    Args:\n        type: Type of the project\n        name: Name/title of the project\n        description: Detailed description of the project\n    \"\"\"\n    return Project(\n        self.endpoints.createProject(\n            name=name, \n            type=type, \n            description=description,\n        )['item'], \n        self\n    )\n</code></pre>"},{"location":"v2/interface/#plankapy.v2.interface.Planka.create_project(type)","title":"<code>type</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.create_project(name)","title":"<code>name</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.create_project(description)","title":"<code>description</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.create_user","title":"create_user","text":"<pre><code>create_user(*, email: str, password: str, role: UserRole, name: str, username: str | None = None, phone: str | None = None, organization: str | None = None, language: Language | None = None, subscribe_to_own_cards: bool = False, subscribe_to_cards_when_commenting: bool = True, turn_off_recent_card_highlighting: bool = False) -&gt; User\n</code></pre> <p>Creates a user account. Requires admin privileges.</p> <p>Only <code>email</code>, <code>password</code>, <code>role</code>, and <code>name</code> are required</p> PARAMETER DESCRIPTION <p>Email address for login and notifications</p> <p> TYPE: <code>str</code> </p> <p>Password for user authentication (must meet password requirements)</p> <p> TYPE: <code>str</code> </p> <p>User role defining access permissions</p> <p> TYPE: <code>UserRole</code> </p> <p>Full display name of the user</p> <p> TYPE: <code>str</code> </p> <p>Unique username for user identification</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <p>Contact phone number</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <p>Organization or company name</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <p>Preferred language for user interface and notifications (example: <code>en-US</code>)</p> <p> TYPE: <code>LanguageCode</code> DEFAULT: <code>None</code> </p> <p>Whether the user subscribes to their own cards</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Whether the user subscribes to cards when commenting</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <p>Whether recent card highlighting is disabled</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/plankapy/v2/interface.py</code> <pre><code>def create_user(self, \n                *,\n                email: str,\n                password: str,\n                role: UserRole,\n                name: str,\n                username: str|None=None,\n                phone: str|None=None,\n                organization: str|None=None,\n                language: Language|None=None,\n                subscribe_to_own_cards: bool=False,\n                subscribe_to_cards_when_commenting: bool=True,\n                turn_off_recent_card_highlighting: bool=False) -&gt; User:\n    \"\"\"Creates a user account. Requires admin privileges.\n\n    Only `email`, `password`, `role`, and `name` are required\n\n    Args:\n        email (str): Email address for login and notifications\n        password (str): Password for user authentication (must meet password requirements)\n        role (UserRole): User role defining access permissions\n        name (str): Full display name of the user\n        username (str): Unique username for user identification\n        phone (str): Contact phone number\n        organization (str): Organization or company name\n        language (LanguageCode): Preferred language for user interface and notifications (example: `en-US`)\n        subscribe_to_own_cards (bool): Whether the user subscribes to their own cards\n        subscribe_to_cards_when_commenting (bool): Whether the user subscribes to cards when commenting\n        turn_off_recent_card_highlighting (bool): Whether recent card highlighting is disabled\n    \"\"\"\n\n    return User(\n        self.endpoints.createUser(\n            email=email,\n            password=password,\n            role=role,\n            name=name,\n            username=username,\n            phone=phone,\n            organization=organization,\n            language=language,\n            subscribeToOwnCards=subscribe_to_own_cards,\n            subscribeToCardWhenCommenting=subscribe_to_cards_when_commenting,\n            turnOffRecentCardHighlighting=turn_off_recent_card_highlighting,\n        )['item'], \n        self\n    )\n</code></pre>"},{"location":"v2/interface/#plankapy.v2.interface.Planka.create_user(email)","title":"<code>email</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.create_user(password)","title":"<code>password</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.create_user(role)","title":"<code>role</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.create_user(name)","title":"<code>name</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.create_user(username)","title":"<code>username</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.create_user(phone)","title":"<code>phone</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.create_user(organization)","title":"<code>organization</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.create_user(language)","title":"<code>language</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.create_user(subscribe_to_own_cards)","title":"<code>subscribe_to_own_cards</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.create_user(subscribe_to_cards_when_commenting)","title":"<code>subscribe_to_cards_when_commenting</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.create_user(turn_off_recent_card_highlighting)","title":"<code>turn_off_recent_card_highlighting</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.create_webhook","title":"create_webhook","text":"<pre><code>create_webhook(*, name: str, url: str, access_token: str | None = None, events: Sequence[PlankaEvent] | None = None, excluded_events: Sequence[PlankaEvent] | None = None) -&gt; Webhook\n</code></pre> <p>Create a Webhook. Requires admin</p> PARAMETER DESCRIPTION <p>Name/title of the webhook</p> <p> TYPE: <code>str</code> </p> <p>URL endpoint for the webhook</p> <p> TYPE: <code>str</code> </p> <p>Access token for webhook authentication</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <p>list of events that trigger the webhook</p> <p> TYPE: <code>Sequence[PlankaEvent] | None</code> DEFAULT: <code>None</code> </p> <p>Comma-separated list of events excluded from the webhook</p> <p> TYPE: <code>Sequence[PlankaEvent] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/plankapy/v2/interface.py</code> <pre><code>def create_webhook(self, \n                   *,\n                   name: str,\n                   url: str,\n                   access_token: str|None=None,\n                   events: Sequence[events.PlankaEvent]|None=None,\n                   excluded_events: Sequence[events.PlankaEvent]|None=None) -&gt; Webhook:\n    \"\"\"Create a Webhook. Requires admin\n\n    Args:\n        name: Name/title of the webhook\n        url: URL endpoint for the webhook\n        access_token: Access token for webhook authentication\n        events: list of events that trigger the webhook\n        excluded_events: Comma-separated list of events excluded from the webhook\n    \"\"\"\n    args = {\n        'name': name,\n        'url': url\n    }\n    if events:\n        args['events'] = ','.join(events)\n    if excluded_events:\n        args['excludedEvents'] = ','.join(excluded_events)\n    if access_token:\n        args['accessToken'] = access_token\n    return Webhook(self.endpoints.createWebhook(**args)['item'], self)\n</code></pre>"},{"location":"v2/interface/#plankapy.v2.interface.Planka.create_webhook(name)","title":"<code>name</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.create_webhook(url)","title":"<code>url</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.create_webhook(access_token)","title":"<code>access_token</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.create_webhook(events)","title":"<code>events</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.create_webhook(excluded_events)","title":"<code>excluded_events</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.login","title":"login","text":"<pre><code>login(*, username: str | None = None, password: str | None = None, api_key: str | None = None, accept_terms: TermsType | None = None, terms_lang: Language = 'en-US') -&gt; None\n</code></pre> <p>Authenticate with the planka instance</p> PARAMETER DESCRIPTION <p>User username/email </p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <p>User password</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <p>User API Key</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <p>If you user has not accepted the terms, run the term acceptance flow</p> <p> TYPE: <code>TermsType | None</code> DEFAULT: <code>None</code> </p> <p>If accepting terms, request them in this language</p> <p> TYPE: <code>Language</code> DEFAULT: <code>'en-US'</code> </p> Note <p>After accepting the terms, please get an API key from the Planka server. If you need to accept extended terms, please  set the <code>terms</code> flag to the terms you are accepting. These terms will be printed to <code>stdout</code> during the flow.</p> Source code in <code>src/plankapy/v2/interface.py</code> <pre><code>def login(self, \n          *, \n          username: str|None=None, \n          password: str|None=None, \n          api_key: str|None=None, \n          accept_terms: TermsType | None=None,\n          terms_lang: Language='en-US') -&gt; None:\n\n    \"\"\"Authenticate with the planka instance\n\n    Args:\n        username (str | None): User username/email \n        password (str | None): User password\n        api_key (str | None): User API Key\n        accept_terms (TermsType | None): If you user has not accepted the terms, run the term acceptance flow\n        terms_lang: If accepting terms, request them in this language\n\n    Note:\n        After accepting the terms, please get an API key from the Planka server. If you need to accept extended terms, please \n        set the `terms` flag to the terms you are accepting. These terms will be printed to `stdout` during the flow.\n    \"\"\"\n    # API Key\n    if api_key:\n        self.client.headers['X-Api-Key'] = api_key\n\n    # User/Pass with term acceptance flow\n    elif username and password:\n        try:\n            # Get Bearer Auth\n            token = self.endpoints.createAccessToken(emailOrUsername=username, password=password, withHttpOnlyToken=True)['item']\n            self.client.headers['Authorization'] = f'Bearer {token}'\n        except HTTPStatusError as e:\n            if accept_terms is None:\n                raise PermissionError(f'Please logon again with `accept_terms` set to the terms you must accept')\n            self.accept_terms(e.response.json()['pendingToken'], terms_type=accept_terms, lang=terms_lang)\n            self.login(username=username, password=password)\n\n    # Invalid Creds\n    else:\n        raise PermissionError(f'No credentials supplied! Must provide a user/password or an api_key')\n\n    self.current_role = self.me.role\n    self.current_id = self.me.id\n</code></pre>"},{"location":"v2/interface/#plankapy.v2.interface.Planka.login(username)","title":"<code>username</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.login(password)","title":"<code>password</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.login(api_key)","title":"<code>api_key</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.login(accept_terms)","title":"<code>accept_terms</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.login(terms_lang)","title":"<code>terms_lang</code>","text":""},{"location":"v2/interface/#plankapy.v2.interface.Planka.logout","title":"logout","text":"<pre><code>logout() -&gt; None\n</code></pre> <p>Logout the current User</p> Source code in <code>src/plankapy/v2/interface.py</code> <pre><code>def logout(self) -&gt; None:\n    \"\"\"Logout the current User\"\"\"\n    self.endpoints.deleteAccessToken()\n</code></pre>"},{"location":"v2/interface/#plankapy.v2.interface.Planka.read_notifications","title":"read_notifications","text":"<pre><code>read_notifications() -&gt; list[Notification]\n</code></pre> <p>Read all Notifications for the current User</p> Source code in <code>src/plankapy/v2/interface.py</code> <pre><code>@model_list\ndef read_notifications(self) -&gt; list[Notification]:\n    \"\"\"Read all Notifications for the current User\"\"\"\n    return [Notification(n, self) for n in self.endpoints.readAllNotifications()['items']]\n</code></pre>"},{"location":"v2/utils/","title":"Planka Utilities","text":"<p>Utility functions for dealing with Planka objects</p> CLASS DESCRIPTION <code>PlankaSnapshot</code> FUNCTION DESCRIPTION <code>due_in</code> <p>Decorated function for use with a ModelList</p> <code>board_to_csv</code> <p>Write the current board state out to a csv file</p> <code>board_to_table</code> <p>Get a nested list/table for the board. </p> <code>snapshot</code> <p>Create a dictionary snapshot of a Planka object. (MUST BE ADMIN)</p>"},{"location":"v2/utils/#plankapy.v2.utils.PlankaSnapshot","title":"PlankaSnapshot","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 Planka Utilities <code></code>\u00a0snapshot </li> </ul> ATTRIBUTE DESCRIPTION <code>projects</code> <p>Project Schemas</p> <p> TYPE: <code>list[Project]</code> </p> <code>boards</code> <p>Board Schemas</p> <p> TYPE: <code>list[Board]</code> </p> <code>lists</code> <p>List Schemas</p> <p> TYPE: <code>list[List]</code> </p> <code>cards</code> <p>Card Schemas</p> <p> TYPE: <code>list[Card]</code> </p> <code>card_labels</code> <p>Card Label Schemas</p> <p> TYPE: <code>list[CardLabel]</code> </p> <code>card_memberships</code> <p>Card Membership Schemas</p> <p> TYPE: <code>list[CardMembership]</code> </p> <code>task_lists</code> <p>Task List Schemas</p> <p> TYPE: <code>list[TaskList]</code> </p> <code>tasks</code> <p>Task Schemas</p> <p> TYPE: <code>list[Task]</code> </p> <code>base_custom_field_groups</code> <p>Base Custom Field Group schemas</p> <p> TYPE: <code>list[BaseCustomFieldGroup]</code> </p> <code>custom_field_groups</code> <p>Custom Field Group Schemas</p> <p> TYPE: <code>list[CustomFieldGroup]</code> </p> <code>custom_fields</code> <p>Custom Field Schemas</p> <p> TYPE: <code>list[CustomField]</code> </p> <code>custom_field_values</code> <p>Custom Field Value Schemas</p> <p> TYPE: <code>list[CustomFieldValue]</code> </p> <code>comments</code> <p>Comment Schemas</p> <p> TYPE: <code>list[Comment]</code> </p> <code>webhooks</code> <p>Webhook Schemas</p> <p> TYPE: <code>list[Webhook]</code> </p> <code>users</code> <p>User Schemas</p> <p> TYPE: <code>list[User]</code> </p> <code>board_memberships</code> <p>Board Membership Schemas</p> <p> TYPE: <code>list[BoardMembership]</code> </p> <code>project_managers</code> <p>Project Manager Schemas</p> <p> TYPE: <code>list[ProjectManager]</code> </p> <code>labels</code> <p>Label Schemas</p> <p> TYPE: <code>list[Label]</code> </p> <code>notification_services</code> <p>Notificaiton Service Schemas</p> <p> TYPE: <code>list[NotificationService]</code> </p> <code>actions</code> <p>Action Schemas</p> <p> TYPE: <code>list[Action]</code> </p> <code>config</code> <p>Config Schema</p> <p> TYPE: <code>Config</code> </p>"},{"location":"v2/utils/#plankapy.v2.utils.PlankaSnapshot.projects","title":"projects  <code>instance-attribute</code>","text":"<pre><code>projects: list[Project]\n</code></pre> <p>Project Schemas</p>"},{"location":"v2/utils/#plankapy.v2.utils.PlankaSnapshot.boards","title":"boards  <code>instance-attribute</code>","text":"<pre><code>boards: list[Board]\n</code></pre> <p>Board Schemas</p>"},{"location":"v2/utils/#plankapy.v2.utils.PlankaSnapshot.lists","title":"lists  <code>instance-attribute</code>","text":"<pre><code>lists: list[List]\n</code></pre> <p>List Schemas</p>"},{"location":"v2/utils/#plankapy.v2.utils.PlankaSnapshot.cards","title":"cards  <code>instance-attribute</code>","text":"<pre><code>cards: list[Card]\n</code></pre> <p>Card Schemas</p>"},{"location":"v2/utils/#plankapy.v2.utils.PlankaSnapshot.card_labels","title":"card_labels  <code>instance-attribute</code>","text":"<pre><code>card_labels: list[CardLabel]\n</code></pre> <p>Card Label Schemas</p>"},{"location":"v2/utils/#plankapy.v2.utils.PlankaSnapshot.card_memberships","title":"card_memberships  <code>instance-attribute</code>","text":"<pre><code>card_memberships: list[CardMembership]\n</code></pre> <p>Card Membership Schemas</p>"},{"location":"v2/utils/#plankapy.v2.utils.PlankaSnapshot.task_lists","title":"task_lists  <code>instance-attribute</code>","text":"<pre><code>task_lists: list[TaskList]\n</code></pre> <p>Task List Schemas</p>"},{"location":"v2/utils/#plankapy.v2.utils.PlankaSnapshot.tasks","title":"tasks  <code>instance-attribute</code>","text":"<pre><code>tasks: list[Task]\n</code></pre> <p>Task Schemas</p>"},{"location":"v2/utils/#plankapy.v2.utils.PlankaSnapshot.base_custom_field_groups","title":"base_custom_field_groups  <code>instance-attribute</code>","text":"<pre><code>base_custom_field_groups: list[BaseCustomFieldGroup]\n</code></pre> <p>Base Custom Field Group schemas</p>"},{"location":"v2/utils/#plankapy.v2.utils.PlankaSnapshot.custom_field_groups","title":"custom_field_groups  <code>instance-attribute</code>","text":"<pre><code>custom_field_groups: list[CustomFieldGroup]\n</code></pre> <p>Custom Field Group Schemas</p>"},{"location":"v2/utils/#plankapy.v2.utils.PlankaSnapshot.custom_fields","title":"custom_fields  <code>instance-attribute</code>","text":"<pre><code>custom_fields: list[CustomField]\n</code></pre> <p>Custom Field Schemas</p>"},{"location":"v2/utils/#plankapy.v2.utils.PlankaSnapshot.custom_field_values","title":"custom_field_values  <code>instance-attribute</code>","text":"<pre><code>custom_field_values: list[CustomFieldValue]\n</code></pre> <p>Custom Field Value Schemas</p>"},{"location":"v2/utils/#plankapy.v2.utils.PlankaSnapshot.comments","title":"comments  <code>instance-attribute</code>","text":"<pre><code>comments: list[Comment]\n</code></pre> <p>Comment Schemas</p>"},{"location":"v2/utils/#plankapy.v2.utils.PlankaSnapshot.webhooks","title":"webhooks  <code>instance-attribute</code>","text":"<pre><code>webhooks: list[Webhook]\n</code></pre> <p>Webhook Schemas</p>"},{"location":"v2/utils/#plankapy.v2.utils.PlankaSnapshot.users","title":"users  <code>instance-attribute</code>","text":"<pre><code>users: list[User]\n</code></pre> <p>User Schemas</p>"},{"location":"v2/utils/#plankapy.v2.utils.PlankaSnapshot.board_memberships","title":"board_memberships  <code>instance-attribute</code>","text":"<pre><code>board_memberships: list[BoardMembership]\n</code></pre> <p>Board Membership Schemas</p>"},{"location":"v2/utils/#plankapy.v2.utils.PlankaSnapshot.project_managers","title":"project_managers  <code>instance-attribute</code>","text":"<pre><code>project_managers: list[ProjectManager]\n</code></pre> <p>Project Manager Schemas</p>"},{"location":"v2/utils/#plankapy.v2.utils.PlankaSnapshot.labels","title":"labels  <code>instance-attribute</code>","text":"<pre><code>labels: list[Label]\n</code></pre> <p>Label Schemas</p>"},{"location":"v2/utils/#plankapy.v2.utils.PlankaSnapshot.notification_services","title":"notification_services  <code>instance-attribute</code>","text":"<pre><code>notification_services: list[NotificationService]\n</code></pre> <p>Notificaiton Service Schemas</p>"},{"location":"v2/utils/#plankapy.v2.utils.PlankaSnapshot.actions","title":"actions  <code>instance-attribute</code>","text":"<pre><code>actions: list[Action]\n</code></pre> <p>Action Schemas</p>"},{"location":"v2/utils/#plankapy.v2.utils.PlankaSnapshot.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config: Config\n</code></pre> <p>Config Schema</p>"},{"location":"v2/utils/#plankapy.v2.utils.due_in","title":"due_in","text":"<pre><code>due_in(hours: float = 0, days: float = 0, weeks: float = 0)\n</code></pre> <p>Decorated function for use with a ModelList That allows filtering by date</p> Source code in <code>src/plankapy/v2/utils.py</code> <pre><code>def due_in(hours: float=0, days: float=0, weeks: float=0):\n    \"\"\"Decorated function for use with a [ModelList](plankapy.v2.models._helpers.ModelList)\n    That allows filtering by date\n    \"\"\"\n    def _inner(m: HasDueDate):\n        if not m.due_date:\n            return False\n        by = timedelta(days=days, hours=hours, weeks=weeks)\n        return (m.due_date - by) &lt;= datetime.now(tz=timezone.utc)\n    return _inner\n</code></pre>"},{"location":"v2/utils/#plankapy.v2.utils.board_to_csv","title":"board_to_csv","text":"<pre><code>board_to_csv(board: Board, outdir: str | Path = '.', name: str | None = None)\n</code></pre> <p>Write the current board state out to a csv file</p> <p>Writes out a csv of the board state using <code>list.name</code> and <code>card.name</code> as  the headers and values respectively. Will match visual state of the board.</p> PARAMETER DESCRIPTION <p>The board to export</p> <p> TYPE: <code>Board</code> </p> <p>A string or Path to the outpud directory (default: <code>cwd</code>)</p> <p> TYPE: <code>str | Path</code> DEFAULT: <code>'.'</code> </p> <p>An optional overrde for the filename (default: <code>board.name</code>)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/plankapy/v2/utils.py</code> <pre><code>def board_to_csv(board: Board, outdir: str|Path='.', name: str|None=None):\n    \"\"\"Write the current board state out to a csv file\n\n    Writes out a csv of the board state using `list.name` and `card.name` as \n    the headers and values respectively. Will match visual state of the board.\n\n    Args:\n        board: The board to export\n        outdir: A string or Path to the outpud directory (default: `cwd`)\n        name: An optional overrde for the filename (default: `board.name`)\n    \"\"\"\n    outfile = Path(outdir) / f'{name or board.name}.csv'\n    rows = board_to_table(board)\n    with outfile.open('wt') as csv:\n        csv.writelines(','.join(row)+'\\n' for row in rows)\n</code></pre>"},{"location":"v2/utils/#plankapy.v2.utils.board_to_csv(board)","title":"<code>board</code>","text":""},{"location":"v2/utils/#plankapy.v2.utils.board_to_csv(outdir)","title":"<code>outdir</code>","text":""},{"location":"v2/utils/#plankapy.v2.utils.board_to_csv(name)","title":"<code>name</code>","text":""},{"location":"v2/utils/#plankapy.v2.utils.board_to_table","title":"board_to_table","text":"<pre><code>board_to_table(board: Board) -&gt; list[list[str]]\n</code></pre> <p>Get a nested list/table for the board.  Uses <code>name</code> attributes of cards and lists</p> PARAMETER DESCRIPTION <p>The board object to tablify</p> <p> TYPE: <code>Board</code> </p> RETURNS DESCRIPTION <code>list[list[str]]</code> <p>A matrix of string lists with the first element being list names </p> <code>list[list[str]]</code> <p>and the remaining elements being card names from left to right    </p> <code>list[list[str]]</code> <p>```</p> <code>list[list[str]]</code> <p>[ ['list1', 'list2'], ['l1 c1', 'l2 c1'], ['l1 c2', 'l2 c2'], ...</p> <code>list[list[str]]</code> <p>]</p> <code>list[list[str]]</code> <p>```</p> Source code in <code>src/plankapy/v2/utils.py</code> <pre><code>def board_to_table(board: Board) -&gt; list[list[str]]:\n    \"\"\"Get a nested list/table for the board. \n    Uses `name` attributes of cards and lists\n\n    Args:\n        board: The board object to tablify\n\n    Returns:\n        A matrix of string lists with the first element being list names \n        and the remaining elements being card names from left to right    \n        ```\n        [\n            ['list1', 'list2'],\n            ['l1 c1', 'l2 c1'],\n            ['l1 c2', 'l2 c2'],\n            ...\n        ]\n        ```\n    \"\"\"\n    headers: list[str] = board.lists.extract('name')\n    list_cards: list[list[str]] = [\n        lst.cards.extract('name')\n        for lst in board.lists\n    ]\n    rows = zip_longest(*list_cards, fillvalue='')\n    return [headers]+[list(row) for row in rows]\n</code></pre>"},{"location":"v2/utils/#plankapy.v2.utils.board_to_table(board)","title":"<code>board</code>","text":""},{"location":"v2/utils/#plankapy.v2.utils.snapshot","title":"snapshot","text":"<pre><code>snapshot(planka: Planka) -&gt; PlankaSnapshot\n</code></pre> <p>Create a dictionary snapshot of a Planka object. (MUST BE ADMIN) All associated schemas are dumped into a single dictionary. </p> Note <p>Since this required traversing all objecs in the system, it can be a very long process.  This is best run at a time when not a lot of users are interacting with the board since  a 5 minute snapshot could end up with sync errors if state changes over that time.</p> RETURNS DESCRIPTION <code>PlankaSnapshot</code> <p>A dictonary with all object schemas. Each top level key is a </p> RAISES DESCRIPTION <code>PermissionError</code> <p>If the logged in user is not an admin</p> Source code in <code>src/plankapy/v2/utils.py</code> <pre><code>def snapshot(planka: Planka) -&gt; PlankaSnapshot:\n    \"\"\"Create a dictionary snapshot of a Planka object. (MUST BE ADMIN)\n    All associated schemas are dumped into a single dictionary. \n\n    Note:\n        Since this required traversing all objecs in the system, it can be a very long process. \n        This is best run at a time when not a lot of users are interacting with the board since \n        a 5 minute snapshot could end up with sync errors if state changes over that time.\n\n    Returns:\n        A dictonary with all object schemas. Each top level key is a \n\n    Raises:\n        PermissionError: If the logged in user is not an admin\n    \"\"\"\n    if not planka.me.role == 'admin':\n        raise PermissionError('Planka Snapshots can only be done by Admin users!')\n    projects = planka.projects\n    boards = [b for p in projects for b in p.boards]\n    cards = [c for b in boards for c in b.cards]\n    lists = [l for b in boards for l in b.lists]\n    card_labels = [cl for b in boards for cl in b.card_labels]\n    card_memberships = [cm for b in boards for cm in b.card_memberships]\n    task_lists = [tl for b in boards for tl in b.task_lists]\n    tasks = [t for b in boards for t in b.tasks]\n    base_custom_field_groups = [bcfg for p in projects for bcfg in p.base_custom_field_groups]\n    custom_field_groups = [cfg for b in boards for cfg in b.custom_field_groups]\n    custom_fields = [cf for b in boards for cf in b.custom_fields]\n    custom_field_values = [cfv for b in boards for cfv in b.custom_field_values]\n    comments = [cm for c in cards for cm in c.comments]\n    webhooks = planka.webhooks\n    users = planka.users\n    board_memberships = [bm for b in boards for bm in b.board_memberships]\n    project_managers = [pm for p in projects for pm in p.project_managers]\n    labels = [l for b in boards for l in b.labels]\n    notification_services = [ns for p in projects for ns in p.notification_services]\n    actions = [a for c in cards for a in c.actions]\n    config = planka.config\n\n    snap: PlankaSnapshot = {\n        'projects': _get_schema(projects),\n        'boards': _get_schema(boards),\n        'lists': _get_schema(lists),\n        'cards': _get_schema(cards),\n        'card_labels': _get_schema(card_labels),\n        'card_memberships': _get_schema(card_memberships),\n        'task_lists': _get_schema(task_lists),\n        'tasks': _get_schema(tasks),\n        'base_custom_field_groups': _get_schema(base_custom_field_groups),\n        'custom_field_groups': _get_schema(custom_field_groups),\n        'custom_fields': _get_schema(custom_fields),\n        'custom_field_values': _get_schema(custom_field_values),\n        'comments': _get_schema(comments),\n        'webhooks': _get_schema(webhooks),\n        'users': _get_schema(users),\n        'board_memberships': _get_schema(board_memberships),\n        'project_managers': _get_schema(project_managers),\n        'labels': _get_schema(labels),\n        'notification_services': _get_schema(notification_services),\n        'actions': _get_schema(actions),\n        'config': config.schema\n    }\n    return snap\n</code></pre>"},{"location":"v2/api/errors/","title":"Errors","text":"CLASS DESCRIPTION <code>Conflict</code> <code>Forbidden</code> <code>NotFound</code> <code>PlankaError</code> <code>Unauthorized</code> <code>UnprocessableEntity</code> <code>ValidationError</code> ATTRIBUTE DESCRIPTION <code>ERRORS</code> <p> TYPE: <code>dict[str, type[PlankaError]]</code> </p>"},{"location":"v2/api/errors/#plankapy.v2.api.errors.ERRORS","title":"ERRORS  <code>module-attribute</code>","text":"<pre><code>ERRORS: dict[str, type[PlankaError]] = {'E_CONFLICT': Conflict, 'E_FORBIDDEN': Forbidden, 'E_NOT_FOUND': NotFound, 'E_UNAUTHORIZED': Unauthorized, 'E_UNPROCESSABLE_ENTITY': UnprocessableEntity, 'E_MISSING_OR_INVALID_PARAMS': ValidationError}\n</code></pre>"},{"location":"v2/api/errors/#plankapy.v2.api.errors.Conflict","title":"Conflict","text":"<pre><code>Conflict(parent: HTTPStatusError, *args: Any, **kwargs: Any)\n</code></pre> <p>               Bases: <code>PlankaError</code></p> Raised by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <ul> <li> <code></code>\u00a0createBoardMembership </li> <li> <code></code>\u00a0createBoardNotificationService </li> <li> <code></code>\u00a0createCardLabel </li> <li> <code></code>\u00a0createCardMembership </li> <li> <code></code>\u00a0createProjectManager </li> <li> <code></code>\u00a0createUser </li> <li> <code></code>\u00a0createUserNotificationService </li> <li> <code></code>\u00a0createWebhook </li> <li> <code></code>\u00a0updateProject </li> <li> <code></code>\u00a0updateUser </li> <li> <code></code>\u00a0updateUserEmail </li> <li> <code></code>\u00a0updateUserUsername </li> </ul> </li> </ul> Used by: <ul> <li> Plankapy v2 api Errors <code></code>\u00a0ERRORS </li> </ul> Source code in <code>src/plankapy/v2/api/errors.py</code> <pre><code>def __init__(self, parent: HTTPStatusError, *args: Any, **kwargs: Any) -&gt; None:\n    response_json: dict[str, str] = parent.response.json()\n    message = response_json.get('message', 'NO_MESSAGE')\n    super().__init__(message, request=parent.request, response=parent.response)\n    for problem in response_json.get('problems', []):\n        self.add_note(problem)\n</code></pre>"},{"location":"v2/api/errors/#plankapy.v2.api.errors.Forbidden","title":"Forbidden","text":"<pre><code>Forbidden(parent: HTTPStatusError, *args: Any, **kwargs: Any)\n</code></pre> <p>               Bases: <code>PlankaError</code></p> Raised by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <ul> <li> <code></code>\u00a0clearList </li> <li> <code></code>\u00a0createAttachment </li> <li> <code></code>\u00a0createBackgroundImage </li> <li> <code></code>\u00a0createBaseCustomFieldGroup </li> <li> <code></code>\u00a0createBoardCustomFieldGroup </li> <li> <code></code>\u00a0createBoardMembership </li> <li> <code></code>\u00a0createCard </li> <li> <code></code>\u00a0createCardCustomFieldGroup </li> <li> <code></code>\u00a0createCardLabel </li> <li> <code></code>\u00a0createCardMembership </li> <li> <code></code>\u00a0createComment </li> <li> <code></code>\u00a0createCustomFieldInGroup </li> <li> <code></code>\u00a0createLabel </li> <li> <code></code>\u00a0createList </li> <li> <code></code>\u00a0createProjectManager </li> <li> <code></code>\u00a0createTask </li> <li> <code></code>\u00a0createTaskList </li> <li> <code></code>\u00a0createUser </li> <li> <code></code>\u00a0deleteAttachment </li> <li> <code></code>\u00a0deleteBackgroundImage </li> <li> <code></code>\u00a0deleteBaseCustomFieldGroup </li> <li> <code></code>\u00a0deleteCard </li> <li> <code></code>\u00a0deleteCardLabel </li> <li> <code></code>\u00a0deleteCardMembership </li> <li> <code></code>\u00a0deleteComment </li> <li> <code></code>\u00a0deleteCustomField </li> <li> <code></code>\u00a0deleteCustomFieldGroup </li> <li> <code></code>\u00a0deleteCustomFieldValue </li> <li> <code></code>\u00a0deleteLabel </li> <li> <code></code>\u00a0deleteList </li> <li> <code></code>\u00a0deleteProjectManager </li> <li> <code></code>\u00a0deleteTask </li> <li> <code></code>\u00a0deleteTaskList </li> <li> <code></code>\u00a0deleteUser </li> <li> <code></code>\u00a0duplicateCard </li> <li> <code></code>\u00a0getUsers </li> <li> <code></code>\u00a0moveListCards </li> <li> <code></code>\u00a0sortList </li> <li> <code></code>\u00a0updateAttachment </li> <li> <code></code>\u00a0updateBaseCustomFieldGroup </li> <li> <code></code>\u00a0updateCard </li> <li> <code></code>\u00a0updateComments </li> <li> <code></code>\u00a0updateCustomField </li> <li> <code></code>\u00a0updateCustomFieldGroup </li> <li> <code></code>\u00a0updateCustomFieldValue </li> <li> <code></code>\u00a0updateLabel </li> <li> <code></code>\u00a0updateList </li> <li> <code></code>\u00a0updateProject </li> <li> <code></code>\u00a0updateTask </li> <li> <code></code>\u00a0updateTaskList </li> <li> <code></code>\u00a0updateUser </li> <li> <code></code>\u00a0updateUserEmail </li> <li> <code></code>\u00a0updateUserPassword </li> <li> <code></code>\u00a0updateUserUsername </li> </ul> </li> </ul> Used by: <ul> <li> Plankapy v2 api Errors <code></code>\u00a0ERRORS </li> </ul> Source code in <code>src/plankapy/v2/api/errors.py</code> <pre><code>def __init__(self, parent: HTTPStatusError, *args: Any, **kwargs: Any) -&gt; None:\n    response_json: dict[str, str] = parent.response.json()\n    message = response_json.get('message', 'NO_MESSAGE')\n    super().__init__(message, request=parent.request, response=parent.response)\n    for problem in response_json.get('problems', []):\n        self.add_note(problem)\n</code></pre>"},{"location":"v2/api/errors/#plankapy.v2.api.errors.NotFound","title":"NotFound","text":"<pre><code>NotFound(parent: HTTPStatusError, *args: Any, **kwargs: Any)\n</code></pre> <p>               Bases: <code>PlankaError</code></p> Raised by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <ul> <li> <code></code>\u00a0clearList </li> <li> <code></code>\u00a0createAttachment </li> <li> <code></code>\u00a0createBackgroundImage </li> <li> <code></code>\u00a0createBaseCustomFieldGroup </li> <li> <code></code>\u00a0createBoard </li> <li> <code></code>\u00a0createBoardCustomFieldGroup </li> <li> <code></code>\u00a0createBoardMembership </li> <li> <code></code>\u00a0createBoardNotificationService </li> <li> <code></code>\u00a0createCard </li> <li> <code></code>\u00a0createCardCustomFieldGroup </li> <li> <code></code>\u00a0createCardLabel </li> <li> <code></code>\u00a0createCardMembership </li> <li> <code></code>\u00a0createComment </li> <li> <code></code>\u00a0createCustomFieldInBaseGroup </li> <li> <code></code>\u00a0createCustomFieldInGroup </li> <li> <code></code>\u00a0createLabel </li> <li> <code></code>\u00a0createList </li> <li> <code></code>\u00a0createProjectManager </li> <li> <code></code>\u00a0createTask </li> <li> <code></code>\u00a0createTaskList </li> <li> <code></code>\u00a0createUserNotificationService </li> <li> <code></code>\u00a0deleteAttachment </li> <li> <code></code>\u00a0deleteBackgroundImage </li> <li> <code></code>\u00a0deleteBaseCustomFieldGroup </li> <li> <code></code>\u00a0deleteBoard </li> <li> <code></code>\u00a0deleteBoardMembership </li> <li> <code></code>\u00a0deleteCard </li> <li> <code></code>\u00a0deleteCardLabel </li> <li> <code></code>\u00a0deleteCardMembership </li> <li> <code></code>\u00a0deleteComment </li> <li> <code></code>\u00a0deleteCustomField </li> <li> <code></code>\u00a0deleteCustomFieldGroup </li> <li> <code></code>\u00a0deleteCustomFieldValue </li> <li> <code></code>\u00a0deleteLabel </li> <li> <code></code>\u00a0deleteList </li> <li> <code></code>\u00a0deleteNotificationService </li> <li> <code></code>\u00a0deleteProject </li> <li> <code></code>\u00a0deleteProjectManager </li> <li> <code></code>\u00a0deleteTask </li> <li> <code></code>\u00a0deleteTaskList </li> <li> <code></code>\u00a0deleteUser </li> <li> <code></code>\u00a0deleteWebhook </li> <li> <code></code>\u00a0duplicateCard </li> <li> <code></code>\u00a0getBoard </li> <li> <code></code>\u00a0getBoardActions </li> <li> <code></code>\u00a0getCard </li> <li> <code></code>\u00a0getCardActions </li> <li> <code></code>\u00a0getCards </li> <li> <code></code>\u00a0getComments </li> <li> <code></code>\u00a0getCustomFieldGroup </li> <li> <code></code>\u00a0getList </li> <li> <code></code>\u00a0getNotification </li> <li> <code></code>\u00a0getProject </li> <li> <code></code>\u00a0getTaskList </li> <li> <code></code>\u00a0getTerms </li> <li> <code></code>\u00a0getUser </li> <li> <code></code>\u00a0moveListCards </li> <li> <code></code>\u00a0readCardNotifications </li> <li> <code></code>\u00a0revokePendingToken </li> <li> <code></code>\u00a0sortList </li> <li> <code></code>\u00a0testNotificationService </li> <li> <code></code>\u00a0updateAttachment </li> <li> <code></code>\u00a0updateBaseCustomFieldGroup </li> <li> <code></code>\u00a0updateBoard </li> <li> <code></code>\u00a0updateBoardMembership </li> <li> <code></code>\u00a0updateCard </li> <li> <code></code>\u00a0updateComments </li> <li> <code></code>\u00a0updateCustomField </li> <li> <code></code>\u00a0updateCustomFieldGroup </li> <li> <code></code>\u00a0updateCustomFieldValue </li> <li> <code></code>\u00a0updateLabel </li> <li> <code></code>\u00a0updateList </li> <li> <code></code>\u00a0updateNotification </li> <li> <code></code>\u00a0updateNotificationService </li> <li> <code></code>\u00a0updateProject </li> <li> <code></code>\u00a0updateTask </li> <li> <code></code>\u00a0updateTaskList </li> <li> <code></code>\u00a0updateUser </li> <li> <code></code>\u00a0updateUserAvatar </li> <li> <code></code>\u00a0updateUserEmail </li> <li> <code></code>\u00a0updateUserPassword </li> <li> <code></code>\u00a0updateUserUsername </li> <li> <code></code>\u00a0updateWebhook </li> </ul> </li> </ul> Used by: <ul> <li> Plankapy v2 api Errors <code></code>\u00a0ERRORS </li> </ul> Source code in <code>src/plankapy/v2/api/errors.py</code> <pre><code>def __init__(self, parent: HTTPStatusError, *args: Any, **kwargs: Any) -&gt; None:\n    response_json: dict[str, str] = parent.response.json()\n    message = response_json.get('message', 'NO_MESSAGE')\n    super().__init__(message, request=parent.request, response=parent.response)\n    for problem in response_json.get('problems', []):\n        self.add_note(problem)\n</code></pre>"},{"location":"v2/api/errors/#plankapy.v2.api.errors.PlankaError","title":"PlankaError","text":"<pre><code>PlankaError(parent: HTTPStatusError, *args: Any, **kwargs: Any)\n</code></pre> <p>               Bases: <code>HTTPStatusError</code></p> Returned by: <ul> <li> Plankapy v2 api Errors <code></code>\u00a0ERRORS </li> </ul> Subclassed by: <ul> <li> Plankapy v2 api Errors <ul> <li> <code></code>\u00a0Conflict </li> <li> <code></code>\u00a0Forbidden </li> <li> <code></code>\u00a0NotFound </li> <li> <code></code>\u00a0Unauthorized </li> <li> <code></code>\u00a0UnprocessableEntity </li> <li> <code></code>\u00a0ValidationError </li> </ul> </li> </ul> Source code in <code>src/plankapy/v2/api/errors.py</code> <pre><code>def __init__(self, parent: HTTPStatusError, *args: Any, **kwargs: Any) -&gt; None:\n    response_json: dict[str, str] = parent.response.json()\n    message = response_json.get('message', 'NO_MESSAGE')\n    super().__init__(message, request=parent.request, response=parent.response)\n    for problem in response_json.get('problems', []):\n        self.add_note(problem)\n</code></pre>"},{"location":"v2/api/errors/#plankapy.v2.api.errors.Unauthorized","title":"Unauthorized","text":"<pre><code>Unauthorized(parent: HTTPStatusError, *args: Any, **kwargs: Any)\n</code></pre> <p>               Bases: <code>PlankaError</code></p> Raised by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <ul> <li> <code></code>\u00a0clearList </li> <li> <code></code>\u00a0createAttachment </li> <li> <code></code>\u00a0createBackgroundImage </li> <li> <code></code>\u00a0createBaseCustomFieldGroup </li> <li> <code></code>\u00a0createBoard </li> <li> <code></code>\u00a0createBoardCustomFieldGroup </li> <li> <code></code>\u00a0createBoardMembership </li> <li> <code></code>\u00a0createBoardNotificationService </li> <li> <code></code>\u00a0createCard </li> <li> <code></code>\u00a0createCardCustomFieldGroup </li> <li> <code></code>\u00a0createCardLabel </li> <li> <code></code>\u00a0createCardMembership </li> <li> <code></code>\u00a0createComment </li> <li> <code></code>\u00a0createCustomFieldInBaseGroup </li> <li> <code></code>\u00a0createCustomFieldInGroup </li> <li> <code></code>\u00a0createLabel </li> <li> <code></code>\u00a0createList </li> <li> <code></code>\u00a0createProject </li> <li> <code></code>\u00a0createProjectManager </li> <li> <code></code>\u00a0createTask </li> <li> <code></code>\u00a0createTaskList </li> <li> <code></code>\u00a0createUser </li> <li> <code></code>\u00a0createUserNotificationService </li> <li> <code></code>\u00a0createWebhook </li> <li> <code></code>\u00a0deleteAccessToken </li> <li> <code></code>\u00a0deleteAttachment </li> <li> <code></code>\u00a0deleteBackgroundImage </li> <li> <code></code>\u00a0deleteBaseCustomFieldGroup </li> <li> <code></code>\u00a0deleteBoard </li> <li> <code></code>\u00a0deleteBoardMembership </li> <li> <code></code>\u00a0deleteCard </li> <li> <code></code>\u00a0deleteCardLabel </li> <li> <code></code>\u00a0deleteCardMembership </li> <li> <code></code>\u00a0deleteComment </li> <li> <code></code>\u00a0deleteCustomField </li> <li> <code></code>\u00a0deleteCustomFieldGroup </li> <li> <code></code>\u00a0deleteCustomFieldValue </li> <li> <code></code>\u00a0deleteLabel </li> <li> <code></code>\u00a0deleteList </li> <li> <code></code>\u00a0deleteNotificationService </li> <li> <code></code>\u00a0deleteProject </li> <li> <code></code>\u00a0deleteProjectManager </li> <li> <code></code>\u00a0deleteTask </li> <li> <code></code>\u00a0deleteTaskList </li> <li> <code></code>\u00a0deleteUser </li> <li> <code></code>\u00a0deleteWebhook </li> <li> <code></code>\u00a0duplicateCard </li> <li> <code></code>\u00a0getBoard </li> <li> <code></code>\u00a0getBoardActions </li> <li> <code></code>\u00a0getCard </li> <li> <code></code>\u00a0getCardActions </li> <li> <code></code>\u00a0getCards </li> <li> <code></code>\u00a0getComments </li> <li> <code></code>\u00a0getCustomFieldGroup </li> <li> <code></code>\u00a0getList </li> <li> <code></code>\u00a0getNotification </li> <li> <code></code>\u00a0getNotifications </li> <li> <code></code>\u00a0getProject </li> <li> <code></code>\u00a0getProjects </li> <li> <code></code>\u00a0getTaskList </li> <li> <code></code>\u00a0getTerms </li> <li> <code></code>\u00a0getUser </li> <li> <code></code>\u00a0getUsers </li> <li> <code></code>\u00a0getWebhooks </li> <li> <code></code>\u00a0moveListCards </li> <li> <code></code>\u00a0readAllNotifications </li> <li> <code></code>\u00a0readCardNotifications </li> <li> <code></code>\u00a0sortList </li> <li> <code></code>\u00a0testNotificationService </li> <li> <code></code>\u00a0updateAttachment </li> <li> <code></code>\u00a0updateBaseCustomFieldGroup </li> <li> <code></code>\u00a0updateBoard </li> <li> <code></code>\u00a0updateBoardMembership </li> <li> <code></code>\u00a0updateCard </li> <li> <code></code>\u00a0updateComments </li> <li> <code></code>\u00a0updateCustomField </li> <li> <code></code>\u00a0updateCustomFieldGroup </li> <li> <code></code>\u00a0updateCustomFieldValue </li> <li> <code></code>\u00a0updateLabel </li> <li> <code></code>\u00a0updateList </li> <li> <code></code>\u00a0updateNotification </li> <li> <code></code>\u00a0updateNotificationService </li> <li> <code></code>\u00a0updateProject </li> <li> <code></code>\u00a0updateTask </li> <li> <code></code>\u00a0updateTaskList </li> <li> <code></code>\u00a0updateUser </li> <li> <code></code>\u00a0updateUserAvatar </li> <li> <code></code>\u00a0updateUserEmail </li> <li> <code></code>\u00a0updateUserPassword </li> <li> <code></code>\u00a0updateUserUsername </li> <li> <code></code>\u00a0updateWebhook </li> </ul> </li> </ul> Used by: <ul> <li> Plankapy v2 api Errors <code></code>\u00a0ERRORS </li> </ul> Source code in <code>src/plankapy/v2/api/errors.py</code> <pre><code>def __init__(self, parent: HTTPStatusError, *args: Any, **kwargs: Any) -&gt; None:\n    response_json: dict[str, str] = parent.response.json()\n    message = response_json.get('message', 'NO_MESSAGE')\n    super().__init__(message, request=parent.request, response=parent.response)\n    for problem in response_json.get('problems', []):\n        self.add_note(problem)\n</code></pre>"},{"location":"v2/api/errors/#plankapy.v2.api.errors.UnprocessableEntity","title":"UnprocessableEntity","text":"<pre><code>UnprocessableEntity(parent: HTTPStatusError, *args: Any, **kwargs: Any)\n</code></pre> <p>               Bases: <code>PlankaError</code></p> Raised by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <ul> <li> <code></code>\u00a0createBoardCustomFieldGroup </li> <li> <code></code>\u00a0createCard </li> <li> <code></code>\u00a0createCardCustomFieldGroup </li> <li> <code></code>\u00a0createProjectManager </li> <li> <code></code>\u00a0createTask </li> <li> <code></code>\u00a0deleteProject </li> <li> <code></code>\u00a0deleteProjectManager </li> <li> <code></code>\u00a0sortList </li> <li> <code></code>\u00a0updateCard </li> <li> <code></code>\u00a0updateCustomFieldGroup </li> <li> <code></code>\u00a0updateProject </li> <li> <code></code>\u00a0updateUserAvatar </li> </ul> </li> </ul> Used by: <ul> <li> Plankapy v2 api Errors <code></code>\u00a0ERRORS </li> </ul> Source code in <code>src/plankapy/v2/api/errors.py</code> <pre><code>def __init__(self, parent: HTTPStatusError, *args: Any, **kwargs: Any) -&gt; None:\n    response_json: dict[str, str] = parent.response.json()\n    message = response_json.get('message', 'NO_MESSAGE')\n    super().__init__(message, request=parent.request, response=parent.response)\n    for problem in response_json.get('problems', []):\n        self.add_note(problem)\n</code></pre>"},{"location":"v2/api/errors/#plankapy.v2.api.errors.ValidationError","title":"ValidationError","text":"<pre><code>ValidationError(parent: HTTPStatusError, *args: Any, **kwargs: Any)\n</code></pre> <p>               Bases: <code>PlankaError</code></p> Raised by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <ul> <li> <code></code>\u00a0acceptTerms </li> <li> <code></code>\u00a0clearList </li> <li> <code></code>\u00a0createAccessToken </li> <li> <code></code>\u00a0createAttachment </li> <li> <code></code>\u00a0createBackgroundImage </li> <li> <code></code>\u00a0createBaseCustomFieldGroup </li> <li> <code></code>\u00a0createBoard </li> <li> <code></code>\u00a0createBoardCustomFieldGroup </li> <li> <code></code>\u00a0createBoardMembership </li> <li> <code></code>\u00a0createBoardNotificationService </li> <li> <code></code>\u00a0createCard </li> <li> <code></code>\u00a0createCardCustomFieldGroup </li> <li> <code></code>\u00a0createCardLabel </li> <li> <code></code>\u00a0createCardMembership </li> <li> <code></code>\u00a0createComment </li> <li> <code></code>\u00a0createCustomFieldInBaseGroup </li> <li> <code></code>\u00a0createCustomFieldInGroup </li> <li> <code></code>\u00a0createLabel </li> <li> <code></code>\u00a0createList </li> <li> <code></code>\u00a0createProject </li> <li> <code></code>\u00a0createProjectManager </li> <li> <code></code>\u00a0createTask </li> <li> <code></code>\u00a0createTaskList </li> <li> <code></code>\u00a0createUser </li> <li> <code></code>\u00a0createUserNotificationService </li> <li> <code></code>\u00a0createWebhook </li> <li> <code></code>\u00a0deleteAttachment </li> <li> <code></code>\u00a0deleteBackgroundImage </li> <li> <code></code>\u00a0deleteBaseCustomFieldGroup </li> <li> <code></code>\u00a0deleteBoard </li> <li> <code></code>\u00a0deleteBoardMembership </li> <li> <code></code>\u00a0deleteCard </li> <li> <code></code>\u00a0deleteCardLabel </li> <li> <code></code>\u00a0deleteCardMembership </li> <li> <code></code>\u00a0deleteComment </li> <li> <code></code>\u00a0deleteCustomField </li> <li> <code></code>\u00a0deleteCustomFieldGroup </li> <li> <code></code>\u00a0deleteCustomFieldValue </li> <li> <code></code>\u00a0deleteLabel </li> <li> <code></code>\u00a0deleteList </li> <li> <code></code>\u00a0deleteNotificationService </li> <li> <code></code>\u00a0deleteProject </li> <li> <code></code>\u00a0deleteProjectManager </li> <li> <code></code>\u00a0deleteTask </li> <li> <code></code>\u00a0deleteTaskList </li> <li> <code></code>\u00a0deleteUser </li> <li> <code></code>\u00a0deleteWebhook </li> <li> <code></code>\u00a0duplicateCard </li> <li> <code></code>\u00a0exchangeForAccessTokenWithOidc </li> <li> <code></code>\u00a0getBoard </li> <li> <code></code>\u00a0getBoardActions </li> <li> <code></code>\u00a0getCard </li> <li> <code></code>\u00a0getCardActions </li> <li> <code></code>\u00a0getCards </li> <li> <code></code>\u00a0getComments </li> <li> <code></code>\u00a0getCustomFieldGroup </li> <li> <code></code>\u00a0getList </li> <li> <code></code>\u00a0getNotification </li> <li> <code></code>\u00a0getNotifications </li> <li> <code></code>\u00a0getProject </li> <li> <code></code>\u00a0getProjects </li> <li> <code></code>\u00a0getTaskList </li> <li> <code></code>\u00a0getTerms </li> <li> <code></code>\u00a0getUser </li> <li> <code></code>\u00a0getUsers </li> <li> <code></code>\u00a0getWebhooks </li> <li> <code></code>\u00a0moveListCards </li> <li> <code></code>\u00a0readAllNotifications </li> <li> <code></code>\u00a0readCardNotifications </li> <li> <code></code>\u00a0revokePendingToken </li> <li> <code></code>\u00a0sortList </li> <li> <code></code>\u00a0testNotificationService </li> <li> <code></code>\u00a0updateAttachment </li> <li> <code></code>\u00a0updateBaseCustomFieldGroup </li> <li> <code></code>\u00a0updateBoard </li> <li> <code></code>\u00a0updateBoardMembership </li> <li> <code></code>\u00a0updateCard </li> <li> <code></code>\u00a0updateComments </li> <li> <code></code>\u00a0updateCustomField </li> <li> <code></code>\u00a0updateCustomFieldGroup </li> <li> <code></code>\u00a0updateCustomFieldValue </li> <li> <code></code>\u00a0updateLabel </li> <li> <code></code>\u00a0updateList </li> <li> <code></code>\u00a0updateNotification </li> <li> <code></code>\u00a0updateNotificationService </li> <li> <code></code>\u00a0updateProject </li> <li> <code></code>\u00a0updateTask </li> <li> <code></code>\u00a0updateTaskList </li> <li> <code></code>\u00a0updateUser </li> <li> <code></code>\u00a0updateUserAvatar </li> <li> <code></code>\u00a0updateUserEmail </li> <li> <code></code>\u00a0updateUserPassword </li> <li> <code></code>\u00a0updateUserUsername </li> <li> <code></code>\u00a0updateWebhook </li> </ul> </li> </ul> Used by: <ul> <li> Plankapy v2 api Errors <code></code>\u00a0ERRORS </li> </ul> Source code in <code>src/plankapy/v2/api/errors.py</code> <pre><code>def __init__(self, parent: HTTPStatusError, *args: Any, **kwargs: Any) -&gt; None:\n    response_json: dict[str, str] = parent.response.json()\n    message = response_json.get('message', 'NO_MESSAGE')\n    super().__init__(message, request=parent.request, response=parent.response)\n    for problem in response_json.get('problems', []):\n        self.add_note(problem)\n</code></pre>"},{"location":"v2/api/paths/","title":"Paths/Endpoints","text":"CLASS DESCRIPTION <code>PlankaEndpoints</code>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints","title":"PlankaEndpoints","text":"<pre><code>PlankaEndpoints(client: Client)\n</code></pre> METHOD DESCRIPTION <code>acceptTerms</code> <p>Accept terms during the authentication flow. Converts the pending token to an access token.</p> <code>clearList</code> <p>Deletes all cards from a list. Only works with trash-type lists. Requires project manager or board editor permissions.</p> <code>createAccessToken</code> <p>Authenticates a user using email/username and password. Returns an access token for API authentication.</p> <code>createAttachment</code> <p>Creates an attachment on a card. Requires board editor permissions.</p> <code>createBackgroundImage</code> <p>Uploads a background image for a project. Requires project manager permissions.</p> <code>createBaseCustomFieldGroup</code> <p>Creates a base custom field group within a project. Requires project manager permissions.</p> <code>createBoard</code> <p>Creates a board within a project. Supports importing from Trello. Requires project manager permissions.</p> <code>createBoardCustomFieldGroup</code> <p>Creates a custom field group within a board. Either <code>baseCustomFieldGroupId</code> or <code>name</code> must be provided. Requires board editor permissions.</p> <code>createBoardMembership</code> <p>Creates a board membership within a board. Requires project manager permissions.</p> <code>createBoardNotificationService</code> <p>Creates a new notification service for a board. Requires project manager permissions.</p> <code>createCard</code> <p>Creates a card within a list. Requires board editor permissions.</p> <code>createCardCustomFieldGroup</code> <p>Creates a custom field group within a card. Either <code>baseCustomFieldGroupId</code> or <code>name</code> must be provided. Requires board editor permissions.</p> <code>createCardLabel</code> <p>Adds a label to a card. Requires board editor permissions.</p> <code>createCardMembership</code> <p>Adds a user to a card. Requires board editor permissions.</p> <code>createComment</code> <p>Creates a new comment on a card. Requires board editor permissions or comment permissions.</p> <code>createCustomFieldInBaseGroup</code> <p>Creates a custom field within a base custom field group. Requires project manager permissions.</p> <code>createCustomFieldInGroup</code> <p>Creates a custom field within a custom field group. Requires board editor permissions.</p> <code>createLabel</code> <p>Creates a label within a board. Requires board editor permissions.</p> <code>createList</code> <p>Creates a list within a board. Requires board editor permissions.</p> <code>createProject</code> <p>Creates a project. The current user automatically becomes a project manager.</p> <code>createProjectManager</code> <p>Creates a project manager within a project. Requires admin privileges for shared projects or existing project manager permissions. The user must be an admin or project owner.</p> <code>createTask</code> <p>Creates a task within a task list. Either <code>linkedCardId</code> or <code>name</code> must be provided. Requires board editor permissions.</p> <code>createTaskList</code> <p>Creates a task list within a card. Requires board editor permissions.</p> <code>createUser</code> <p>Creates a user account. Requires admin privileges.</p> <code>createUserNotificationService</code> <p>Creates a new notification service for a user. Users can only create services for themselves.</p> <code>createWebhook</code> <p>Creates a webhook. Requires admin privileges.</p> <code>deleteAccessToken</code> <p>Logs out the current user by deleting the session and access token. Clears HTTP-only cookies if present.</p> <code>deleteAttachment</code> <p>Deletes an attachment. Requires board editor permissions.</p> <code>deleteBackgroundImage</code> <p>Deletes a background image. Requires project manager permissions.</p> <code>deleteBaseCustomFieldGroup</code> <p>Deletes a base custom field group. Requires project manager permissions.</p> <code>deleteBoard</code> <p>Deletes a board and all its contents (lists, cards, etc.). Requires project manager permissions.</p> <code>deleteBoardMembership</code> <p>Deletes a board membership. Users can remove their own membership, project managers can remove any membership.</p> <code>deleteCard</code> <p>Deletes a card and all its contents (tasks, attachments, etc.). Requires board editor permissions.</p> <code>deleteCardLabel</code> <p>Removes a label from a card. Requires board editor permissions.</p> <code>deleteCardMembership</code> <p>Removes a user from a card. Requires board editor permissions.</p> <code>deleteComment</code> <p>Deletes a comment. Can be deleted by the comment author (with comment permissions) or project manager.</p> <code>deleteCustomField</code> <p>Deletes a custom field. Can delete the in base custom field group (requires project manager permissions) or the custom field group (requires board editor permissions).</p> <code>deleteCustomFieldGroup</code> <p>Deletes a custom field group. Requires board editor permissions.</p> <code>deleteCustomFieldValue</code> <p>Deletes a custom field value for a specific card. Requires board editor permissions.</p> <code>deleteLabel</code> <p>Deletes a label. Requires board editor permissions.</p> <code>deleteList</code> <p>Deletes a list and moves its cards to a trash list. Can only delete finite lists. Requires board editor permissions.</p> <code>deleteNotificationService</code> <p>Deletes a notification service. Users can delete their own services, project managers can delete board services.</p> <code>deleteProject</code> <p>Deletes a project. The project must not have any boards. Requires project manager permissions.</p> <code>deleteProjectManager</code> <p>Deletes a project manager. Requires admin privileges for shared projects or existing project manager permissions. Cannot remove the last project manager.</p> <code>deleteTask</code> <p>Deletes a task. Requires board editor permissions.</p> <code>deleteTaskList</code> <p>Deletes a task list and all its tasks. Requires board editor permissions.</p> <code>deleteUser</code> <p>Deletes a user account. Cannot delete the default admin user. Requires admin privileges.</p> <code>deleteWebhook</code> <p>Deletes a webhook. Requires admin privileges.</p> <code>duplicateCard</code> <p>Creates a duplicate of a card with all its contents (tasks, attachments, etc.). Requires board editor permissions.</p> <code>exchangeForAccessTokenWithOidc</code> <p>Exchanges an OIDC authorization code for an access token. Creates a user if they do not exist.</p> <code>getBoard</code> <p>Retrieves comprehensive board information, including lists, cards, and other related data.</p> <code>getBoardActions</code> <p>Retrieves a list of actions (activity history) for a specific board, with pagination support.</p> <code>getCard</code> <p>Retrieves comprehensive card information, including tasks, attachments, and other related data.</p> <code>getCardActions</code> <p>Retrieves a list of actions (activity history) for a specific card, with pagination support.</p> <code>getCards</code> <p>Retrieves cards from an endless list with filtering, search, and pagination support.</p> <code>getComments</code> <p>Retrieves comments for a card with pagination support. Requires access to the card.</p> <code>getConfig</code> <p>Retrieves the application configuration.</p> <code>getCustomFieldGroup</code> <p>Retrieves comprehensive custom field group information, including fields and values. Requires access to the board/card.</p> <code>getList</code> <p>Retrieves comprehensive list information, including cards, attachments, and other related data. Requires access to the board.</p> <code>getNotification</code> <p>Retrieves notification, including creator users. Users can only access their own notifications.</p> <code>getNotifications</code> <p>Retrieves all unread notifications for the current user, including creator users.</p> <code>getProject</code> <p>Retrieves comprehensive project information, including boards, board memberships, and other related data.</p> <code>getProjects</code> <p>Retrieves all projects the current user has access to, including managed projects, membership projects, and shared projects (for admins).</p> <code>getTaskList</code> <p>Retrieves task list information, including tasks. Requires access to the card.</p> <code>getTerms</code> <p>Retrieves terms and conditions in the specified language.</p> <code>getUser</code> <p>Retrieves a user. Use 'me' as ID to get the current user.</p> <code>getUsers</code> <p>Retrieves a list of all users. Requires admin or project owner privileges.</p> <code>getWebhooks</code> <p>Retrieves a list of all configured webhooks. Requires admin privileges.</p> <code>moveListCards</code> <p>Moves all cards from a closed list to an archive list. Requires board editor permissions.</p> <code>readAllNotifications</code> <p>Marks all notifications for the current user as read.</p> <code>readCardNotifications</code> <p>Marks all notifications for a specific card as read for the current user. Requires access to the card.</p> <code>revokePendingToken</code> <p>Revokes a pending authentication token and cancels the authentication flow.</p> <code>sortList</code> <p>Sorts all cards within a list. Requires board editor permissions.</p> <code>testNotificationService</code> <p>Sends a test notification to verify the notification service is working. Users can test their own services, project managers can test board services.</p> <code>updateAttachment</code> <p>Updates an attachment. Requires board editor permissions.</p> <code>updateBaseCustomFieldGroup</code> <p>Updates a base custom field group. Requires project manager permissions.</p> <code>updateBoard</code> <p>Updates a board. Project managers can update all fields, board members can only subscribe/unsubscribe.</p> <code>updateBoardMembership</code> <p>Updates a board membership. Requires project manager permissions.</p> <code>updateCard</code> <p>Updates a card. Board editors can update all fields, viewers can only subscribe/unsubscribe.</p> <code>updateComments</code> <p>Updates a comment. Only the author of the comment can update it.</p> <code>updateCustomField</code> <p>Updates a custom field. Can update in the base custom field group (requires project manager permissions) or the custom field group (requires board editor permissions).</p> <code>updateCustomFieldGroup</code> <p>Updates a custom field group. Supports both board-wide and card-specific groups. Requires board editor permissions.</p> <code>updateCustomFieldValue</code> <p>Creates or updates a custom field value for a card. Requires board editor permissions.</p> <code>updateLabel</code> <p>Updates a label. Requires board editor permissions.</p> <code>updateList</code> <p>Updates a list. Can move lists between boards. Requires board editor permissions.</p> <code>updateNotification</code> <p>Updates a notification. Users can only update their own notifications.</p> <code>updateNotificationService</code> <p>Updates a notification service. Users can update their own services, project managers can update board services.</p> <code>updateProject</code> <p>Updates a project. Accessible fields depend on user permissions.</p> <code>updateTask</code> <p>Updates a task. Linked card tasks have limited update options. Requires board editor permissions.</p> <code>updateTaskList</code> <p>Updates a task list. Requires board editor permissions.</p> <code>updateUser</code> <p>Updates a user. Users can update their own profile, admins can update any user.</p> <code>updateUserAvatar</code> <p>Updates a user's avatar image. Users can update their own avatar, admins can update any user's avatar.</p> <code>updateUserEmail</code> <p>Updates a user's email address. Users must provide current password when updating their own email. Admins can update any user's email without a password.</p> <code>updateUserPassword</code> <p>Updates a user's password. Users must provide a current password when updating their own password. Admins can update any user's password without the current password. Returns a new access token when updating own password.</p> <code>updateUserUsername</code> <p>Updates a user's username. Users must provide a current password when updating their own username (unless they are SSO users with <code>oidcIgnoreUsername</code> enabled). Admins can update any user's username without the current password.</p> <code>updateWebhook</code> <p>Updates a webhook. Requires admin privileges.</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def __init__(self, client: Client) -&gt; None:\n    self.client = client\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.acceptTerms","title":"acceptTerms","text":"<pre><code>acceptTerms(**kwargs: Unpack[Request_acceptTerms]) -&gt; Response_acceptTerms\n</code></pre> <p>Accept terms during the authentication flow. Converts the pending token to an access token.</p> PARAMETER DESCRIPTION <p>Pending token received from the authentication flow</p> <p> TYPE: <code>str</code> </p> <p>Terms signature hash based on user role</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Error</code> <p>401 Invalid pending token</p> <code>Error</code> <p>403 Authentication restriction</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def acceptTerms(self, **kwargs: Unpack[Request_acceptTerms]) -&gt; Response_acceptTerms:\n    \"\"\"Accept terms during the authentication flow. Converts the pending token to an access token.\n\n    Args:\n        pendingToken (str): Pending token received from the authentication flow\n        signature (str): Terms signature hash based on user role\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Error: 401 Invalid pending token\n        Error: 403 Authentication restriction\n    \"\"\"\n    resp = self.client.post(\"api/access-tokens/accept-terms\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.acceptTerms(pendingToken)","title":"<code>pendingToken</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.acceptTerms(signature)","title":"<code>signature</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.clearList","title":"clearList","text":"<pre><code>clearList(id: str) -&gt; Response_clearList\n</code></pre> <p>Deletes all cards from a list. Only works with trash-type lists. Requires project manager or board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the list to clear (must be a trash-type list))</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def clearList(self, id: str) -&gt; Response_clearList:\n    \"\"\"Deletes all cards from a list. Only works with trash-type lists. Requires project manager or board editor permissions.\n\n    Args:\n        id (str): ID of the list to clear (must be a trash-type list))\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.post(f\"api/lists/{id}/clear\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.clearList(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createAccessToken","title":"createAccessToken","text":"<pre><code>createAccessToken(**kwargs: Unpack[Request_createAccessToken]) -&gt; Response_createAccessToken\n</code></pre> <p>Authenticates a user using email/username and password. Returns an access token for API authentication.</p> PARAMETER DESCRIPTION <p>Email address or username of the user</p> <p> TYPE: <code>str</code> </p> <p>Password of the user</p> <p> TYPE: <code>str</code> </p> <p>Whether to include an HTTP-only authentication cookie</p> <p> TYPE: <code>bool</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Error</code> <p>401 Invalid credentials</p> <code>Error</code> <p>403 Authentication restriction</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createAccessToken(self, **kwargs: Unpack[Request_createAccessToken]) -&gt; Response_createAccessToken:\n    \"\"\"Authenticates a user using email/username and password. Returns an access token for API authentication.\n\n    Args:\n        emailOrUsername (str): Email address or username of the user\n        password (str): Password of the user\n        withHttpOnlyToken (bool): Whether to include an HTTP-only authentication cookie\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Error: 401 Invalid credentials\n        Error: 403 Authentication restriction\n    \"\"\"\n    resp = self.client.post(\"api/access-tokens\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createAccessToken(emailOrUsername)","title":"<code>emailOrUsername</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createAccessToken(password)","title":"<code>password</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createAccessToken(withHttpOnlyToken)","title":"<code>withHttpOnlyToken</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createAttachment","title":"createAttachment","text":"<pre><code>createAttachment(cardId: str, mime_type: str | None = None, **kwargs: Unpack[Request_createAttachment]) -&gt; Response_createAttachment\n</code></pre> <p>Creates an attachment on a card. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the card to create the attachment on)</p> <p> TYPE: <code>str</code> </p> <p>Optional mime type for file uploads</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <p>Type of the attachment</p> <p> TYPE: <code>Literal[file, link]</code> </p> <p>File to upload</p> <p> TYPE: <code>bytes</code> </p> <p>URL for the link attachment</p> <p> TYPE: <code>str</code> </p> <p>Name/title of the attachment</p> <p> TYPE: <code>str</code> </p> <p>Request ID for tracking</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404 </p> <code>Error</code> <p>422 Upload or validation error</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createAttachment(self, cardId: str, mime_type: str|None=None, **kwargs: Unpack[Request_createAttachment]) -&gt; Response_createAttachment:\n    \"\"\"Creates an attachment on a card. Requires board editor permissions.\n\n    Args:\n        cardId (str): ID of the card to create the attachment on)\n        mime_type (str | None): Optional mime type for file uploads\n        type (Literal['file', 'link']): Type of the attachment\n        file (bytes): File to upload\n        url (str): URL for the link attachment\n        name (str): Name/title of the attachment\n        requestId (str): Request ID for tracking\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n        Error: 422 Upload or validation error\n    \"\"\"\n    # Handle file attachment\n    if kwargs.get('type') == 'file':\n        file_data = kwargs.pop('file')\n        name = kwargs['name']\n        resp = self.client.post(f\"api/cards/{cardId}/attachments\", \n            data=kwargs, \n            files={'file': (name, file_data, mime_type)}, \n        )\n        raise_planka_err(resp)\n\n    # Handle link attachment \n    else:\n        resp = self.client.post(f\"api/cards/{cardId}/attachments\", json=kwargs)\n        raise_planka_err(resp)\n\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createAttachment(cardId)","title":"<code>cardId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createAttachment(mime_type)","title":"<code>mime_type</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createAttachment(type)","title":"<code>type</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createAttachment(file)","title":"<code>file</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createAttachment(url)","title":"<code>url</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createAttachment(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createAttachment(requestId)","title":"<code>requestId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBackgroundImage","title":"createBackgroundImage","text":"<pre><code>createBackgroundImage(projectId: str, mime_type: str | None = None, **kwargs: Unpack[Request_createBackgroundImage]) -&gt; Response_createBackgroundImage\n</code></pre> <p>Uploads a background image for a project. Requires project manager permissions.</p> PARAMETER DESCRIPTION <p>ID of the project to upload background image for)</p> <p> TYPE: <code>str</code> </p> <p>Optional mime type for the file upload</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <p>Background image file (must be an image format)</p> <p> TYPE: <code>bytes</code> </p> <p>Request ID for tracking</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404 </p> <code>Error</code> <p>422 File upload error</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createBackgroundImage(self, projectId: str, mime_type: str | None=None, **kwargs: Unpack[Request_createBackgroundImage]) -&gt; Response_createBackgroundImage:\n    \"\"\"Uploads a background image for a project. Requires project manager permissions.\n\n    Args:\n        projectId (str): ID of the project to upload background image for)\n        mime_type (str | None): Optional mime type for the file upload\n        file (bytes): Background image file (must be an image format)\n        requestId (str): Request ID for tracking\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n        Error: 422 File upload error\n    \"\"\"\n    resp = self.client.post(f\"api/projects/{projectId}/background-images\", \n        files={'file': ('background', kwargs['file'], mime_type)}, \n    )\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBackgroundImage(projectId)","title":"<code>projectId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBackgroundImage(mime_type)","title":"<code>mime_type</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBackgroundImage(file)","title":"<code>file</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBackgroundImage(requestId)","title":"<code>requestId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBaseCustomFieldGroup","title":"createBaseCustomFieldGroup","text":"<pre><code>createBaseCustomFieldGroup(projectId: str, **kwargs: Unpack[Request_createBaseCustomFieldGroup]) -&gt; Response_createBaseCustomFieldGroup\n</code></pre> <p>Creates a base custom field group within a project. Requires project manager permissions.</p> PARAMETER DESCRIPTION <p>ID of the project to create the base custom field group in)</p> <p> TYPE: <code>str</code> </p> <p>Name/title of the base custom field group</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createBaseCustomFieldGroup(self, projectId: str, **kwargs: Unpack[Request_createBaseCustomFieldGroup]) -&gt; Response_createBaseCustomFieldGroup:\n    \"\"\"Creates a base custom field group within a project. Requires project manager permissions.\n\n    Args:\n        projectId (str): ID of the project to create the base custom field group in)\n        name (str): Name/title of the base custom field group\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.post(f\"api/projects/{projectId}/base-custom-field-groups\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBaseCustomFieldGroup(projectId)","title":"<code>projectId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBaseCustomFieldGroup(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBoard","title":"createBoard","text":"<pre><code>createBoard(projectId: str, **kwargs: Unpack[Request_createBoard]) -&gt; Response_createBoard\n</code></pre> <p>Creates a board within a project. Supports importing from Trello. Requires project manager permissions.</p> PARAMETER DESCRIPTION <p>ID of the project to create the board in)</p> <p> TYPE: <code>str</code> </p> <p>Position of the board within the project</p> <p> TYPE: <code>int</code> </p> <p>Name/title of the board</p> <p> TYPE: <code>str</code> </p> <p>Type of import</p> <p> TYPE: <code>Literal[trello]</code> </p> <p>Import file</p> <p> TYPE: <code>bytes</code> </p> <p>Request ID for tracking</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404 </p> <code>Error</code> <p>422 Import file upload error</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createBoard(self, projectId: str, **kwargs: Unpack[Request_createBoard]) -&gt; Response_createBoard:\n    \"\"\"Creates a board within a project. Supports importing from Trello. Requires project manager permissions.\n\n    Args:\n        projectId (str): ID of the project to create the board in)\n        position (int): Position of the board within the project\n        name (str): Name/title of the board\n        importType (Literal['trello']): Type of import\n        importFile (bytes): Import file\n        requestId (str): Request ID for tracking\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n        Error: 422 Import file upload error\n    \"\"\"\n    if imp_file := kwargs.pop('importFile', None):\n        resp = self.client.post(\n            f\"api/projects/{projectId}/boards\", \n            files={'file': (f'import', imp_file, None)}, \n            data=kwargs)\n    else:\n        resp = self.client.post(f\"api/projects/{projectId}/boards\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBoard(projectId)","title":"<code>projectId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBoard(position)","title":"<code>position</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBoard(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBoard(importType)","title":"<code>importType</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBoard(importFile)","title":"<code>importFile</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBoard(requestId)","title":"<code>requestId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBoardCustomFieldGroup","title":"createBoardCustomFieldGroup","text":"<pre><code>createBoardCustomFieldGroup(boardId: str, **kwargs: Unpack[Request_createBoardCustomFieldGroup]) -&gt; Response_createBoardCustomFieldGroup\n</code></pre> <p>Creates a custom field group within a board. Either <code>baseCustomFieldGroupId</code> or <code>name</code> must be provided. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the board to create the custom field group in)</p> <p> TYPE: <code>str</code> </p> <p>ID of the base custom field group used as a template</p> <p> TYPE: <code>str</code> </p> <p>Position of the custom field group within the board</p> <p> TYPE: <code>int</code> </p> <p>Name/title of the custom field group (required if <code>baseCustomFieldGroupId</code> is not provided)</p> <p> TYPE: <code>str | None</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404 </p> <code>UnprocessableEntity</code> <p>422</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createBoardCustomFieldGroup(self, boardId: str, **kwargs: Unpack[Request_createBoardCustomFieldGroup]) -&gt; Response_createBoardCustomFieldGroup:\n    \"\"\"Creates a custom field group within a board. Either `baseCustomFieldGroupId` or `name` must be provided. Requires board editor permissions.\n\n    Args:\n        boardId (str): ID of the board to create the custom field group in)\n        baseCustomFieldGroupId (str): ID of the base custom field group used as a template\n        position (int): Position of the custom field group within the board\n        name (str | None): Name/title of the custom field group (required if `baseCustomFieldGroupId` is not provided)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n        UnprocessableEntity: 422 \n    \"\"\"\n    resp = self.client.post(f\"api/boards/{boardId}/custom-field-groups\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBoardCustomFieldGroup(boardId)","title":"<code>boardId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBoardCustomFieldGroup(baseCustomFieldGroupId)","title":"<code>baseCustomFieldGroupId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBoardCustomFieldGroup(position)","title":"<code>position</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBoardCustomFieldGroup(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBoardMembership","title":"createBoardMembership","text":"<pre><code>createBoardMembership(boardId: str, **kwargs: Unpack[Request_createBoardMembership]) -&gt; Response_createBoardMembership\n</code></pre> <p>Creates a board membership within a board. Requires project manager permissions.</p> PARAMETER DESCRIPTION <p>ID of the board to create the board membership in)</p> <p> TYPE: <code>str</code> </p> <p>ID of the user who is a member of the board</p> <p> TYPE: <code>str</code> </p> <p>Role of the user in the board</p> <p> TYPE: <code>Literal[editor, viewer]</code> </p> <p>Whether the user can comment on cards (applies only to viewers)</p> <p> TYPE: <code>bool | None</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404 </p> <code>Conflict</code> <p>409</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createBoardMembership(self, boardId: str, **kwargs: Unpack[Request_createBoardMembership]) -&gt; Response_createBoardMembership:\n    \"\"\"Creates a board membership within a board. Requires project manager permissions.\n\n    Args:\n        boardId (str): ID of the board to create the board membership in)\n        userId (str): ID of the user who is a member of the board\n        role (Literal['editor', 'viewer']): Role of the user in the board\n        canComment (bool | None): Whether the user can comment on cards (applies only to viewers)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n        Conflict: 409 \n    \"\"\"\n    resp = self.client.post(f\"api/boards/{boardId}/board-memberships\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBoardMembership(boardId)","title":"<code>boardId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBoardMembership(userId)","title":"<code>userId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBoardMembership(role)","title":"<code>role</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBoardMembership(canComment)","title":"<code>canComment</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBoardNotificationService","title":"createBoardNotificationService","text":"<pre><code>createBoardNotificationService(boardId: str, **kwargs: Unpack[Request_createBoardNotificationService]) -&gt; Response_createBoardNotificationService\n</code></pre> <p>Creates a new notification service for a board. Requires project manager permissions.</p> PARAMETER DESCRIPTION <p>ID of the board to create notification service for)</p> <p> TYPE: <code>str</code> </p> <p>URL endpoint for notifications</p> <p> TYPE: <code>str</code> </p> <p>Format for notification messages</p> <p> TYPE: <code>Literal[text, markdown, html]</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404 </p> <code>Conflict</code> <p>409</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createBoardNotificationService(self, boardId: str, **kwargs: Unpack[Request_createBoardNotificationService]) -&gt; Response_createBoardNotificationService:\n    \"\"\"Creates a new notification service for a board. Requires project manager permissions.\n\n    Args:\n        boardId (str): ID of the board to create notification service for)\n        url (str): URL endpoint for notifications\n        format (Literal['text', 'markdown', 'html']): Format for notification messages\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n        Conflict: 409 \n    \"\"\"\n    resp = self.client.post(f\"api/boards/{boardId}/notification-services\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBoardNotificationService(boardId)","title":"<code>boardId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBoardNotificationService(url)","title":"<code>url</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createBoardNotificationService(format)","title":"<code>format</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCard","title":"createCard","text":"<pre><code>createCard(listId: str, **kwargs: Unpack[Request_createCard]) -&gt; Response_createCard\n</code></pre> <p>Creates a card within a list. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the list to create the card in)</p> <p> TYPE: <code>str</code> </p> <p>Type of the card</p> <p> TYPE: <code>Literal[project, story]</code> </p> <p>Position of the card within the list</p> <p> TYPE: <code>int | None</code> </p> <p>Name/title of the card</p> <p> TYPE: <code>str</code> </p> <p>Detailed description of the card</p> <p> TYPE: <code>str | None</code> </p> <p>Due date for the card</p> <p> TYPE: <code>str</code> </p> <p>Whether the due date is completed</p> <p> TYPE: <code>bool | None</code> </p> <p>Stopwatch data for time tracking</p> <p> TYPE: <code>dict[str, Any] | None</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404 </p> <code>UnprocessableEntity</code> <p>422</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createCard(self, listId: str, **kwargs: Unpack[Request_createCard]) -&gt; Response_createCard:\n    \"\"\"Creates a card within a list. Requires board editor permissions.\n\n    Args:\n        listId (str): ID of the list to create the card in)\n        type (Literal['project', 'story']): Type of the card\n        position (int | None): Position of the card within the list\n        name (str): Name/title of the card\n        description (str | None): Detailed description of the card\n        dueDate (str): Due date for the card\n        isDueCompleted (bool | None): Whether the due date is completed\n        stopwatch (dict[str, Any] | None): Stopwatch data for time tracking\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n        UnprocessableEntity: 422 \n    \"\"\"\n    resp = self.client.post(f\"api/lists/{listId}/cards\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCard(listId)","title":"<code>listId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCard(type)","title":"<code>type</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCard(position)","title":"<code>position</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCard(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCard(description)","title":"<code>description</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCard(dueDate)","title":"<code>dueDate</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCard(isDueCompleted)","title":"<code>isDueCompleted</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCard(stopwatch)","title":"<code>stopwatch</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCardCustomFieldGroup","title":"createCardCustomFieldGroup","text":"<pre><code>createCardCustomFieldGroup(cardId: str, **kwargs: Unpack[Request_createCardCustomFieldGroup]) -&gt; Response_createCardCustomFieldGroup\n</code></pre> <p>Creates a custom field group within a card. Either <code>baseCustomFieldGroupId</code> or <code>name</code> must be provided. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the card to create the custom field group in)</p> <p> TYPE: <code>str</code> </p> <p>ID of the base custom field group used as a template</p> <p> TYPE: <code>str</code> </p> <p>Position of the custom field group within the card</p> <p> TYPE: <code>int</code> </p> <p>Name/title of the custom field group (required if <code>baseCustomFieldGroupId</code> is not provided)</p> <p> TYPE: <code>str | None</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404 </p> <code>UnprocessableEntity</code> <p>422</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createCardCustomFieldGroup(self, cardId: str, **kwargs: Unpack[Request_createCardCustomFieldGroup]) -&gt; Response_createCardCustomFieldGroup:\n    \"\"\"Creates a custom field group within a card. Either `baseCustomFieldGroupId` or `name` must be provided. Requires board editor permissions.\n\n    Args:\n        cardId (str): ID of the card to create the custom field group in)\n        baseCustomFieldGroupId (str): ID of the base custom field group used as a template\n        position (int): Position of the custom field group within the card\n        name (str | None): Name/title of the custom field group (required if `baseCustomFieldGroupId` is not provided)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n        UnprocessableEntity: 422 \n    \"\"\"\n    resp = self.client.post(f\"api/cards/{cardId}/custom-field-groups\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCardCustomFieldGroup(cardId)","title":"<code>cardId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCardCustomFieldGroup(baseCustomFieldGroupId)","title":"<code>baseCustomFieldGroupId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCardCustomFieldGroup(position)","title":"<code>position</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCardCustomFieldGroup(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCardLabel","title":"createCardLabel","text":"<pre><code>createCardLabel(cardId: str, **kwargs: Unpack[Request_createCardLabel]) -&gt; Response_createCardLabel\n</code></pre> <p>Adds a label to a card. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the card to add the label to)</p> <p> TYPE: <code>str</code> </p> <p>ID of the label to add to the card</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404 </p> <code>Conflict</code> <p>409</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createCardLabel(self, cardId: str, **kwargs: Unpack[Request_createCardLabel]) -&gt; Response_createCardLabel:\n    \"\"\"Adds a label to a card. Requires board editor permissions.\n\n    Args:\n        cardId (str): ID of the card to add the label to)\n        labelId (str): ID of the label to add to the card\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n        Conflict: 409 \n    \"\"\"\n    resp = self.client.post(f\"api/cards/{cardId}/card-labels\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCardLabel(cardId)","title":"<code>cardId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCardLabel(labelId)","title":"<code>labelId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCardMembership","title":"createCardMembership","text":"<pre><code>createCardMembership(cardId: str, **kwargs: Unpack[Request_createCardMembership]) -&gt; Response_createCardMembership\n</code></pre> <p>Adds a user to a card. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the card to add the user to)</p> <p> TYPE: <code>str</code> </p> <p>ID of the card to add the user to</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404 </p> <code>Conflict</code> <p>409</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createCardMembership(self, cardId: str, **kwargs: Unpack[Request_createCardMembership]) -&gt; Response_createCardMembership:\n    \"\"\"Adds a user to a card. Requires board editor permissions.\n\n    Args:\n        cardId (str): ID of the card to add the user to)\n        userId (str): ID of the card to add the user to\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n        Conflict: 409 \n    \"\"\"\n    resp = self.client.post(f\"api/cards/{cardId}/card-memberships\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCardMembership(cardId)","title":"<code>cardId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCardMembership(userId)","title":"<code>userId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createComment","title":"createComment","text":"<pre><code>createComment(cardId: str, **kwargs: Unpack[Request_createComment]) -&gt; Response_createComment\n</code></pre> <p>Creates a new comment on a card. Requires board editor permissions or comment permissions.</p> PARAMETER DESCRIPTION <p>ID of the card to create the comment on)</p> <p> TYPE: <code>str</code> </p> <p>Content of the comment</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createComment(self, cardId: str, **kwargs: Unpack[Request_createComment]) -&gt; Response_createComment:\n    \"\"\"Creates a new comment on a card. Requires board editor permissions or comment permissions.\n\n    Args:\n        cardId (str): ID of the card to create the comment on)\n        text (str): Content of the comment\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.post(f\"api/cards/{cardId}/comments\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createComment(cardId)","title":"<code>cardId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createComment(text)","title":"<code>text</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCustomFieldInBaseGroup","title":"createCustomFieldInBaseGroup","text":"<pre><code>createCustomFieldInBaseGroup(baseCustomFieldGroupId: str, **kwargs: Unpack[Request_createCustomFieldInBaseGroup]) -&gt; Response_createCustomFieldInBaseGroup\n</code></pre> <p>Creates a custom field within a base custom field group. Requires project manager permissions.</p> PARAMETER DESCRIPTION <p>ID of the base custom field group to create the custom field in)</p> <p> TYPE: <code>str</code> </p> <p>Position of the custom field within the group</p> <p> TYPE: <code>int</code> </p> <p>Name/title of the custom field</p> <p> TYPE: <code>str</code> </p> <p>Whether to show the field on the front of cards</p> <p> TYPE: <code>bool</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createCustomFieldInBaseGroup(self, baseCustomFieldGroupId: str, **kwargs: Unpack[Request_createCustomFieldInBaseGroup]) -&gt; Response_createCustomFieldInBaseGroup:\n    \"\"\"Creates a custom field within a base custom field group. Requires project manager permissions.\n\n    Args:\n        baseCustomFieldGroupId (str): ID of the base custom field group to create the custom field in)\n        position (int): Position of the custom field within the group\n        name (str): Name/title of the custom field\n        showOnFrontOfCard (bool): Whether to show the field on the front of cards\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.post(f\"api/base-custom-field-groups/{baseCustomFieldGroupId}/custom-fields\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCustomFieldInBaseGroup(baseCustomFieldGroupId)","title":"<code>baseCustomFieldGroupId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCustomFieldInBaseGroup(position)","title":"<code>position</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCustomFieldInBaseGroup(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCustomFieldInBaseGroup(showOnFrontOfCard)","title":"<code>showOnFrontOfCard</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCustomFieldInGroup","title":"createCustomFieldInGroup","text":"<pre><code>createCustomFieldInGroup(customFieldGroupId: str, **kwargs: Unpack[Request_createCustomFieldInGroup]) -&gt; Response_createCustomFieldInGroup\n</code></pre> <p>Creates a custom field within a custom field group. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the custom field group to create the custom field in)</p> <p> TYPE: <code>str</code> </p> <p>Position of the custom field within the group</p> <p> TYPE: <code>int</code> </p> <p>Name/title of the custom field</p> <p> TYPE: <code>str</code> </p> <p>Whether to show the field on the front of cards</p> <p> TYPE: <code>bool</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createCustomFieldInGroup(self, customFieldGroupId: str, **kwargs: Unpack[Request_createCustomFieldInGroup]) -&gt; Response_createCustomFieldInGroup:\n    \"\"\"Creates a custom field within a custom field group. Requires board editor permissions.\n\n    Args:\n        customFieldGroupId (str): ID of the custom field group to create the custom field in)\n        position (int): Position of the custom field within the group\n        name (str): Name/title of the custom field\n        showOnFrontOfCard (bool): Whether to show the field on the front of cards\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.post(f\"api/custom-field-groups/{customFieldGroupId}/custom-fields\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCustomFieldInGroup(customFieldGroupId)","title":"<code>customFieldGroupId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCustomFieldInGroup(position)","title":"<code>position</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCustomFieldInGroup(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createCustomFieldInGroup(showOnFrontOfCard)","title":"<code>showOnFrontOfCard</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createLabel","title":"createLabel","text":"<pre><code>createLabel(boardId: str, **kwargs: Unpack[Request_createLabel]) -&gt; Response_createLabel\n</code></pre> <p>Creates a label within a board. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the board to create the label in)</p> <p> TYPE: <code>str</code> </p> <p>Position of the label within the board</p> <p> TYPE: <code>int</code> </p> <p>Name/title of the label</p> <p> TYPE: <code>str | None</code> </p> <p>Color of the label</p> <p> TYPE: <code>Literal[muddy - grey, autumn - leafs, morning - sky, antique - blue, egg - yellow, desert - sand, dark - granite, fresh - salad, lagoon - blue, midnight - blue, light - orange, pumpkin - orange, light - concrete, sunny - grass, navy - blue, lilac - eyes, apricot - red, orange - peel, silver - glint, bright - moss, deep - ocean, summer - sky, berry - red, light - cocoa, grey - stone, tank - green, coral - green, sugar - plum, pink - tulip, shady - rust, wet - rock, wet - moss, turquoise - sea, lavender - fields, piggy - red, light - mud, gun - metal, modern - green, french - coast, sweet - lilac, red - burgundy, pirate - gold]</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createLabel(self, boardId: str, **kwargs: Unpack[Request_createLabel]) -&gt; Response_createLabel:\n    \"\"\"Creates a label within a board. Requires board editor permissions.\n\n    Args:\n        boardId (str): ID of the board to create the label in)\n        position (int): Position of the label within the board\n        name (str | None): Name/title of the label\n        color (Literal['muddy-grey', 'autumn-leafs', 'morning-sky', 'antique-blue', 'egg-yellow', 'desert-sand', 'dark-granite', 'fresh-salad', 'lagoon-blue', 'midnight-blue', 'light-orange', 'pumpkin-orange', 'light-concrete', 'sunny-grass', 'navy-blue', 'lilac-eyes', 'apricot-red', 'orange-peel', 'silver-glint', 'bright-moss', 'deep-ocean', 'summer-sky', 'berry-red', 'light-cocoa', 'grey-stone', 'tank-green', 'coral-green', 'sugar-plum', 'pink-tulip', 'shady-rust', 'wet-rock', 'wet-moss', 'turquoise-sea', 'lavender-fields', 'piggy-red', 'light-mud', 'gun-metal', 'modern-green', 'french-coast', 'sweet-lilac', 'red-burgundy', 'pirate-gold']): Color of the label\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.post(f\"api/boards/{boardId}/labels\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createLabel(boardId)","title":"<code>boardId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createLabel(position)","title":"<code>position</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createLabel(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createLabel(color)","title":"<code>color</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createList","title":"createList","text":"<pre><code>createList(boardId: str, **kwargs: Unpack[Request_createList]) -&gt; Response_createList\n</code></pre> <p>Creates a list within a board. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the board to create the list in)</p> <p> TYPE: <code>str</code> </p> <p>Type/status of the list</p> <p> TYPE: <code>Literal[active, closed]</code> </p> <p>Position of the list within the board</p> <p> TYPE: <code>int</code> </p> <p>Name/title of the list</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createList(self, boardId: str, **kwargs: Unpack[Request_createList]) -&gt; Response_createList:\n    \"\"\"Creates a list within a board. Requires board editor permissions.\n\n    Args:\n        boardId (str): ID of the board to create the list in)\n        type (Literal['active', 'closed']): Type/status of the list\n        position (int): Position of the list within the board\n        name (str): Name/title of the list\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.post(f\"api/boards/{boardId}/lists\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createList(boardId)","title":"<code>boardId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createList(type)","title":"<code>type</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createList(position)","title":"<code>position</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createList(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createProject","title":"createProject","text":"<pre><code>createProject(**kwargs: Unpack[Request_createProject]) -&gt; Response_createProject\n</code></pre> <p>Creates a project. The current user automatically becomes a project manager.</p> PARAMETER DESCRIPTION <p>Type of the project</p> <p> TYPE: <code>Literal[public, private]</code> </p> <p>Name/title of the project</p> <p> TYPE: <code>str</code> </p> <p>Detailed description of the project</p> <p> TYPE: <code>str | None</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createProject(self, **kwargs: Unpack[Request_createProject]) -&gt; Response_createProject:\n    \"\"\"Creates a project. The current user automatically becomes a project manager.\n\n    Args:\n        type (Literal['public', 'private']): Type of the project\n        name (str): Name/title of the project\n        description (str | None): Detailed description of the project\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n    \"\"\"\n    resp = self.client.post(\"api/projects\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createProject(type)","title":"<code>type</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createProject(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createProject(description)","title":"<code>description</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createProjectManager","title":"createProjectManager","text":"<pre><code>createProjectManager(projectId: str, **kwargs: Unpack[Request_createProjectManager]) -&gt; Response_createProjectManager\n</code></pre> <p>Creates a project manager within a project. Requires admin privileges for shared projects or existing project manager permissions. The user must be an admin or project owner.</p> PARAMETER DESCRIPTION <p>ID of the project to create the project manager in)</p> <p> TYPE: <code>str</code> </p> <p>ID of the user who is assigned as project manager</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404 </p> <code>Conflict</code> <p>409 </p> <code>UnprocessableEntity</code> <p>422</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createProjectManager(self, projectId: str, **kwargs: Unpack[Request_createProjectManager]) -&gt; Response_createProjectManager:\n    \"\"\"Creates a project manager within a project. Requires admin privileges for shared projects or existing project manager permissions. The user must be an admin or project owner.\n\n    Args:\n        projectId (str): ID of the project to create the project manager in)\n        userId (str): ID of the user who is assigned as project manager\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n        Conflict: 409 \n        UnprocessableEntity: 422 \n    \"\"\"\n    resp = self.client.post(f\"api/projects/{projectId}/project-managers\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createProjectManager(projectId)","title":"<code>projectId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createProjectManager(userId)","title":"<code>userId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createTask","title":"createTask","text":"<pre><code>createTask(taskListId: str, **kwargs: Unpack[Request_createTask]) -&gt; Response_createTask\n</code></pre> <p>Creates a task within a task list. Either <code>linkedCardId</code> or <code>name</code> must be provided. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the task list to create task in)</p> <p> TYPE: <code>str</code> </p> <p>ID of the card linked to the task</p> <p> TYPE: <code>str</code> </p> <p>Position of the task within the task list</p> <p> TYPE: <code>int</code> </p> <p>Name/title of the task (required if <code>linkedCardId</code> is not provided)</p> <p> TYPE: <code>str | None</code> </p> <p>Whether the task is completed</p> <p> TYPE: <code>bool</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404 </p> <code>UnprocessableEntity</code> <p>422</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createTask(self, taskListId: str, **kwargs: Unpack[Request_createTask]) -&gt; Response_createTask:\n    \"\"\"Creates a task within a task list. Either `linkedCardId` or `name` must be provided. Requires board editor permissions.\n\n    Args:\n        taskListId (str): ID of the task list to create task in)\n        linkedCardId (str): ID of the card linked to the task\n        position (int): Position of the task within the task list\n        name (str | None): Name/title of the task (required if `linkedCardId` is not provided)\n        isCompleted (bool): Whether the task is completed\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n        UnprocessableEntity: 422 \n    \"\"\"\n    resp = self.client.post(f\"api/task-lists/{taskListId}/tasks\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createTask(taskListId)","title":"<code>taskListId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createTask(linkedCardId)","title":"<code>linkedCardId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createTask(position)","title":"<code>position</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createTask(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createTask(isCompleted)","title":"<code>isCompleted</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createTaskList","title":"createTaskList","text":"<pre><code>createTaskList(cardId: str, **kwargs: Unpack[Request_createTaskList]) -&gt; Response_createTaskList\n</code></pre> <p>Creates a task list within a card. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the card to create task list in)</p> <p> TYPE: <code>str</code> </p> <p>Position of the task list within the card</p> <p> TYPE: <code>int</code> </p> <p>Name/title of the task list</p> <p> TYPE: <code>str</code> </p> <p>Whether to show the task list on the front of the card</p> <p> TYPE: <code>bool</code> </p> <p>Whether to hide completed tasks</p> <p> TYPE: <code>bool</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createTaskList(self, cardId: str, **kwargs: Unpack[Request_createTaskList]) -&gt; Response_createTaskList:\n    \"\"\"Creates a task list within a card. Requires board editor permissions.\n\n    Args:\n        cardId (str): ID of the card to create task list in)\n        position (int): Position of the task list within the card\n        name (str): Name/title of the task list\n        showOnFrontOfCard (bool): Whether to show the task list on the front of the card\n        hideCompletedTasks (bool): Whether to hide completed tasks\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.post(f\"api/cards/{cardId}/task-lists\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createTaskList(cardId)","title":"<code>cardId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createTaskList(position)","title":"<code>position</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createTaskList(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createTaskList(showOnFrontOfCard)","title":"<code>showOnFrontOfCard</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createTaskList(hideCompletedTasks)","title":"<code>hideCompletedTasks</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createUser","title":"createUser","text":"<pre><code>createUser(**kwargs: Unpack[Request_createUser]) -&gt; Response_createUser\n</code></pre> <p>Creates a user account. Requires admin privileges.</p> PARAMETER DESCRIPTION <p>Email address for login and notifications</p> <p> TYPE: <code>str</code> </p> <p>Password for user authentication (must meet password requirements)</p> <p> TYPE: <code>str</code> </p> <p>User role defining access permissions</p> <p> TYPE: <code>Literal[admin, projectOwner, boardUser]</code> </p> <p>Full display name of the user</p> <p> TYPE: <code>str</code> </p> <p>Unique username for user identification</p> <p> TYPE: <code>str | None</code> </p> <p>Contact phone number</p> <p> TYPE: <code>str | None</code> </p> <p>Organization or company name</p> <p> TYPE: <code>str | None</code> </p> <p>Preferred language for user interface and notifications</p> <p> TYPE: <code>Literal[ar - YE, bg - BG, cs - CZ, da - DK, de - DE, el - GR, en - GB, en - US, es - ES, et - EE, fa - IR, fi - FI, fr - FR, hu - HU, id - ID, it - IT, ja - JP, ko - KR, nl - NL, pl - PL, pt - BR, pt - PT, ro - RO, ru - RU, sk - SK, sr - Cyrl - RS, sr - Latn - RS, sv - SE, tr - TR, uk - UA, uz - UZ, zh - CN, zh - TW] | None</code> </p> <p>Whether the user subscribes to their own cards</p> <p> TYPE: <code>bool</code> </p> <p>Whether the user subscribes to cards when commenting</p> <p> TYPE: <code>bool</code> </p> <p>Whether recent card highlighting is disabled</p> <p> TYPE: <code>bool</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>Conflict</code> <p>409</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createUser(self, **kwargs: Unpack[Request_createUser]) -&gt; Response_createUser:\n    \"\"\"Creates a user account. Requires admin privileges.\n\n    Args:\n        email (str): Email address for login and notifications\n        password (str): Password for user authentication (must meet password requirements)\n        role (Literal['admin', 'projectOwner', 'boardUser']): User role defining access permissions\n        name (str): Full display name of the user\n        username (str | None): Unique username for user identification\n        phone (str | None): Contact phone number\n        organization (str | None): Organization or company name\n        language (Literal['ar-YE', 'bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-GB', 'en-US', 'es-ES', 'et-EE', 'fa-IR', 'fi-FI', 'fr-FR', 'hu-HU', 'id-ID', 'it-IT', 'ja-JP', 'ko-KR', 'nl-NL', 'pl-PL', 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sk-SK', 'sr-Cyrl-RS', 'sr-Latn-RS', 'sv-SE', 'tr-TR', 'uk-UA', 'uz-UZ', 'zh-CN', 'zh-TW'] | None): Preferred language for user interface and notifications\n        subscribeToOwnCards (bool): Whether the user subscribes to their own cards\n        subscribeToCardWhenCommenting (bool): Whether the user subscribes to cards when commenting\n        turnOffRecentCardHighlighting (bool): Whether recent card highlighting is disabled\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        Conflict: 409 \n    \"\"\"\n    resp = self.client.post(\"api/users\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createUser(email)","title":"<code>email</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createUser(password)","title":"<code>password</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createUser(role)","title":"<code>role</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createUser(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createUser(username)","title":"<code>username</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createUser(phone)","title":"<code>phone</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createUser(organization)","title":"<code>organization</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createUser(language)","title":"<code>language</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createUser(subscribeToOwnCards)","title":"<code>subscribeToOwnCards</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createUser(subscribeToCardWhenCommenting)","title":"<code>subscribeToCardWhenCommenting</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createUser(turnOffRecentCardHighlighting)","title":"<code>turnOffRecentCardHighlighting</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createUserNotificationService","title":"createUserNotificationService","text":"<pre><code>createUserNotificationService(userId: str, **kwargs: Unpack[Request_createUserNotificationService]) -&gt; Response_createUserNotificationService\n</code></pre> <p>Creates a new notification service for a user. Users can only create services for themselves.</p> PARAMETER DESCRIPTION <p>ID of the user to create notification service for (must be the current user))</p> <p> TYPE: <code>str</code> </p> <p>URL endpoint for notifications</p> <p> TYPE: <code>str</code> </p> <p>Format for notification messages</p> <p> TYPE: <code>Literal[text, markdown, html]</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404 </p> <code>Conflict</code> <p>409</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createUserNotificationService(self, userId: str, **kwargs: Unpack[Request_createUserNotificationService]) -&gt; Response_createUserNotificationService:\n    \"\"\"Creates a new notification service for a user. Users can only create services for themselves.\n\n    Args:\n        userId (str): ID of the user to create notification service for (must be the current user))\n        url (str): URL endpoint for notifications\n        format (Literal['text', 'markdown', 'html']): Format for notification messages\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n        Conflict: 409 \n    \"\"\"\n    resp = self.client.post(f\"api/users/{userId}/notification-services\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createUserNotificationService(userId)","title":"<code>userId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createUserNotificationService(url)","title":"<code>url</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createUserNotificationService(format)","title":"<code>format</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createWebhook","title":"createWebhook","text":"<pre><code>createWebhook(**kwargs: Unpack[Request_createWebhook]) -&gt; Response_createWebhook\n</code></pre> <p>Creates a webhook. Requires admin privileges.</p> PARAMETER DESCRIPTION <p>Name/title of the webhook</p> <p> TYPE: <code>str</code> </p> <p>URL endpoint for the webhook</p> <p> TYPE: <code>str</code> </p> <p>Access token for webhook authentication</p> <p> TYPE: <code>str | None</code> </p> <p>Comma-separated list of events that trigger the webhook</p> <p> TYPE: <code>str | None</code> </p> <p>Comma-separated list of events excluded from the webhook</p> <p> TYPE: <code>str | None</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Conflict</code> <p>409</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def createWebhook(self, **kwargs: Unpack[Request_createWebhook]) -&gt; Response_createWebhook:\n    \"\"\"Creates a webhook. Requires admin privileges.\n\n    Args:\n        name (str): Name/title of the webhook\n        url (str): URL endpoint for the webhook\n        accessToken (str | None): Access token for webhook authentication\n        events (str | None): Comma-separated list of events that trigger the webhook\n        excludedEvents (str | None): Comma-separated list of events excluded from the webhook\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Conflict: 409 \n    \"\"\"\n    resp = self.client.post(\"api/webhooks\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createWebhook(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createWebhook(url)","title":"<code>url</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createWebhook(accessToken)","title":"<code>accessToken</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createWebhook(events)","title":"<code>events</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.createWebhook(excludedEvents)","title":"<code>excludedEvents</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteAccessToken","title":"deleteAccessToken","text":"<pre><code>deleteAccessToken() -&gt; Response_deleteAccessToken\n</code></pre> <p>Logs out the current user by deleting the session and access token. Clears HTTP-only cookies if present.</p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>Unauthorized</code> <p>401</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def deleteAccessToken(self) -&gt; Response_deleteAccessToken:\n    \"\"\"Logs out the current user by deleting the session and access token. Clears HTTP-only cookies if present.\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        Unauthorized: 401 \n    \"\"\"\n    resp = self.client.delete(\"api/access-tokens/me\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteAttachment","title":"deleteAttachment","text":"<pre><code>deleteAttachment(id: str) -&gt; Response_deleteAttachment\n</code></pre> <p>Deletes an attachment. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the attachment to delete)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def deleteAttachment(self, id: str) -&gt; Response_deleteAttachment:\n    \"\"\"Deletes an attachment. Requires board editor permissions.\n\n    Args:\n        id (str): ID of the attachment to delete)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.delete(f\"api/attachments/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteAttachment(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteBackgroundImage","title":"deleteBackgroundImage","text":"<pre><code>deleteBackgroundImage(id: str) -&gt; Response_deleteBackgroundImage\n</code></pre> <p>Deletes a background image. Requires project manager permissions.</p> PARAMETER DESCRIPTION <p>ID of the background image to delete)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def deleteBackgroundImage(self, id: str) -&gt; Response_deleteBackgroundImage:\n    \"\"\"Deletes a background image. Requires project manager permissions.\n\n    Args:\n        id (str): ID of the background image to delete)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.delete(f\"api/background-images/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteBackgroundImage(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteBaseCustomFieldGroup","title":"deleteBaseCustomFieldGroup","text":"<pre><code>deleteBaseCustomFieldGroup(id: str) -&gt; Response_deleteBaseCustomFieldGroup\n</code></pre> <p>Deletes a base custom field group. Requires project manager permissions.</p> PARAMETER DESCRIPTION <p>ID of the base custom field group to delete)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def deleteBaseCustomFieldGroup(self, id: str) -&gt; Response_deleteBaseCustomFieldGroup:\n    \"\"\"Deletes a base custom field group. Requires project manager permissions.\n\n    Args:\n        id (str): ID of the base custom field group to delete)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.delete(f\"api/base-custom-field-groups/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteBaseCustomFieldGroup(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteBoard","title":"deleteBoard","text":"<pre><code>deleteBoard(id: str) -&gt; Response_deleteBoard\n</code></pre> <p>Deletes a board and all its contents (lists, cards, etc.). Requires project manager permissions.</p> PARAMETER DESCRIPTION <p>ID of the board to delete)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def deleteBoard(self, id: str) -&gt; Response_deleteBoard:\n    \"\"\"Deletes a board and all its contents (lists, cards, etc.). Requires project manager permissions.\n\n    Args:\n        id (str): ID of the board to delete)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.delete(f\"api/boards/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteBoard(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteBoardMembership","title":"deleteBoardMembership","text":"<pre><code>deleteBoardMembership(id: str) -&gt; Response_deleteBoardMembership\n</code></pre> <p>Deletes a board membership. Users can remove their own membership, project managers can remove any membership.</p> PARAMETER DESCRIPTION <p>ID of the board membership to delete)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def deleteBoardMembership(self, id: str) -&gt; Response_deleteBoardMembership:\n    \"\"\"Deletes a board membership. Users can remove their own membership, project managers can remove any membership.\n\n    Args:\n        id (str): ID of the board membership to delete)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.delete(f\"api/board-memberships/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteBoardMembership(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteCard","title":"deleteCard","text":"<pre><code>deleteCard(id: str) -&gt; Response_deleteCard\n</code></pre> <p>Deletes a card and all its contents (tasks, attachments, etc.). Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the card to delete)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def deleteCard(self, id: str) -&gt; Response_deleteCard:\n    \"\"\"Deletes a card and all its contents (tasks, attachments, etc.). Requires board editor permissions.\n\n    Args:\n        id (str): ID of the card to delete)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.delete(f\"api/cards/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteCard(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteCardLabel","title":"deleteCardLabel","text":"<pre><code>deleteCardLabel(cardId: str, labelId: str) -&gt; Response_deleteCardLabel\n</code></pre> <p>Removes a label from a card. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the card to remove the label from)</p> <p> TYPE: <code>str</code> </p> <p>ID of the label to remove from the card)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def deleteCardLabel(self, cardId: str, labelId: str) -&gt; Response_deleteCardLabel:\n    \"\"\"Removes a label from a card. Requires board editor permissions.\n\n    Args:\n        cardId (str): ID of the card to remove the label from)\n        labelId (str): ID of the label to remove from the card)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.delete(f\"api/cards/{cardId}/card-labels/labelId:{labelId}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteCardLabel(cardId)","title":"<code>cardId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteCardLabel(labelId)","title":"<code>labelId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteCardMembership","title":"deleteCardMembership","text":"<pre><code>deleteCardMembership(cardId: str, userId: str) -&gt; Response_deleteCardMembership\n</code></pre> <p>Removes a user from a card. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the card to remove the user from)</p> <p> TYPE: <code>str</code> </p> <p>ID of the user to remove from the card)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def deleteCardMembership(self, cardId: str, userId: str) -&gt; Response_deleteCardMembership:\n    \"\"\"Removes a user from a card. Requires board editor permissions.\n\n    Args:\n        cardId (str): ID of the card to remove the user from)\n        userId (str): ID of the user to remove from the card)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.delete(f\"api/cards/{cardId}/card-memberships/userId:{userId}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteCardMembership(cardId)","title":"<code>cardId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteCardMembership(userId)","title":"<code>userId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteComment","title":"deleteComment","text":"<pre><code>deleteComment(id: str) -&gt; Response_deleteComment\n</code></pre> <p>Deletes a comment. Can be deleted by the comment author (with comment permissions) or project manager.</p> PARAMETER DESCRIPTION <p>ID of the comment to delete)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def deleteComment(self, id: str) -&gt; Response_deleteComment:\n    \"\"\"Deletes a comment. Can be deleted by the comment author (with comment permissions) or project manager.\n\n    Args:\n        id (str): ID of the comment to delete)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.delete(f\"api/comments/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteComment(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteCustomField","title":"deleteCustomField","text":"<pre><code>deleteCustomField(id: str) -&gt; Response_deleteCustomField\n</code></pre> <p>Deletes a custom field. Can delete the in base custom field group (requires project manager permissions) or the custom field group (requires board editor permissions).</p> PARAMETER DESCRIPTION <p>ID of the custom field to delete)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def deleteCustomField(self, id: str) -&gt; Response_deleteCustomField:\n    \"\"\"Deletes a custom field. Can delete the in base custom field group (requires project manager permissions) or the custom field group (requires board editor permissions).\n\n    Args:\n        id (str): ID of the custom field to delete)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.delete(f\"api/custom-fields/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteCustomField(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteCustomFieldGroup","title":"deleteCustomFieldGroup","text":"<pre><code>deleteCustomFieldGroup(id: str) -&gt; Response_deleteCustomFieldGroup\n</code></pre> <p>Deletes a custom field group. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the custom field group to delete)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def deleteCustomFieldGroup(self, id: str) -&gt; Response_deleteCustomFieldGroup:\n    \"\"\"Deletes a custom field group. Requires board editor permissions.\n\n    Args:\n        id (str): ID of the custom field group to delete)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.delete(f\"api/custom-field-groups/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteCustomFieldGroup(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteCustomFieldValue","title":"deleteCustomFieldValue","text":"<pre><code>deleteCustomFieldValue(cardId: str, customFieldGroupId: str, customFieldId: str) -&gt; Response_deleteCustomFieldValue\n</code></pre> <p>Deletes a custom field value for a specific card. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the card to delete the custom field value from)</p> <p> TYPE: <code>str</code> </p> <p>ID of the custom field group the value belongs to)</p> <p> TYPE: <code>str</code> </p> <p>ID of the custom field the value belongs to)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def deleteCustomFieldValue(self, cardId: str, customFieldGroupId: str, customFieldId: str) -&gt; Response_deleteCustomFieldValue:\n    \"\"\"Deletes a custom field value for a specific card. Requires board editor permissions.\n\n    Args:\n        cardId (str): ID of the card to delete the custom field value from)\n        customFieldGroupId (str): ID of the custom field group the value belongs to)\n        customFieldId (str): ID of the custom field the value belongs to)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.delete(f\"api/cards/{cardId}/custom-field-value/customFieldGroupId:{customFieldGroupId}:customFieldId:${customFieldId}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteCustomFieldValue(cardId)","title":"<code>cardId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteCustomFieldValue(customFieldGroupId)","title":"<code>customFieldGroupId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteCustomFieldValue(customFieldId)","title":"<code>customFieldId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteLabel","title":"deleteLabel","text":"<pre><code>deleteLabel(id: str) -&gt; Response_deleteLabel\n</code></pre> <p>Deletes a label. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the label to delete)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def deleteLabel(self, id: str) -&gt; Response_deleteLabel:\n    \"\"\"Deletes a label. Requires board editor permissions.\n\n    Args:\n        id (str): ID of the label to delete)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.delete(f\"api/labels/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteLabel(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteList","title":"deleteList","text":"<pre><code>deleteList(id: str) -&gt; Response_deleteList\n</code></pre> <p>Deletes a list and moves its cards to a trash list. Can only delete finite lists. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the list to delete)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def deleteList(self, id: str) -&gt; Response_deleteList:\n    \"\"\"Deletes a list and moves its cards to a trash list. Can only delete finite lists. Requires board editor permissions.\n\n    Args:\n        id (str): ID of the list to delete)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.delete(f\"api/lists/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteList(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteNotificationService","title":"deleteNotificationService","text":"<pre><code>deleteNotificationService(id: str) -&gt; Response_deleteNotificationService\n</code></pre> <p>Deletes a notification service. Users can delete their own services, project managers can delete board services.</p> PARAMETER DESCRIPTION <p>ID of the notification service to delete)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def deleteNotificationService(self, id: str) -&gt; Response_deleteNotificationService:\n    \"\"\"Deletes a notification service. Users can delete their own services, project managers can delete board services.\n\n    Args:\n        id (str): ID of the notification service to delete)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.delete(f\"api/notification-services/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteNotificationService(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteProject","title":"deleteProject","text":"<pre><code>deleteProject(id: str) -&gt; Response_deleteProject\n</code></pre> <p>Deletes a project. The project must not have any boards. Requires project manager permissions.</p> PARAMETER DESCRIPTION <p>ID of the project to delete)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404 </p> <code>UnprocessableEntity</code> <p>422</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def deleteProject(self, id: str) -&gt; Response_deleteProject:\n    \"\"\"Deletes a project. The project must not have any boards. Requires project manager permissions.\n\n    Args:\n        id (str): ID of the project to delete)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n        UnprocessableEntity: 422 \n    \"\"\"\n    resp = self.client.delete(f\"api/projects/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteProject(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteProjectManager","title":"deleteProjectManager","text":"<pre><code>deleteProjectManager(id: str) -&gt; Response_deleteProjectManager\n</code></pre> <p>Deletes a project manager. Requires admin privileges for shared projects or existing project manager permissions. Cannot remove the last project manager.</p> PARAMETER DESCRIPTION <p>ID of the project manager to delete)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404 </p> <code>UnprocessableEntity</code> <p>422</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def deleteProjectManager(self, id: str) -&gt; Response_deleteProjectManager:\n    \"\"\"Deletes a project manager. Requires admin privileges for shared projects or existing project manager permissions. Cannot remove the last project manager.\n\n    Args:\n        id (str): ID of the project manager to delete)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n        UnprocessableEntity: 422 \n    \"\"\"\n    resp = self.client.delete(f\"api/project-managers/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteProjectManager(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteTask","title":"deleteTask","text":"<pre><code>deleteTask(id: str) -&gt; Response_deleteTask\n</code></pre> <p>Deletes a task. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the task to delete)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def deleteTask(self, id: str) -&gt; Response_deleteTask:\n    \"\"\"Deletes a task. Requires board editor permissions.\n\n    Args:\n        id (str): ID of the task to delete)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.delete(f\"api/tasks/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteTask(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteTaskList","title":"deleteTaskList","text":"<pre><code>deleteTaskList(id: str) -&gt; Response_deleteTaskList\n</code></pre> <p>Deletes a task list and all its tasks. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the task list to delete)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def deleteTaskList(self, id: str) -&gt; Response_deleteTaskList:\n    \"\"\"Deletes a task list and all its tasks. Requires board editor permissions.\n\n    Args:\n        id (str): ID of the task list to delete)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.delete(f\"api/task-lists/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteTaskList(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteUser","title":"deleteUser","text":"<pre><code>deleteUser(id: str) -&gt; Response_deleteUser\n</code></pre> <p>Deletes a user account. Cannot delete the default admin user. Requires admin privileges.</p> PARAMETER DESCRIPTION <p>ID of the user to delete)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def deleteUser(self, id: str) -&gt; Response_deleteUser:\n    \"\"\"Deletes a user account. Cannot delete the default admin user. Requires admin privileges.\n\n    Args:\n        id (str): ID of the user to delete)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.delete(f\"api/users/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteUser(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteWebhook","title":"deleteWebhook","text":"<pre><code>deleteWebhook(id: str) -&gt; Response_deleteWebhook\n</code></pre> <p>Deletes a webhook. Requires admin privileges.</p> PARAMETER DESCRIPTION <p>ID of the webhook to delete)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def deleteWebhook(self, id: str) -&gt; Response_deleteWebhook:\n    \"\"\"Deletes a webhook. Requires admin privileges.\n\n    Args:\n        id (str): ID of the webhook to delete)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.delete(f\"api/webhooks/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.deleteWebhook(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.duplicateCard","title":"duplicateCard","text":"<pre><code>duplicateCard(id: str, **kwargs: Unpack[Request_duplicateCard]) -&gt; Response_duplicateCard\n</code></pre> <p>Creates a duplicate of a card with all its contents (tasks, attachments, etc.). Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the card to duplicate)</p> <p> TYPE: <code>str</code> </p> <p>Position for the duplicated card within the list</p> <p> TYPE: <code>int</code> </p> <p>Name/title for the duplicated card</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def duplicateCard(self, id: str, **kwargs: Unpack[Request_duplicateCard]) -&gt; Response_duplicateCard:\n    \"\"\"Creates a duplicate of a card with all its contents (tasks, attachments, etc.). Requires board editor permissions.\n\n    Args:\n        id (str): ID of the card to duplicate)\n        position (int): Position for the duplicated card within the list\n        name (str): Name/title for the duplicated card\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.post(f\"api/cards/{id}/duplicate\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.duplicateCard(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.duplicateCard(position)","title":"<code>position</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.duplicateCard(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.exchangeForAccessTokenWithOidc","title":"exchangeForAccessTokenWithOidc","text":"<pre><code>exchangeForAccessTokenWithOidc(**kwargs: Unpack[Request_exchangeForAccessTokenWithOidc]) -&gt; Response_exchangeForAccessTokenWithOidc\n</code></pre> <p>Exchanges an OIDC authorization code for an access token. Creates a user if they do not exist.</p> PARAMETER DESCRIPTION <p>Authorization code from OIDC provider</p> <p> TYPE: <code>str</code> </p> <p>Nonce value for OIDC security</p> <p> TYPE: <code>str</code> </p> <p>Whether to include HTTP-only authentication cookie</p> <p> TYPE: <code>bool</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Error</code> <p>401 OIDC authentication error</p> <code>Error</code> <p>403 Authentication restriction</p> <code>Error</code> <p>409 Conflict error</p> <code>Error</code> <p>422 Missing required values</p> <code>Error</code> <p>500 OIDC configuration error</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def exchangeForAccessTokenWithOidc(self, **kwargs: Unpack[Request_exchangeForAccessTokenWithOidc]) -&gt; Response_exchangeForAccessTokenWithOidc:\n    \"\"\"Exchanges an OIDC authorization code for an access token. Creates a user if they do not exist.\n\n    Args:\n        code (str): Authorization code from OIDC provider\n        nonce (str): Nonce value for OIDC security\n        withHttpOnlyToken (bool): Whether to include HTTP-only authentication cookie\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Error: 401 OIDC authentication error\n        Error: 403 Authentication restriction\n        Error: 409 Conflict error\n        Error: 422 Missing required values\n        Error: 500 OIDC configuration error\n    \"\"\"\n    resp = self.client.post(\"api/access-tokens/exchange-with-oidc\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.exchangeForAccessTokenWithOidc(code)","title":"<code>code</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.exchangeForAccessTokenWithOidc(nonce)","title":"<code>nonce</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.exchangeForAccessTokenWithOidc(withHttpOnlyToken)","title":"<code>withHttpOnlyToken</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getBoard","title":"getBoard","text":"<pre><code>getBoard(id: str, **kwargs: Unpack[Request_getBoard]) -&gt; Response_getBoard\n</code></pre> <p>Retrieves comprehensive board information, including lists, cards, and other related data.</p> PARAMETER DESCRIPTION <p>ID of the board to retrieve)</p> <p> TYPE: <code>str</code> </p> <p>Whether to subscribe to real-time updates for this board (only for socket connections)) (optional)</p> <p> TYPE: <code>bool</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def getBoard(self, id: str, **kwargs: Unpack[Request_getBoard]) -&gt; Response_getBoard:\n    \"\"\"Retrieves comprehensive board information, including lists, cards, and other related data.\n\n    Args:\n        id (str): ID of the board to retrieve)\n        subscribe (bool): Whether to subscribe to real-time updates for this board (only for socket connections)) (optional)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    valid_params = ('subscribe',)\n    passed_params = {k: v for k, v in kwargs.items() if k in valid_params if isinstance(v, str | int | float)}\n    resp = self.client.get(f\"api/boards/{id}\", params=passed_params)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getBoard(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getBoard(subscribe)","title":"<code>subscribe</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getBoardActions","title":"getBoardActions","text":"<pre><code>getBoardActions(boardId: str, **kwargs: Unpack[Request_getBoardActions]) -&gt; Response_getBoardActions\n</code></pre> <p>Retrieves a list of actions (activity history) for a specific board, with pagination support.</p> PARAMETER DESCRIPTION <p>ID of the board to get actions for)</p> <p> TYPE: <code>str</code> </p> <p>ID to get actions before (for pagination)) (optional)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def getBoardActions(self, boardId: str, **kwargs: Unpack[Request_getBoardActions]) -&gt; Response_getBoardActions:\n    \"\"\"Retrieves a list of actions (activity history) for a specific board, with pagination support.\n\n    Args:\n        boardId (str): ID of the board to get actions for)\n        beforeId (str): ID to get actions before (for pagination)) (optional)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    valid_params = ('beforeId',)\n    passed_params = {k: v for k, v in kwargs.items() if k in valid_params if isinstance(v, str | int | float)}\n    resp = self.client.get(f\"api/boards/{boardId}/actions\", params=passed_params)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getBoardActions(boardId)","title":"<code>boardId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getBoardActions(beforeId)","title":"<code>beforeId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getCard","title":"getCard","text":"<pre><code>getCard(id: str) -&gt; Response_getCard\n</code></pre> <p>Retrieves comprehensive card information, including tasks, attachments, and other related data.</p> PARAMETER DESCRIPTION <p>ID of the card to retrieve)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def getCard(self, id: str) -&gt; Response_getCard:\n    \"\"\"Retrieves comprehensive card information, including tasks, attachments, and other related data.\n\n    Args:\n        id (str): ID of the card to retrieve)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.get(f\"api/cards/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getCard(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getCardActions","title":"getCardActions","text":"<pre><code>getCardActions(cardId: str, **kwargs: Unpack[Request_getCardActions]) -&gt; Response_getCardActions\n</code></pre> <p>Retrieves a list of actions (activity history) for a specific card, with pagination support.</p> PARAMETER DESCRIPTION <p>ID of the card to get actions for)</p> <p> TYPE: <code>str</code> </p> <p>ID to get actions before (for pagination)) (optional)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def getCardActions(self, cardId: str, **kwargs: Unpack[Request_getCardActions]) -&gt; Response_getCardActions:\n    \"\"\"Retrieves a list of actions (activity history) for a specific card, with pagination support.\n\n    Args:\n        cardId (str): ID of the card to get actions for)\n        beforeId (str): ID to get actions before (for pagination)) (optional)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    valid_params = ('beforeId',)\n    passed_params = {k: v for k, v in kwargs.items() if k in valid_params if isinstance(v, str | int | float)}\n    resp = self.client.get(f\"api/cards/{cardId}/actions\", params=passed_params)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getCardActions(cardId)","title":"<code>cardId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getCardActions(beforeId)","title":"<code>beforeId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getCards","title":"getCards","text":"<pre><code>getCards(listId: str, **kwargs: Unpack[Request_getCards]) -&gt; Response_getCards\n</code></pre> <p>Retrieves cards from an endless list with filtering, search, and pagination support.</p> PARAMETER DESCRIPTION <p>ID of the list to get cards from (must be an endless list))</p> <p> TYPE: <code>str</code> </p> <p>Pagination cursor (JSON object with id and listChangedAt)) (optional)</p> <p> TYPE: <code>str</code> </p> <p>Search term to filter cards) (optional)</p> <p> TYPE: <code>str</code> </p> <p>Comma-separated user IDs to filter by members) (optional)</p> <p> TYPE: <code>str</code> </p> <p>Comma-separated label IDs to filter by labels) (optional)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def getCards(self, listId: str, **kwargs: Unpack[Request_getCards]) -&gt; Response_getCards:\n    \"\"\"Retrieves cards from an endless list with filtering, search, and pagination support.\n\n    Args:\n        listId (str): ID of the list to get cards from (must be an endless list))\n        before (str): Pagination cursor (JSON object with id and listChangedAt)) (optional)\n        search (str): Search term to filter cards) (optional)\n        userIds (str): Comma-separated user IDs to filter by members) (optional)\n        labelIds (str): Comma-separated label IDs to filter by labels) (optional)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    valid_params = ('before', 'search', 'userIds', 'labelIds')\n    passed_params = {k: v for k, v in kwargs.items() if k in valid_params if isinstance(v, str | int | float)}\n    resp = self.client.get(f\"api/lists/{listId}/cards\", params=passed_params)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getCards(listId)","title":"<code>listId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getCards(before)","title":"<code>before</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getCards(search)","title":"<code>search</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getCards(userIds)","title":"<code>userIds</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getCards(labelIds)","title":"<code>labelIds</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getComments","title":"getComments","text":"<pre><code>getComments(cardId: str, **kwargs: Unpack[Request_getComments]) -&gt; Response_getComments\n</code></pre> <p>Retrieves comments for a card with pagination support. Requires access to the card.</p> PARAMETER DESCRIPTION <p>ID of the card to retrieve comments for)</p> <p> TYPE: <code>str</code> </p> <p>ID to get comments before (for pagination)) (optional)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def getComments(self, cardId: str, **kwargs: Unpack[Request_getComments]) -&gt; Response_getComments:\n    \"\"\"Retrieves comments for a card with pagination support. Requires access to the card.\n\n    Args:\n        cardId (str): ID of the card to retrieve comments for)\n        beforeId (str): ID to get comments before (for pagination)) (optional)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    valid_params = ('beforeId',)\n    passed_params = {k: v for k, v in kwargs.items() if k in valid_params if isinstance(v, str | int | float)}\n    resp = self.client.get(f\"api/cards/{cardId}/comments\", params=passed_params)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getComments(cardId)","title":"<code>cardId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getComments(beforeId)","title":"<code>beforeId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getConfig","title":"getConfig","text":"<pre><code>getConfig() -&gt; Response_getConfig\n</code></pre> <p>Retrieves the application configuration.</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def getConfig(self) -&gt; Response_getConfig:\n    \"\"\"Retrieves the application configuration.\n    \"\"\"\n    resp = self.client.get(\"api/config\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getCustomFieldGroup","title":"getCustomFieldGroup","text":"<pre><code>getCustomFieldGroup(id: str) -&gt; Response_getCustomFieldGroup\n</code></pre> <p>Retrieves comprehensive custom field group information, including fields and values. Requires access to the board/card.</p> PARAMETER DESCRIPTION <p>ID of the custom field group to retrieve)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def getCustomFieldGroup(self, id: str) -&gt; Response_getCustomFieldGroup:\n    \"\"\"Retrieves comprehensive custom field group information, including fields and values. Requires access to the board/card.\n\n    Args:\n        id (str): ID of the custom field group to retrieve)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.get(f\"api/custom-field-groups/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getCustomFieldGroup(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getList","title":"getList","text":"<pre><code>getList(id: str) -&gt; Response_getList\n</code></pre> <p>Retrieves comprehensive list information, including cards, attachments, and other related data. Requires access to the board.</p> PARAMETER DESCRIPTION <p>ID of the list to retrieve)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def getList(self, id: str) -&gt; Response_getList:\n    \"\"\"Retrieves comprehensive list information, including cards, attachments, and other related data. Requires access to the board.\n\n    Args:\n        id (str): ID of the list to retrieve)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.get(f\"api/lists/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getList(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getNotification","title":"getNotification","text":"<pre><code>getNotification(id: str) -&gt; Response_getNotification\n</code></pre> <p>Retrieves notification, including creator users. Users can only access their own notifications.</p> PARAMETER DESCRIPTION <p>ID of the notification to retrieve)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def getNotification(self, id: str) -&gt; Response_getNotification:\n    \"\"\"Retrieves notification, including creator users. Users can only access their own notifications.\n\n    Args:\n        id (str): ID of the notification to retrieve)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.get(f\"api/notifications/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getNotification(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getNotifications","title":"getNotifications","text":"<pre><code>getNotifications() -&gt; Response_getNotifications\n</code></pre> <p>Retrieves all unread notifications for the current user, including creator users.</p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def getNotifications(self) -&gt; Response_getNotifications:\n    \"\"\"Retrieves all unread notifications for the current user, including creator users.\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n    \"\"\"\n    resp = self.client.get(\"api/notifications\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getProject","title":"getProject","text":"<pre><code>getProject(id: str) -&gt; Response_getProject\n</code></pre> <p>Retrieves comprehensive project information, including boards, board memberships, and other related data.</p> PARAMETER DESCRIPTION <p>ID of the project to retrieve)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def getProject(self, id: str) -&gt; Response_getProject:\n    \"\"\"Retrieves comprehensive project information, including boards, board memberships, and other related data.\n\n    Args:\n        id (str): ID of the project to retrieve)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.get(f\"api/projects/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getProject(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getProjects","title":"getProjects","text":"<pre><code>getProjects() -&gt; Response_getProjects\n</code></pre> <p>Retrieves all projects the current user has access to, including managed projects, membership projects, and shared projects (for admins).</p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def getProjects(self) -&gt; Response_getProjects:\n    \"\"\"Retrieves all projects the current user has access to, including managed projects, membership projects, and shared projects (for admins).\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n    \"\"\"\n    resp = self.client.get(\"api/projects\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getTaskList","title":"getTaskList","text":"<pre><code>getTaskList(id: str) -&gt; Response_getTaskList\n</code></pre> <p>Retrieves task list information, including tasks. Requires access to the card.</p> PARAMETER DESCRIPTION <p>ID of the task list to retrieve)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def getTaskList(self, id: str) -&gt; Response_getTaskList:\n    \"\"\"Retrieves task list information, including tasks. Requires access to the card.\n\n    Args:\n        id (str): ID of the task list to retrieve)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.get(f\"api/task-lists/{id}\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getTaskList(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getTerms","title":"getTerms","text":"<pre><code>getTerms(type: Literal['general', 'extended'], **kwargs: Unpack[Request_getTerms]) -&gt; Response_getTerms\n</code></pre> <p>Retrieves terms and conditions in the specified language.</p> PARAMETER DESCRIPTION <p>Type of terms to retrieve)</p> <p> TYPE: <code>Literal[general, extended]</code> </p> <p>Language code for terms localization) (optional)</p> <p> TYPE: <code>Literal[de - DE, en - US]</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def getTerms(self, type: Literal['general', 'extended'], **kwargs: Unpack[Request_getTerms]) -&gt; Response_getTerms:\n    \"\"\"Retrieves terms and conditions in the specified language.\n\n    Args:\n        type (Literal['general', 'extended']): Type of terms to retrieve)\n        language (Literal['de-DE', 'en-US']): Language code for terms localization) (optional)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    valid_params = ('language',)\n    passed_params = {k: v for k, v in kwargs.items() if k in valid_params if isinstance(v, str | int | float)}\n    resp = self.client.get(f\"api/terms/{type}\", params=passed_params)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getTerms(type)","title":"<code>type</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getTerms(language)","title":"<code>language</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getUser","title":"getUser","text":"<pre><code>getUser(id: str, **kwargs: Unpack[Request_getUser]) -&gt; Response_getUser\n</code></pre> <p>Retrieves a user. Use 'me' as ID to get the current user.</p> PARAMETER DESCRIPTION <p>ID of the user or 'me' for current user)</p> <p> TYPE: <code>str</code> </p> <p>Whether to subscribe to real-time updates for this user (only for socket connections)) (optional)</p> <p> TYPE: <code>bool</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def getUser(self, id: str, **kwargs: Unpack[Request_getUser]) -&gt; Response_getUser:\n    \"\"\"Retrieves a user. Use 'me' as ID to get the current user.\n\n    Args:\n        id (str): ID of the user or 'me' for current user)\n        subscribe (bool): Whether to subscribe to real-time updates for this user (only for socket connections)) (optional)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    valid_params = ('subscribe',)\n    passed_params = {k: v for k, v in kwargs.items() if k in valid_params if isinstance(v, str | int | float)}\n    resp = self.client.get(f\"api/users/{id}\", params=passed_params)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getUser(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getUser(subscribe)","title":"<code>subscribe</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getUsers","title":"getUsers","text":"<pre><code>getUsers() -&gt; Response_getUsers\n</code></pre> <p>Retrieves a list of all users. Requires admin or project owner privileges.</p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def getUsers(self) -&gt; Response_getUsers:\n    \"\"\"Retrieves a list of all users. Requires admin or project owner privileges.\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n    \"\"\"\n    resp = self.client.get(\"api/users\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.getWebhooks","title":"getWebhooks","text":"<pre><code>getWebhooks() -&gt; Response_getWebhooks\n</code></pre> <p>Retrieves a list of all configured webhooks. Requires admin privileges.</p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def getWebhooks(self) -&gt; Response_getWebhooks:\n    \"\"\"Retrieves a list of all configured webhooks. Requires admin privileges.\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n    \"\"\"\n    resp = self.client.get(\"api/webhooks\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.moveListCards","title":"moveListCards","text":"<pre><code>moveListCards(id: str, **kwargs: Unpack[Request_moveListCards]) -&gt; Response_moveListCards\n</code></pre> <p>Moves all cards from a closed list to an archive list. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the source list (must be a closed-type list))</p> <p> TYPE: <code>str</code> </p> <p>ID of the target list (must be an archive-type list)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def moveListCards(self, id: str, **kwargs: Unpack[Request_moveListCards]) -&gt; Response_moveListCards:\n    \"\"\"Moves all cards from a closed list to an archive list. Requires board editor permissions.\n\n    Args:\n        id (str): ID of the source list (must be a closed-type list))\n        listId (str): ID of the target list (must be an archive-type list)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.post(f\"api/lists/{id}/move-cards\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.moveListCards(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.moveListCards(listId)","title":"<code>listId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.readAllNotifications","title":"readAllNotifications","text":"<pre><code>readAllNotifications() -&gt; Response_readAllNotifications\n</code></pre> <p>Marks all notifications for the current user as read.</p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def readAllNotifications(self) -&gt; Response_readAllNotifications:\n    \"\"\"Marks all notifications for the current user as read.\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n    \"\"\"\n    resp = self.client.post(\"api/notifications/read-all\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.readCardNotifications","title":"readCardNotifications","text":"<pre><code>readCardNotifications(id: str) -&gt; Response_readCardNotifications\n</code></pre> <p>Marks all notifications for a specific card as read for the current user. Requires access to the card.</p> PARAMETER DESCRIPTION <p>ID of the card to mark notifications as read for)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def readCardNotifications(self, id: str) -&gt; Response_readCardNotifications:\n    \"\"\"Marks all notifications for a specific card as read for the current user. Requires access to the card.\n\n    Args:\n        id (str): ID of the card to mark notifications as read for)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.post(f\"api/cards/{id}/read-notifications\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.readCardNotifications(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.revokePendingToken","title":"revokePendingToken","text":"<pre><code>revokePendingToken(**kwargs: Unpack[Request_revokePendingToken]) -&gt; Response_revokePendingToken\n</code></pre> <p>Revokes a pending authentication token and cancels the authentication flow.</p> PARAMETER DESCRIPTION <p>Pending token to revoke</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def revokePendingToken(self, **kwargs: Unpack[Request_revokePendingToken]) -&gt; Response_revokePendingToken:\n    \"\"\"Revokes a pending authentication token and cancels the authentication flow.\n\n    Args:\n        pendingToken (str): Pending token to revoke\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.post(\"api/access-tokens/revoke-pending-token\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.revokePendingToken(pendingToken)","title":"<code>pendingToken</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.sortList","title":"sortList","text":"<pre><code>sortList(id: str, **kwargs: Unpack[Request_sortList]) -&gt; Response_sortList\n</code></pre> <p>Sorts all cards within a list. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the list to sort)</p> <p> TYPE: <code>str</code> </p> <p>Field to sort cards by</p> <p> TYPE: <code>Literal[name, dueDate, createdAt]</code> </p> <p>Sorting order</p> <p> TYPE: <code>Literal[asc, desc]</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404 </p> <code>UnprocessableEntity</code> <p>422</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def sortList(self, id: str, **kwargs: Unpack[Request_sortList]) -&gt; Response_sortList:\n    \"\"\"Sorts all cards within a list. Requires board editor permissions.\n\n    Args:\n        id (str): ID of the list to sort)\n        fieldName (Literal['name', 'dueDate', 'createdAt']): Field to sort cards by\n        order (Literal['asc', 'desc']): Sorting order\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n        UnprocessableEntity: 422 \n    \"\"\"\n    resp = self.client.post(f\"api/lists/{id}/sort\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.sortList(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.sortList(fieldName)","title":"<code>fieldName</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.sortList(order)","title":"<code>order</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.testNotificationService","title":"testNotificationService","text":"<pre><code>testNotificationService(id: str) -&gt; Response_testNotificationService\n</code></pre> <p>Sends a test notification to verify the notification service is working. Users can test their own services, project managers can test board services.</p> PARAMETER DESCRIPTION <p>ID of the notification service to test)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def testNotificationService(self, id: str) -&gt; Response_testNotificationService:\n    \"\"\"Sends a test notification to verify the notification service is working. Users can test their own services, project managers can test board services.\n\n    Args:\n        id (str): ID of the notification service to test)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.post(f\"api/notification-services/{id}/test\")\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.testNotificationService(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateAttachment","title":"updateAttachment","text":"<pre><code>updateAttachment(id: str, **kwargs: Unpack[Request_updateAttachment]) -&gt; Response_updateAttachment\n</code></pre> <p>Updates an attachment. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the attachment to update)</p> <p> TYPE: <code>str</code> </p> <p>Name/title of the attachment</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def updateAttachment(self, id: str, **kwargs: Unpack[Request_updateAttachment]) -&gt; Response_updateAttachment:\n    \"\"\"Updates an attachment. Requires board editor permissions.\n\n    Args:\n        id (str): ID of the attachment to update)\n        name (str): Name/title of the attachment\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.patch(f\"api/attachments/{id}\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateAttachment(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateAttachment(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateBaseCustomFieldGroup","title":"updateBaseCustomFieldGroup","text":"<pre><code>updateBaseCustomFieldGroup(id: str, **kwargs: Unpack[Request_updateBaseCustomFieldGroup]) -&gt; Response_updateBaseCustomFieldGroup\n</code></pre> <p>Updates a base custom field group. Requires project manager permissions.</p> PARAMETER DESCRIPTION <p>ID of the base custom field group to update)</p> <p> TYPE: <code>str</code> </p> <p>Name/title of the base custom field group</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def updateBaseCustomFieldGroup(self, id: str, **kwargs: Unpack[Request_updateBaseCustomFieldGroup]) -&gt; Response_updateBaseCustomFieldGroup:\n    \"\"\"Updates a base custom field group. Requires project manager permissions.\n\n    Args:\n        id (str): ID of the base custom field group to update)\n        name (str): Name/title of the base custom field group\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.patch(f\"api/base-custom-field-groups/{id}\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateBaseCustomFieldGroup(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateBaseCustomFieldGroup(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateBoard","title":"updateBoard","text":"<pre><code>updateBoard(id: str, **kwargs: Unpack[Request_updateBoard]) -&gt; Response_updateBoard\n</code></pre> <p>Updates a board. Project managers can update all fields, board members can only subscribe/unsubscribe.</p> PARAMETER DESCRIPTION <p>ID of the board to update)</p> <p> TYPE: <code>str</code> </p> <p>Position of the board within the project</p> <p> TYPE: <code>int</code> </p> <p>Name/title of the board</p> <p> TYPE: <code>str</code> </p> <p>Default view for the board</p> <p> TYPE: <code>Literal[kanban, grid, list]</code> </p> <p>Default card type for new cards</p> <p> TYPE: <code>Literal[project, story]</code> </p> <p>Whether to limit card types to default one</p> <p> TYPE: <code>bool</code> </p> <p>Whether to always display card creators</p> <p> TYPE: <code>bool</code> </p> <p>Whether to expand task lists by default</p> <p> TYPE: <code>bool</code> </p> <p>Whether the current user is subscribed to the board</p> <p> TYPE: <code>bool</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def updateBoard(self, id: str, **kwargs: Unpack[Request_updateBoard]) -&gt; Response_updateBoard:\n    \"\"\"Updates a board. Project managers can update all fields, board members can only subscribe/unsubscribe.\n\n    Args:\n        id (str): ID of the board to update)\n        position (int): Position of the board within the project\n        name (str): Name/title of the board\n        defaultView (Literal['kanban', 'grid', 'list']): Default view for the board\n        defaultCardType (Literal['project', 'story']): Default card type for new cards\n        limitCardTypesToDefaultOne (bool): Whether to limit card types to default one\n        alwaysDisplayCardCreator (bool): Whether to always display card creators\n        expandTaskListsByDefault (bool): Whether to expand task lists by default\n        isSubscribed (bool): Whether the current user is subscribed to the board\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.patch(f\"api/boards/{id}\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateBoard(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateBoard(position)","title":"<code>position</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateBoard(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateBoard(defaultView)","title":"<code>defaultView</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateBoard(defaultCardType)","title":"<code>defaultCardType</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateBoard(limitCardTypesToDefaultOne)","title":"<code>limitCardTypesToDefaultOne</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateBoard(alwaysDisplayCardCreator)","title":"<code>alwaysDisplayCardCreator</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateBoard(expandTaskListsByDefault)","title":"<code>expandTaskListsByDefault</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateBoard(isSubscribed)","title":"<code>isSubscribed</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateBoardMembership","title":"updateBoardMembership","text":"<pre><code>updateBoardMembership(id: str, **kwargs: Unpack[Request_updateBoardMembership]) -&gt; Response_updateBoardMembership\n</code></pre> <p>Updates a board membership. Requires project manager permissions.</p> PARAMETER DESCRIPTION <p>ID of the board membership to update)</p> <p> TYPE: <code>str</code> </p> <p>Role of the user in the board</p> <p> TYPE: <code>Literal[editor, viewer]</code> </p> <p>Whether the user can comment on cards (applies only to viewers)</p> <p> TYPE: <code>bool | None</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def updateBoardMembership(self, id: str, **kwargs: Unpack[Request_updateBoardMembership]) -&gt; Response_updateBoardMembership:\n    \"\"\"Updates a board membership. Requires project manager permissions.\n\n    Args:\n        id (str): ID of the board membership to update)\n        role (Literal['editor', 'viewer']): Role of the user in the board\n        canComment (bool | None): Whether the user can comment on cards (applies only to viewers)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.patch(f\"api/board-memberships/{id}\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateBoardMembership(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateBoardMembership(role)","title":"<code>role</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateBoardMembership(canComment)","title":"<code>canComment</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCard","title":"updateCard","text":"<pre><code>updateCard(id: str, **kwargs: Unpack[Request_updateCard]) -&gt; Response_updateCard\n</code></pre> <p>Updates a card. Board editors can update all fields, viewers can only subscribe/unsubscribe.</p> PARAMETER DESCRIPTION <p>ID of the card to update)</p> <p> TYPE: <code>str</code> </p> <p>ID of the board to move the card to</p> <p> TYPE: <code>str</code> </p> <p>ID of the list to move the card to</p> <p> TYPE: <code>str</code> </p> <p>ID of the attachment used as cover</p> <p> TYPE: <code>str | None</code> </p> <p>Type of the card</p> <p> TYPE: <code>Literal[project, story]</code> </p> <p>Position of the card within the list</p> <p> TYPE: <code>int | None</code> </p> <p>Name/title of the card</p> <p> TYPE: <code>str</code> </p> <p>Detailed description of the card</p> <p> TYPE: <code>str | None</code> </p> <p>Due date for the card</p> <p> TYPE: <code>str | None</code> </p> <p>Whether the due date is completed</p> <p> TYPE: <code>bool | None</code> </p> <p>Stopwatch data for time tracking</p> <p> TYPE: <code>dict[str, Any] | None</code> </p> <p>Whether the current user is subscribed to the card</p> <p> TYPE: <code>bool</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404 </p> <code>UnprocessableEntity</code> <p>422</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def updateCard(self, id: str, **kwargs: Unpack[Request_updateCard]) -&gt; Response_updateCard:\n    \"\"\"Updates a card. Board editors can update all fields, viewers can only subscribe/unsubscribe.\n\n    Args:\n        id (str): ID of the card to update)\n        boardId (str): ID of the board to move the card to\n        listId (str): ID of the list to move the card to\n        coverAttachmentId (str | None): ID of the attachment used as cover\n        type (Literal['project', 'story']): Type of the card\n        position (int | None): Position of the card within the list\n        name (str): Name/title of the card\n        description (str | None): Detailed description of the card\n        dueDate (str | None): Due date for the card\n        isDueCompleted (bool | None): Whether the due date is completed\n        stopwatch (dict[str, Any] | None): Stopwatch data for time tracking\n        isSubscribed (bool): Whether the current user is subscribed to the card\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n        UnprocessableEntity: 422 \n    \"\"\"\n    resp = self.client.patch(f\"api/cards/{id}\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCard(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCard(boardId)","title":"<code>boardId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCard(listId)","title":"<code>listId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCard(coverAttachmentId)","title":"<code>coverAttachmentId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCard(type)","title":"<code>type</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCard(position)","title":"<code>position</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCard(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCard(description)","title":"<code>description</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCard(dueDate)","title":"<code>dueDate</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCard(isDueCompleted)","title":"<code>isDueCompleted</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCard(stopwatch)","title":"<code>stopwatch</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCard(isSubscribed)","title":"<code>isSubscribed</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateComments","title":"updateComments","text":"<pre><code>updateComments(id: str, **kwargs: Unpack[Request_updateComments]) -&gt; Response_updateComments\n</code></pre> <p>Updates a comment. Only the author of the comment can update it.</p> PARAMETER DESCRIPTION <p>ID of the comment to update)</p> <p> TYPE: <code>str</code> </p> <p>Content of the comment</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def updateComments(self, id: str, **kwargs: Unpack[Request_updateComments]) -&gt; Response_updateComments:\n    \"\"\"Updates a comment. Only the author of the comment can update it.\n\n    Args:\n        id (str): ID of the comment to update)\n        text (str): Content of the comment\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.patch(f\"api/comments/{id}\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateComments(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateComments(text)","title":"<code>text</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCustomField","title":"updateCustomField","text":"<pre><code>updateCustomField(id: str, **kwargs: Unpack[Request_updateCustomField]) -&gt; Response_updateCustomField\n</code></pre> <p>Updates a custom field. Can update in the base custom field group (requires project manager permissions) or the custom field group (requires board editor permissions).</p> PARAMETER DESCRIPTION <p>ID of the custom field to update)</p> <p> TYPE: <code>str</code> </p> <p>Position of the custom field within the group</p> <p> TYPE: <code>int</code> </p> <p>Name/title of the custom field</p> <p> TYPE: <code>str</code> </p> <p>Whether to show the field on the front of cards</p> <p> TYPE: <code>bool</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def updateCustomField(self, id: str, **kwargs: Unpack[Request_updateCustomField]) -&gt; Response_updateCustomField:\n    \"\"\"Updates a custom field. Can update in the base custom field group (requires project manager permissions) or the custom field group (requires board editor permissions).\n\n    Args:\n        id (str): ID of the custom field to update)\n        position (int): Position of the custom field within the group\n        name (str): Name/title of the custom field\n        showOnFrontOfCard (bool): Whether to show the field on the front of cards\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.patch(f\"api/custom-fields/{id}\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCustomField(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCustomField(position)","title":"<code>position</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCustomField(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCustomField(showOnFrontOfCard)","title":"<code>showOnFrontOfCard</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCustomFieldGroup","title":"updateCustomFieldGroup","text":"<pre><code>updateCustomFieldGroup(id: str, **kwargs: Unpack[Request_updateCustomFieldGroup]) -&gt; Response_updateCustomFieldGroup\n</code></pre> <p>Updates a custom field group. Supports both board-wide and card-specific groups. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the custom field group to update)</p> <p> TYPE: <code>str</code> </p> <p>Position of the custom field group within the board/card</p> <p> TYPE: <code>int</code> </p> <p>Name/title of the custom field group</p> <p> TYPE: <code>str | None</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404 </p> <code>UnprocessableEntity</code> <p>422</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def updateCustomFieldGroup(self, id: str, **kwargs: Unpack[Request_updateCustomFieldGroup]) -&gt; Response_updateCustomFieldGroup:\n    \"\"\"Updates a custom field group. Supports both board-wide and card-specific groups. Requires board editor permissions.\n\n    Args:\n        id (str): ID of the custom field group to update)\n        position (int): Position of the custom field group within the board/card\n        name (str | None): Name/title of the custom field group\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n        UnprocessableEntity: 422 \n    \"\"\"\n    resp = self.client.patch(f\"api/custom-field-groups/{id}\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCustomFieldGroup(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCustomFieldGroup(position)","title":"<code>position</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCustomFieldGroup(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCustomFieldValue","title":"updateCustomFieldValue","text":"<pre><code>updateCustomFieldValue(cardId: str, customFieldGroupId: str, customFieldId: str, **kwargs: Unpack[Request_updateCustomFieldValue]) -&gt; Response_updateCustomFieldValue\n</code></pre> <p>Creates or updates a custom field value for a card. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the card to set the custom field value for)</p> <p> TYPE: <code>str</code> </p> <p>ID of the custom field group the value belongs to)</p> <p> TYPE: <code>str</code> </p> <p>ID of the custom field the value belongs to)</p> <p> TYPE: <code>str</code> </p> <p>Content/value of the custom field</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def updateCustomFieldValue(self, cardId: str, customFieldGroupId: str, customFieldId: str, **kwargs: Unpack[Request_updateCustomFieldValue]) -&gt; Response_updateCustomFieldValue:\n    \"\"\"Creates or updates a custom field value for a card. Requires board editor permissions.\n\n    Args:\n        cardId (str): ID of the card to set the custom field value for)\n        customFieldGroupId (str): ID of the custom field group the value belongs to)\n        customFieldId (str): ID of the custom field the value belongs to)\n        content (str): Content/value of the custom field\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.patch(f\"api/cards/{cardId}/custom-field-values/customFieldGroupId:{customFieldGroupId}:customFieldId:${customFieldId}\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCustomFieldValue(cardId)","title":"<code>cardId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCustomFieldValue(customFieldGroupId)","title":"<code>customFieldGroupId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCustomFieldValue(customFieldId)","title":"<code>customFieldId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateCustomFieldValue(content)","title":"<code>content</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateLabel","title":"updateLabel","text":"<pre><code>updateLabel(id: str, **kwargs: Unpack[Request_updateLabel]) -&gt; Response_updateLabel\n</code></pre> <p>Updates a label. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the label to update)</p> <p> TYPE: <code>str</code> </p> <p>Position of the label within the board</p> <p> TYPE: <code>int</code> </p> <p>Name/title of the label</p> <p> TYPE: <code>str | None</code> </p> <p>Color of the label</p> <p> TYPE: <code>Literal[muddy - grey, autumn - leafs, morning - sky, antique - blue, egg - yellow, desert - sand, dark - granite, fresh - salad, lagoon - blue, midnight - blue, light - orange, pumpkin - orange, light - concrete, sunny - grass, navy - blue, lilac - eyes, apricot - red, orange - peel, silver - glint, bright - moss, deep - ocean, summer - sky, berry - red, light - cocoa, grey - stone, tank - green, coral - green, sugar - plum, pink - tulip, shady - rust, wet - rock, wet - moss, turquoise - sea, lavender - fields, piggy - red, light - mud, gun - metal, modern - green, french - coast, sweet - lilac, red - burgundy, pirate - gold]</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def updateLabel(self, id: str, **kwargs: Unpack[Request_updateLabel]) -&gt; Response_updateLabel:\n    \"\"\"Updates a label. Requires board editor permissions.\n\n    Args:\n        id (str): ID of the label to update)\n        position (int): Position of the label within the board\n        name (str | None): Name/title of the label\n        color (Literal['muddy-grey', 'autumn-leafs', 'morning-sky', 'antique-blue', 'egg-yellow', 'desert-sand', 'dark-granite', 'fresh-salad', 'lagoon-blue', 'midnight-blue', 'light-orange', 'pumpkin-orange', 'light-concrete', 'sunny-grass', 'navy-blue', 'lilac-eyes', 'apricot-red', 'orange-peel', 'silver-glint', 'bright-moss', 'deep-ocean', 'summer-sky', 'berry-red', 'light-cocoa', 'grey-stone', 'tank-green', 'coral-green', 'sugar-plum', 'pink-tulip', 'shady-rust', 'wet-rock', 'wet-moss', 'turquoise-sea', 'lavender-fields', 'piggy-red', 'light-mud', 'gun-metal', 'modern-green', 'french-coast', 'sweet-lilac', 'red-burgundy', 'pirate-gold']): Color of the label\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.patch(f\"api/labels/{id}\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateLabel(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateLabel(position)","title":"<code>position</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateLabel(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateLabel(color)","title":"<code>color</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateList","title":"updateList","text":"<pre><code>updateList(id: str, **kwargs: Unpack[Request_updateList]) -&gt; Response_updateList\n</code></pre> <p>Updates a list. Can move lists between boards. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the list to update)</p> <p> TYPE: <code>str</code> </p> <p>ID of the board to move list to</p> <p> TYPE: <code>str</code> </p> <p>Type/status of the list</p> <p> TYPE: <code>Literal[active, closed]</code> </p> <p>Position of the list within the board</p> <p> TYPE: <code>int</code> </p> <p>Name/title of the list</p> <p> TYPE: <code>str</code> </p> <p>Color for the list</p> <p> TYPE: <code>Literal[berry - red, pumpkin - orange, lagoon - blue, pink - tulip, light - mud, orange - peel, bright - moss, antique - blue, dark - granite, turquoise - sea] | None</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def updateList(self, id: str, **kwargs: Unpack[Request_updateList]) -&gt; Response_updateList:\n    \"\"\"Updates a list. Can move lists between boards. Requires board editor permissions.\n\n    Args:\n        id (str): ID of the list to update)\n        boardId (str): ID of the board to move list to\n        type (Literal['active', 'closed']): Type/status of the list\n        position (int): Position of the list within the board\n        name (str): Name/title of the list\n        color (Literal['berry-red', 'pumpkin-orange', 'lagoon-blue', 'pink-tulip', 'light-mud', 'orange-peel', 'bright-moss', 'antique-blue', 'dark-granite', 'turquoise-sea'] | None): Color for the list\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.patch(f\"api/lists/{id}\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateList(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateList(boardId)","title":"<code>boardId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateList(type)","title":"<code>type</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateList(position)","title":"<code>position</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateList(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateList(color)","title":"<code>color</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateNotification","title":"updateNotification","text":"<pre><code>updateNotification(id: str, **kwargs: Unpack[Request_updateNotification]) -&gt; Response_updateNotification\n</code></pre> <p>Updates a notification. Users can only update their own notifications.</p> PARAMETER DESCRIPTION <p>ID of the notification to update)</p> <p> TYPE: <code>str</code> </p> <p>Whether the notification has been read</p> <p> TYPE: <code>bool</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def updateNotification(self, id: str, **kwargs: Unpack[Request_updateNotification]) -&gt; Response_updateNotification:\n    \"\"\"Updates a notification. Users can only update their own notifications.\n\n    Args:\n        id (str): ID of the notification to update)\n        isRead (bool): Whether the notification has been read\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.patch(f\"api/notifications/{id}\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateNotification(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateNotification(isRead)","title":"<code>isRead</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateNotificationService","title":"updateNotificationService","text":"<pre><code>updateNotificationService(id: str, **kwargs: Unpack[Request_updateNotificationService]) -&gt; Response_updateNotificationService\n</code></pre> <p>Updates a notification service. Users can update their own services, project managers can update board services.</p> PARAMETER DESCRIPTION <p>ID of the notification service to update)</p> <p> TYPE: <code>str</code> </p> <p>URL endpoint for notifications</p> <p> TYPE: <code>str</code> </p> <p>Format for notification messages</p> <p> TYPE: <code>Literal[text, markdown, html]</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def updateNotificationService(self, id: str, **kwargs: Unpack[Request_updateNotificationService]) -&gt; Response_updateNotificationService:\n    \"\"\"Updates a notification service. Users can update their own services, project managers can update board services.\n\n    Args:\n        id (str): ID of the notification service to update)\n        url (str): URL endpoint for notifications\n        format (Literal['text', 'markdown', 'html']): Format for notification messages\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.patch(f\"api/notification-services/{id}\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateNotificationService(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateNotificationService(url)","title":"<code>url</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateNotificationService(format)","title":"<code>format</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateProject","title":"updateProject","text":"<pre><code>updateProject(id: str, **kwargs: Unpack[Request_updateProject]) -&gt; Response_updateProject\n</code></pre> <p>Updates a project. Accessible fields depend on user permissions.</p> PARAMETER DESCRIPTION <p>ID of the project to update)</p> <p> TYPE: <code>str</code> </p> <p>ID of the project manager who owns the project</p> <p> TYPE: <code>str | None</code> </p> <p>ID of the background image used as background</p> <p> TYPE: <code>str | None</code> </p> <p>Name/title of the project</p> <p> TYPE: <code>str</code> </p> <p>Detailed description of the project</p> <p> TYPE: <code>str | None</code> </p> <p>Type of background for the project</p> <p> TYPE: <code>Literal[gradient, image] | None</code> </p> <p>Gradient background for the project</p> <p> TYPE: <code>Literal[old - lime, ocean - dive, tzepesch - style, jungle - mesh, strawberry - dust, purple - rose, sun - scream, warm - rust, sky - change, green - eyes, blue - xchange, blood - orange, sour - peel, green - ninja, algae - green, coral - reef, steel - grey, heat - waves, velvet - lounge, purple - rain, blue - steel, blueish - curve, prism - light, green - mist, red - curtain] | None</code> </p> <p>Whether the project is hidden</p> <p> TYPE: <code>bool</code> </p> <p>Whether the project is marked as favorite by the current user</p> <p> TYPE: <code>bool</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404 </p> <code>Conflict</code> <p>409 </p> <code>UnprocessableEntity</code> <p>422</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def updateProject(self, id: str, **kwargs: Unpack[Request_updateProject]) -&gt; Response_updateProject:\n    \"\"\"Updates a project. Accessible fields depend on user permissions.\n\n    Args:\n        id (str): ID of the project to update)\n        ownerProjectManagerId (str | None): ID of the project manager who owns the project\n        backgroundImageId (str | None): ID of the background image used as background\n        name (str): Name/title of the project\n        description (str | None): Detailed description of the project\n        backgroundType (Literal['gradient', 'image'] | None): Type of background for the project\n        backgroundGradient (Literal['old-lime', 'ocean-dive', 'tzepesch-style', 'jungle-mesh', 'strawberry-dust', 'purple-rose', 'sun-scream', 'warm-rust', 'sky-change', 'green-eyes', 'blue-xchange', 'blood-orange', 'sour-peel', 'green-ninja', 'algae-green', 'coral-reef', 'steel-grey', 'heat-waves', 'velvet-lounge', 'purple-rain', 'blue-steel', 'blueish-curve', 'prism-light', 'green-mist', 'red-curtain'] | None): Gradient background for the project\n        isHidden (bool): Whether the project is hidden\n        isFavorite (bool): Whether the project is marked as favorite by the current user\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n        Conflict: 409 \n        UnprocessableEntity: 422 \n    \"\"\"\n    resp = self.client.patch(f\"api/projects/{id}\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateProject(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateProject(ownerProjectManagerId)","title":"<code>ownerProjectManagerId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateProject(backgroundImageId)","title":"<code>backgroundImageId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateProject(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateProject(description)","title":"<code>description</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateProject(backgroundType)","title":"<code>backgroundType</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateProject(backgroundGradient)","title":"<code>backgroundGradient</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateProject(isHidden)","title":"<code>isHidden</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateProject(isFavorite)","title":"<code>isFavorite</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateTask","title":"updateTask","text":"<pre><code>updateTask(id: str, **kwargs: Unpack[Request_updateTask]) -&gt; Response_updateTask\n</code></pre> <p>Updates a task. Linked card tasks have limited update options. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the task to update)</p> <p> TYPE: <code>str</code> </p> <p>ID of the task list to move the task to</p> <p> TYPE: <code>str</code> </p> <p>ID of the user assigned to the task (null to unassign)</p> <p> TYPE: <code>str | None</code> </p> <p>Position of the task within the task list</p> <p> TYPE: <code>int</code> </p> <p>Name/title of the task</p> <p> TYPE: <code>str</code> </p> <p>Whether the task is completed</p> <p> TYPE: <code>bool</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def updateTask(self, id: str, **kwargs: Unpack[Request_updateTask]) -&gt; Response_updateTask:\n    \"\"\"Updates a task. Linked card tasks have limited update options. Requires board editor permissions.\n\n    Args:\n        id (str): ID of the task to update)\n        taskListId (str): ID of the task list to move the task to\n        assigneeUserId (str | None): ID of the user assigned to the task (null to unassign)\n        position (int): Position of the task within the task list\n        name (str): Name/title of the task\n        isCompleted (bool): Whether the task is completed\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.patch(f\"api/tasks/{id}\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateTask(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateTask(taskListId)","title":"<code>taskListId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateTask(assigneeUserId)","title":"<code>assigneeUserId</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateTask(position)","title":"<code>position</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateTask(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateTask(isCompleted)","title":"<code>isCompleted</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateTaskList","title":"updateTaskList","text":"<pre><code>updateTaskList(id: str, **kwargs: Unpack[Request_updateTaskList]) -&gt; Response_updateTaskList\n</code></pre> <p>Updates a task list. Requires board editor permissions.</p> PARAMETER DESCRIPTION <p>ID of the task list to update)</p> <p> TYPE: <code>str</code> </p> <p>Position of the task list within the card</p> <p> TYPE: <code>int</code> </p> <p>Name/title of the task list</p> <p> TYPE: <code>str</code> </p> <p>Whether to show the task list on the front of the card</p> <p> TYPE: <code>bool</code> </p> <p>Whether to hide completed tasks</p> <p> TYPE: <code>bool</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def updateTaskList(self, id: str, **kwargs: Unpack[Request_updateTaskList]) -&gt; Response_updateTaskList:\n    \"\"\"Updates a task list. Requires board editor permissions.\n\n    Args:\n        id (str): ID of the task list to update)\n        position (int): Position of the task list within the card\n        name (str): Name/title of the task list\n        showOnFrontOfCard (bool): Whether to show the task list on the front of the card\n        hideCompletedTasks (bool): Whether to hide completed tasks\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.patch(f\"api/task-lists/{id}\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateTaskList(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateTaskList(position)","title":"<code>position</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateTaskList(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateTaskList(showOnFrontOfCard)","title":"<code>showOnFrontOfCard</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateTaskList(hideCompletedTasks)","title":"<code>hideCompletedTasks</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUser","title":"updateUser","text":"<pre><code>updateUser(id: str, **kwargs: Unpack[Request_updateUser]) -&gt; Response_updateUser\n</code></pre> <p>Updates a user. Users can update their own profile, admins can update any user.</p> PARAMETER DESCRIPTION <p>ID of the user to update)</p> <p> TYPE: <code>str</code> </p> <p>User role defining access permissions</p> <p> TYPE: <code>Literal[admin, projectOwner, boardUser]</code> </p> <p>Full display name of the user</p> <p> TYPE: <code>str</code> </p> <p>Avatar of the user (only null value to remove avatar)</p> <p> TYPE: <code>dict[str, Any] | None</code> </p> <p>Contact phone number</p> <p> TYPE: <code>str | None</code> </p> <p>Organization or company name</p> <p> TYPE: <code>str | None</code> </p> <p>Preferred language for user interface and notifications</p> <p> TYPE: <code>Literal[ar - YE, bg - BG, cs - CZ, da - DK, de - DE, el - GR, en - GB, en - US, es - ES, et - EE, fa - IR, fi - FI, fr - FR, hu - HU, id - ID, it - IT, ja - JP, ko - KR, nl - NL, pl - PL, pt - BR, pt - PT, ro - RO, ru - RU, sk - SK, sr - Cyrl - RS, sr - Latn - RS, sv - SE, tr - TR, uk - UA, uz - UZ, zh - CN, zh - TW] | None</code> </p> <p>Whether the user subscribes to their own cards</p> <p> TYPE: <code>bool</code> </p> <p>Whether the user subscribes to cards when commenting</p> <p> TYPE: <code>bool</code> </p> <p>Whether recent card highlighting is disabled</p> <p> TYPE: <code>bool</code> </p> <p>Whether favorites are enabled by default</p> <p> TYPE: <code>bool</code> </p> <p>Default markdown editor mode</p> <p> TYPE: <code>Literal[wysiwyg, markup]</code> </p> <p>Default view mode for the home page</p> <p> TYPE: <code>Literal[gridProjects, groupedProjects]</code> </p> <p>Default sort order for projects display</p> <p> TYPE: <code>Literal[byDefault, alphabetically, byCreationTime]</code> </p> <p>Whether the user account is deactivated and cannot log in (for admins)</p> <p> TYPE: <code>bool</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404 </p> <code>Conflict</code> <p>409</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def updateUser(self, id: str, **kwargs: Unpack[Request_updateUser]) -&gt; Response_updateUser:\n    \"\"\"Updates a user. Users can update their own profile, admins can update any user.\n\n    Args:\n        id (str): ID of the user to update)\n        role (Literal['admin', 'projectOwner', 'boardUser']): User role defining access permissions\n        name (str): Full display name of the user\n        avatar (dict[str, Any] | None): Avatar of the user (only null value to remove avatar)\n        phone (str | None): Contact phone number\n        organization (str | None): Organization or company name\n        language (Literal['ar-YE', 'bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-GB', 'en-US', 'es-ES', 'et-EE', 'fa-IR', 'fi-FI', 'fr-FR', 'hu-HU', 'id-ID', 'it-IT', 'ja-JP', 'ko-KR', 'nl-NL', 'pl-PL', 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sk-SK', 'sr-Cyrl-RS', 'sr-Latn-RS', 'sv-SE', 'tr-TR', 'uk-UA', 'uz-UZ', 'zh-CN', 'zh-TW'] | None): Preferred language for user interface and notifications\n        subscribeToOwnCards (bool): Whether the user subscribes to their own cards\n        subscribeToCardWhenCommenting (bool): Whether the user subscribes to cards when commenting\n        turnOffRecentCardHighlighting (bool): Whether recent card highlighting is disabled\n        enableFavoritesByDefault (bool): Whether favorites are enabled by default\n        defaultEditorMode (Literal['wysiwyg', 'markup']): Default markdown editor mode\n        defaultHomeView (Literal['gridProjects', 'groupedProjects']): Default view mode for the home page\n        defaultProjectsOrder (Literal['byDefault', 'alphabetically', 'byCreationTime']): Default sort order for projects display\n        isDeactivated (bool): Whether the user account is deactivated and cannot log in (for admins)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n        Conflict: 409 \n    \"\"\"\n    resp = self.client.patch(f\"api/users/{id}\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUser(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUser(role)","title":"<code>role</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUser(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUser(avatar)","title":"<code>avatar</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUser(phone)","title":"<code>phone</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUser(organization)","title":"<code>organization</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUser(language)","title":"<code>language</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUser(subscribeToOwnCards)","title":"<code>subscribeToOwnCards</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUser(subscribeToCardWhenCommenting)","title":"<code>subscribeToCardWhenCommenting</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUser(turnOffRecentCardHighlighting)","title":"<code>turnOffRecentCardHighlighting</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUser(enableFavoritesByDefault)","title":"<code>enableFavoritesByDefault</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUser(defaultEditorMode)","title":"<code>defaultEditorMode</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUser(defaultHomeView)","title":"<code>defaultHomeView</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUser(defaultProjectsOrder)","title":"<code>defaultProjectsOrder</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUser(isDeactivated)","title":"<code>isDeactivated</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUserAvatar","title":"updateUserAvatar","text":"<pre><code>updateUserAvatar(id: str, mime_type: str | None = None, **kwargs: Unpack[Request_updateUserAvatar]) -&gt; Response_updateUserAvatar\n</code></pre> <p>Updates a user's avatar image. Users can update their own avatar, admins can update any user's avatar.</p> PARAMETER DESCRIPTION <p>ID of the user whose avatar to update)</p> <p> TYPE: <code>str</code> </p> <p>Optional mime type for file upload</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <p>Avatar image file (must be an image format)</p> <p> TYPE: <code>bytes</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404 </p> <code>UnprocessableEntity</code> <p>422</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def updateUserAvatar(self, id: str, mime_type: str | None=None ,**kwargs: Unpack[Request_updateUserAvatar]) -&gt; Response_updateUserAvatar:\n    \"\"\"Updates a user's avatar image. Users can update their own avatar, admins can update any user's avatar.\n\n    Args:\n        id (str): ID of the user whose avatar to update)\n        mime_type (str): Optional mime type for file upload\n        file (bytes): Avatar image file (must be an image format)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n        UnprocessableEntity: 422 \n    \"\"\"\n    resp = self.client.post(f\"api/users/{id}/avatar\", \n        files={'file': ('avatar', kwargs['file'], mime_type)}, \n    )\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUserAvatar(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUserAvatar(mime_type)","title":"<code>mime_type</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUserAvatar(file)","title":"<code>file</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUserEmail","title":"updateUserEmail","text":"<pre><code>updateUserEmail(id: str, **kwargs: Unpack[Request_updateUserEmail]) -&gt; Response_updateUserEmail\n</code></pre> <p>Updates a user's email address. Users must provide current password when updating their own email. Admins can update any user's email without a password.</p> PARAMETER DESCRIPTION <p>ID of the user whose email to update)</p> <p> TYPE: <code>str</code> </p> <p>Email address for login and notifications</p> <p> TYPE: <code>str</code> </p> <p>Current password (required when updating own email)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404 </p> <code>Conflict</code> <p>409</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def updateUserEmail(self, id: str, **kwargs: Unpack[Request_updateUserEmail]) -&gt; Response_updateUserEmail:\n    \"\"\"Updates a user's email address. Users must provide current password when updating their own email. Admins can update any user's email without a password.\n\n    Args:\n        id (str): ID of the user whose email to update)\n        email (str): Email address for login and notifications\n        currentPassword (str): Current password (required when updating own email)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n        Conflict: 409 \n    \"\"\"\n    resp = self.client.patch(f\"api/users/{id}/email\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUserEmail(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUserEmail(email)","title":"<code>email</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUserEmail(currentPassword)","title":"<code>currentPassword</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUserPassword","title":"updateUserPassword","text":"<pre><code>updateUserPassword(id: str, **kwargs: Unpack[Request_updateUserPassword]) -&gt; Response_updateUserPassword\n</code></pre> <p>Updates a user's password. Users must provide a current password when updating their own password. Admins can update any user's password without the current password. Returns a new access token when updating own password.</p> PARAMETER DESCRIPTION <p>ID of the user whose password to update)</p> <p> TYPE: <code>str</code> </p> <p>Password (must meet password requirements)</p> <p> TYPE: <code>str</code> </p> <p>Current password (required when updating own password)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def updateUserPassword(self, id: str, **kwargs: Unpack[Request_updateUserPassword]) -&gt; Response_updateUserPassword:\n    \"\"\"Updates a user's password. Users must provide a current password when updating their own password. Admins can update any user's password without the current password. Returns a new access token when updating own password.\n\n    Args:\n        id (str): ID of the user whose password to update)\n        password (str): Password (must meet password requirements)\n        currentPassword (str): Current password (required when updating own password)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.patch(f\"api/users/{id}/password\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUserPassword(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUserPassword(password)","title":"<code>password</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUserPassword(currentPassword)","title":"<code>currentPassword</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUserUsername","title":"updateUserUsername","text":"<pre><code>updateUserUsername(id: str, **kwargs: Unpack[Request_updateUserUsername]) -&gt; Response_updateUserUsername\n</code></pre> <p>Updates a user's username. Users must provide a current password when updating their own username (unless they are SSO users with <code>oidcIgnoreUsername</code> enabled). Admins can update any user's username without the current password.</p> PARAMETER DESCRIPTION <p>ID of the user whose username to update)</p> <p> TYPE: <code>str</code> </p> <p>Unique username for user identification</p> <p> TYPE: <code>str | None</code> </p> <p>Current password (required when updating own username)</p> <p> TYPE: <code>str</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>Forbidden</code> <p>403 </p> <code>NotFound</code> <p>404 </p> <code>Conflict</code> <p>409</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def updateUserUsername(self, id: str, **kwargs: Unpack[Request_updateUserUsername]) -&gt; Response_updateUserUsername:\n    \"\"\"Updates a user's username. Users must provide a current password when updating their own username (unless they are SSO users with `oidcIgnoreUsername` enabled). Admins can update any user's username without the current password.\n\n    Args:\n        id (str): ID of the user whose username to update)\n        username (str | None): Unique username for user identification\n        currentPassword (str): Current password (required when updating own username)\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        Forbidden: 403 \n        NotFound: 404 \n        Conflict: 409 \n    \"\"\"\n    resp = self.client.patch(f\"api/users/{id}/username\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUserUsername(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUserUsername(username)","title":"<code>username</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateUserUsername(currentPassword)","title":"<code>currentPassword</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateWebhook","title":"updateWebhook","text":"<pre><code>updateWebhook(id: str, **kwargs: Unpack[Request_updateWebhook]) -&gt; Response_updateWebhook\n</code></pre> <p>Updates a webhook. Requires admin privileges.</p> PARAMETER DESCRIPTION <p>ID of the webhook to update)</p> <p> TYPE: <code>str</code> </p> <p>Name/title of the webhook</p> <p> TYPE: <code>str</code> </p> <p>URL endpoint for the webhook</p> <p> TYPE: <code>str</code> </p> <p>Access token for webhook authentication</p> <p> TYPE: <code>str | None</code> </p> <p>Comma-separated list of events that trigger the webhook</p> <p> TYPE: <code>str | None</code> </p> <p>Comma-separated list of events excluded from the webhook</p> <p> TYPE: <code>str | None</code> </p> Note <p>All status errors are instances of <code>httpx.HTTPStatusError</code> at runtime (<code>response.raise_for_status()</code>).  If a matching PlankaError exists, it will be raised (see <code>api.errors</code>)  Planka internal status codes and names are included here for disambiguation</p> RAISES DESCRIPTION <code>ValidationError</code> <p>400 </p> <code>Unauthorized</code> <p>401 </p> <code>NotFound</code> <p>404</p> Source code in <code>src/plankapy/v2/api/paths.py</code> <pre><code>def updateWebhook(self, id: str, **kwargs: Unpack[Request_updateWebhook]) -&gt; Response_updateWebhook:\n    \"\"\"Updates a webhook. Requires admin privileges.\n\n    Args:\n        id (str): ID of the webhook to update)\n        name (str): Name/title of the webhook\n        url (str): URL endpoint for the webhook\n        accessToken (str | None): Access token for webhook authentication\n        events (str | None): Comma-separated list of events that trigger the webhook\n        excludedEvents (str | None): Comma-separated list of events excluded from the webhook\n\n    Note:\n        All status errors are instances of `httpx.HTTPStatusError` at runtime (`response.raise_for_status()`). \n        If a matching PlankaError exists, it will be raised (see `api.errors`) \n        Planka internal status codes and names are included here for disambiguation\n\n    Raises:\n        ValidationError: 400 \n        Unauthorized: 401 \n        NotFound: 404 \n    \"\"\"\n    resp = self.client.patch(f\"api/webhooks/{id}\", json=kwargs)\n    raise_planka_err(resp)\n    return resp.json()\n</code></pre>"},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateWebhook(id)","title":"<code>id</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateWebhook(name)","title":"<code>name</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateWebhook(url)","title":"<code>url</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateWebhook(accessToken)","title":"<code>accessToken</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateWebhook(events)","title":"<code>events</code>","text":""},{"location":"v2/api/paths/#plankapy.v2.api.paths.PlankaEndpoints.updateWebhook(excludedEvents)","title":"<code>excludedEvents</code>","text":""},{"location":"v2/api/rest-typing/","title":"REST Typing","text":"<p>All Planka API endpoints habe their request/response body typed here using <code>TypedDict</code>. This means that at runtime all  objects here are <code>dict</code> objects, but can be statically analyzed by a type checker. </p> CLASS DESCRIPTION <code>Action</code> <code>Attachment</code> <code>BackgroundImage</code> <code>BaseCustomFieldGroup</code> <code>Board</code> <code>BoardMembership</code> <code>Card</code> <code>CardLabel</code> <code>CardMembership</code> <code>Comment</code> <code>Config</code> <code>CustomField</code> <code>CustomFieldGroup</code> <code>CustomFieldValue</code> <code>Included_createBoard</code> <code>Included_createProject</code> <code>Included_deleteList</code> <code>Included_duplicateCard</code> <code>Included_getBoard</code> <code>Included_getBoardActions</code> <code>Included_getBoard_all</code> <code>Included_getCard</code> <code>Included_getCardActions</code> <code>Included_getCards</code> <code>Included_getComments</code> <code>Included_getCustomFieldGroup</code> <code>Included_getList</code> <code>Included_getList_all</code> <code>Included_getNotification</code> <code>Included_getNotifications</code> <code>Included_getProject</code> <code>Included_getProjects</code> <code>Included_getTaskList</code> <code>Included_getUser</code> <code>Included_moveListCards</code> <code>Included_readCardNotifications</code> <code>Included_sortList</code> <code>Included_updateUserPassword</code> <code>Item_getBoard</code> <code>Item_getCard</code> <code>Item_getProject</code> <code>Item_getTerms</code> <code>Items_getCards</code> <code>Items_getProjects</code> <code>Label</code> <code>List</code> <code>Notification</code> <code>NotificationService</code> <code>Project</code> <code>ProjectManager</code> <code>Request_acceptTerms</code> <code>Request_createAccessToken</code> <code>Request_createAttachment</code> <code>Request_createBackgroundImage</code> <code>Request_createBaseCustomFieldGroup</code> <code>Request_createBoard</code> <code>Request_createBoardCustomFieldGroup</code> <code>Request_createBoardMembership</code> <code>Request_createBoardNotificationService</code> <code>Request_createCard</code> <code>Request_createCardCustomFieldGroup</code> <code>Request_createCardLabel</code> <code>Request_createCardMembership</code> <code>Request_createComment</code> <code>Request_createCustomFieldInBaseGroup</code> <code>Request_createCustomFieldInGroup</code> <code>Request_createLabel</code> <code>Request_createList</code> <code>Request_createProject</code> <code>Request_createProjectManager</code> <code>Request_createTask</code> <code>Request_createTaskList</code> <code>Request_createUser</code> <code>Request_createUserNotificationService</code> <code>Request_createWebhook</code> <code>Request_duplicateCard</code> <code>Request_exchangeForAccessTokenWithOidc</code> <code>Request_getBoard</code> <code>Request_getBoardActions</code> <code>Request_getCardActions</code> <code>Request_getCards</code> <code>Request_getComments</code> <code>Request_getTerms</code> <code>Request_getUser</code> <code>Request_moveListCards</code> <code>Request_revokePendingToken</code> <code>Request_sortList</code> <code>Request_updateAttachment</code> <code>Request_updateBaseCustomFieldGroup</code> <code>Request_updateBoard</code> <code>Request_updateBoardMembership</code> <code>Request_updateCard</code> <code>Request_updateComments</code> <code>Request_updateCustomField</code> <code>Request_updateCustomFieldGroup</code> <code>Request_updateCustomFieldValue</code> <code>Request_updateLabel</code> <code>Request_updateList</code> <code>Request_updateNotification</code> <code>Request_updateNotificationService</code> <code>Request_updateProject</code> <code>Request_updateTask</code> <code>Request_updateTaskList</code> <code>Request_updateUser</code> <code>Request_updateUserAvatar</code> <code>Request_updateUserEmail</code> <code>Request_updateUserPassword</code> <code>Request_updateUserUsername</code> <code>Request_updateWebhook</code> <code>Response_acceptTerms</code> <p>Terms accepted successfully</p> <code>Response_clearList</code> <p>List cleared successfully</p> <code>Response_createAccessToken</code> <p>Login successful</p> <code>Response_createAttachment</code> <p>Attachment created successfully</p> <code>Response_createBackgroundImage</code> <p>Background image uploaded successfully</p> <code>Response_createBaseCustomFieldGroup</code> <p>Base custom field group created successfully</p> <code>Response_createBoard</code> <p>Board created successfully</p> <code>Response_createBoardCustomFieldGroup</code> <p>Custom field group created successfully</p> <code>Response_createBoardMembership</code> <p>Board membership created successfully</p> <code>Response_createBoardNotificationService</code> <p>Notification service created successfully</p> <code>Response_createCard</code> <p>Card created successfully</p> <code>Response_createCardCustomFieldGroup</code> <p>Custom field group created successfully</p> <code>Response_createCardLabel</code> <p>Label added to card successfully</p> <code>Response_createCardMembership</code> <p>User added to card successfully</p> <code>Response_createComment</code> <p>Comment created successfully</p> <code>Response_createCustomFieldInBaseGroup</code> <p>Custom field created successfully</p> <code>Response_createCustomFieldInGroup</code> <p>Custom field created successfully</p> <code>Response_createLabel</code> <p>Label created successfully</p> <code>Response_createList</code> <p>List created successfully</p> <code>Response_createProject</code> <p>Project created successfully</p> <code>Response_createProjectManager</code> <p>Project manager created successfully</p> <code>Response_createTask</code> <p>Task created successfully</p> <code>Response_createTaskList</code> <p>Task list created successfully</p> <code>Response_createUser</code> <p>User created successfully</p> <code>Response_createUserNotificationService</code> <p>Notification service created successfully</p> <code>Response_createWebhook</code> <p>Webhook created successfully</p> <code>Response_deleteAccessToken</code> <p>Logout successful</p> <code>Response_deleteAttachment</code> <p>Attachment deleted successfully</p> <code>Response_deleteBackgroundImage</code> <p>Background image deleted successfully</p> <code>Response_deleteBaseCustomFieldGroup</code> <p>Base custom field group deleted successfully</p> <code>Response_deleteBoard</code> <p>Board deleted successfully</p> <code>Response_deleteBoardMembership</code> <p>Board membership deleted successfully</p> <code>Response_deleteCard</code> <p>Card deleted successfully</p> <code>Response_deleteCardLabel</code> <p>Label removed from card successfully</p> <code>Response_deleteCardMembership</code> <p>User removed from card successfully</p> <code>Response_deleteComment</code> <p>Comment deleted successfully</p> <code>Response_deleteCustomField</code> <p>Custom field deleted successfully</p> <code>Response_deleteCustomFieldGroup</code> <p>Custom field group deleted successfully</p> <code>Response_deleteCustomFieldValue</code> <p>Custom field value deleted successfully</p> <code>Response_deleteLabel</code> <p>Label deleted successfully</p> <code>Response_deleteList</code> <p>List deleted successfully</p> <code>Response_deleteNotificationService</code> <p>Notification service deleted successfully</p> <code>Response_deleteProject</code> <p>Project deleted successfully</p> <code>Response_deleteProjectManager</code> <p>Project manager deleted successfully</p> <code>Response_deleteTask</code> <p>Task deleted successfully</p> <code>Response_deleteTaskList</code> <p>Task list deleted successfully</p> <code>Response_deleteUser</code> <p>User deleted successfully</p> <code>Response_deleteWebhook</code> <p>Webhook deleted successfully</p> <code>Response_duplicateCard</code> <p>Card duplicated successfully</p> <code>Response_exchangeForAccessTokenWithOidc</code> <p>OIDC exchange successful</p> <code>Response_getBoard</code> <p>Board details retrieved successfully</p> <code>Response_getBoardActions</code> <p>Board actions retrieved successfully</p> <code>Response_getCard</code> <p>Card details retrieved successfully</p> <code>Response_getCardActions</code> <p>Card actions retrieved successfully</p> <code>Response_getCards</code> <p>Cards retrieved successfully</p> <code>Response_getComments</code> <p>Comments retrieved successfully</p> <code>Response_getConfig</code> <p>Configuration retrieved successfully</p> <code>Response_getCustomFieldGroup</code> <p>Custom field group details retrieved successfully</p> <code>Response_getList</code> <p>List details retrieved successfully</p> <code>Response_getNotification</code> <p>Notification details retrieved successfully</p> <code>Response_getNotifications</code> <p>Notifications retrieved successfully</p> <code>Response_getProject</code> <p>Project details retrieved successfully</p> <code>Response_getProjects</code> <p>Projects retrieved successfully</p> <code>Response_getTaskList</code> <p>Task list details retrieved successfully</p> <code>Response_getTerms</code> <p>Terms content retrieved successfully</p> <code>Response_getUser</code> <p>User details retrieved successfully</p> <code>Response_getUsers</code> <p>List of users retrieved successfully</p> <code>Response_getWebhooks</code> <p>List of webhooks retrieved successfully</p> <code>Response_moveListCards</code> <p>Cards moved successfully</p> <code>Response_readAllNotifications</code> <p>Notifications marked as read successfully</p> <code>Response_readCardNotifications</code> <p>Notifications marked as read successfully</p> <code>Response_revokePendingToken</code> <p>Pending token revoked successfully</p> <code>Response_sortList</code> <p>List sorted successfully</p> <code>Response_testNotificationService</code> <p>Test notification sent successfully</p> <code>Response_updateAttachment</code> <p>Attachment updated successfully</p> <code>Response_updateBaseCustomFieldGroup</code> <p>Base custom field group updated successfully</p> <code>Response_updateBoard</code> <p>Board updated successfully</p> <code>Response_updateBoardMembership</code> <p>Board membership updated successfully</p> <code>Response_updateCard</code> <p>Card updated successfully</p> <code>Response_updateComments</code> <p>Comment updated successfully</p> <code>Response_updateCustomField</code> <p>Custom field updated successfully</p> <code>Response_updateCustomFieldGroup</code> <p>Custom field group updated successfully</p> <code>Response_updateCustomFieldValue</code> <p>Custom field value created or updated successfully</p> <code>Response_updateLabel</code> <p>Label updated successfully</p> <code>Response_updateList</code> <p>List updated successfully</p> <code>Response_updateNotification</code> <p>Notification updated successfully</p> <code>Response_updateNotificationService</code> <p>Notification service updated successfully</p> <code>Response_updateProject</code> <p>Project updated successfully</p> <code>Response_updateTask</code> <p>Task updated successfully</p> <code>Response_updateTaskList</code> <p>Task list updated successfully</p> <code>Response_updateUser</code> <p>User updated successfully</p> <code>Response_updateUserAvatar</code> <p>Avatar updated successfully</p> <code>Response_updateUserEmail</code> <p>Email updated successfully</p> <code>Response_updateUserPassword</code> <p>Password updated successfully</p> <code>Response_updateUserUsername</code> <p>Username updated successfully</p> <code>Response_updateWebhook</code> <p>Webhook updated successfully</p> <code>Stopwatch</code> <code>Task</code> <code>TaskList</code> <code>User</code> <code>Webhook</code>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Action","title":"Action","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0actions </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_moveListCards <code></code>\u00a0actions </li> <li> <code></code>\u00a0Response_getBoardActions <code></code>\u00a0items </li> <li> <code></code>\u00a0Response_getCardActions <code></code>\u00a0items </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Action <code></code>\u00a0Action </li> </ul> ATTRIBUTE DESCRIPTION <code>boardId</code> <p>ID of the board where the action occurred</p> <p> TYPE: <code>str</code> </p> <code>cardId</code> <p>ID of the card where the action occurred</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the action was created</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>Action specific data (varies by type)</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>id</code> <p>Unique identifier for the action</p> <p> TYPE: <code>str</code> </p> <code>type</code> <p>Type of the action</p> <p> TYPE: <code>Literal['createCard', 'moveCard', 'addMemberToCard', 'removeMemberFromCard', 'completeTask', 'uncompleteTask']</code> </p> <code>updatedAt</code> <p>When the action was last updated</p> <p> TYPE: <code>str</code> </p> <code>userId</code> <p>ID of the user who performed the action</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Action.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: str\n</code></pre> <p>ID of the board where the action occurred</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Action.cardId","title":"cardId  <code>instance-attribute</code>","text":"<pre><code>cardId: str\n</code></pre> <p>ID of the card where the action occurred</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Action.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the action was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Action.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: dict[str, Any]\n</code></pre> <p>Action specific data (varies by type)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Action.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the action</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Action.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['createCard', 'moveCard', 'addMemberToCard', 'removeMemberFromCard', 'completeTask', 'uncompleteTask']\n</code></pre> <p>Type of the action</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Action.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the action was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Action.userId","title":"userId  <code>instance-attribute</code>","text":"<pre><code>userId: str\n</code></pre> <p>ID of the user who performed the action</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Attachment","title":"Attachment","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <ul> <li> <code></code>\u00a0Included_duplicateCard <code></code>\u00a0attachments </li> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0attachments </li> <li> <code></code>\u00a0Included_getCard <code></code>\u00a0attachments </li> <li> <code></code>\u00a0Included_getCards <code></code>\u00a0attachments </li> <li> <code></code>\u00a0Included_getList <code></code>\u00a0attachments </li> <li> <code></code>\u00a0Response_createAttachment <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteAttachment <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateAttachment <code></code>\u00a0item </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Attachment <code></code>\u00a0Attachment </li> </ul> ATTRIBUTE DESCRIPTION <code>cardId</code> <p>ID of the card the attachment belongs to</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the attachment was created</p> <p> TYPE: <code>str</code> </p> <code>creatorUserId</code> <p>ID of the user who created the attachment</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>Attachment specific data (varies by type)</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>id</code> <p>Unique identifier for the attachment</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the attachment</p> <p> TYPE: <code>str</code> </p> <code>type</code> <p>Type of the attachment</p> <p> TYPE: <code>Literal['file', 'link']</code> </p> <code>updatedAt</code> <p>When the attachment was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Attachment.cardId","title":"cardId  <code>instance-attribute</code>","text":"<pre><code>cardId: str\n</code></pre> <p>ID of the card the attachment belongs to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Attachment.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the attachment was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Attachment.creatorUserId","title":"creatorUserId  <code>instance-attribute</code>","text":"<pre><code>creatorUserId: str\n</code></pre> <p>ID of the user who created the attachment</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Attachment.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: dict[str, Any]\n</code></pre> <p>Attachment specific data (varies by type)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Attachment.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the attachment</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Attachment.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the attachment</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Attachment.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['file', 'link']\n</code></pre> <p>Type of the attachment</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Attachment.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the attachment was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.BackgroundImage","title":"BackgroundImage","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <ul> <li> <code></code>\u00a0Included_getProject <code></code>\u00a0backgroundImages </li> <li> <code></code>\u00a0Included_getProjects <code></code>\u00a0backgroundImages </li> <li> <code></code>\u00a0Response_createBackgroundImage <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteBackgroundImage <code></code>\u00a0item </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Background Image <code></code>\u00a0BackgroundImage </li> </ul> ATTRIBUTE DESCRIPTION <code>createdAt</code> <p>When the background image was created</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the background image</p> <p> TYPE: <code>str</code> </p> <code>projectId</code> <p>ID of the project the background image belongs to</p> <p> TYPE: <code>str</code> </p> <code>sizeInBytes</code> <p>File size of the background image in bytes</p> <p> TYPE: <code>str</code> </p> <code>thumbnailUrls</code> <p>URLs for different thumbnail sizes of the background image</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>updatedAt</code> <p>When the background image was last updated</p> <p> TYPE: <code>str</code> </p> <code>url</code> <p>URL to access the full-size background image</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.BackgroundImage.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the background image was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.BackgroundImage.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the background image</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.BackgroundImage.projectId","title":"projectId  <code>instance-attribute</code>","text":"<pre><code>projectId: str\n</code></pre> <p>ID of the project the background image belongs to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.BackgroundImage.sizeInBytes","title":"sizeInBytes  <code>instance-attribute</code>","text":"<pre><code>sizeInBytes: str\n</code></pre> <p>File size of the background image in bytes</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.BackgroundImage.thumbnailUrls","title":"thumbnailUrls  <code>instance-attribute</code>","text":"<pre><code>thumbnailUrls: dict[str, Any]\n</code></pre> <p>URLs for different thumbnail sizes of the background image</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.BackgroundImage.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the background image was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.BackgroundImage.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre> <p>URL to access the full-size background image</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.BaseCustomFieldGroup","title":"BaseCustomFieldGroup","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0base_custom_field_groups </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_getProject <code></code>\u00a0baseCustomFieldGroups </li> <li> <code></code>\u00a0Included_getProjects <code></code>\u00a0baseCustomFieldGroups </li> <li> <code></code>\u00a0Response_createBaseCustomFieldGroup <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteBaseCustomFieldGroup <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateBaseCustomFieldGroup <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Base Custom Field Group <code></code>\u00a0BaseCustomFieldGroup </li> </ul> ATTRIBUTE DESCRIPTION <code>createdAt</code> <p>When the base custom field group was created</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the base custom field group</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the base custom field group</p> <p> TYPE: <code>str</code> </p> <code>projectId</code> <p>ID of the project the base custom field group belongs to</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the base custom field group was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.BaseCustomFieldGroup.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the base custom field group was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.BaseCustomFieldGroup.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the base custom field group</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.BaseCustomFieldGroup.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the base custom field group</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.BaseCustomFieldGroup.projectId","title":"projectId  <code>instance-attribute</code>","text":"<pre><code>projectId: str\n</code></pre> <p>ID of the project the base custom field group belongs to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.BaseCustomFieldGroup.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the base custom field group was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Board","title":"Board","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0boards </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_getProject <code></code>\u00a0boards </li> <li> <code></code>\u00a0Included_getProjects <code></code>\u00a0boards </li> <li> <code></code>\u00a0Response_createBoard <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteBoard <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateBoard <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 <ul> <li> models Board <code></code>\u00a0Board </li> <li> api REST Typing <code></code>\u00a0Item_getBoard </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>alwaysDisplayCardCreator</code> <p>Whether to always display the card creator</p> <p> TYPE: <code>bool</code> </p> <code>createdAt</code> <p>When the board was created</p> <p> TYPE: <code>str</code> </p> <code>defaultCardType</code> <p>Default card type for new cards</p> <p> TYPE: <code>Literal['project', 'story']</code> </p> <code>defaultView</code> <p>Default view for the board</p> <p> TYPE: <code>Literal['kanban', 'grid', 'list']</code> </p> <code>expandTaskListsByDefault</code> <p>Whether to expand task lists by default</p> <p> TYPE: <code>bool</code> </p> <code>id</code> <p>Unique identifier for the board</p> <p> TYPE: <code>str</code> </p> <code>limitCardTypesToDefaultOne</code> <p>Whether to limit card types to default one</p> <p> TYPE: <code>bool</code> </p> <code>name</code> <p>Name/title of the board</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the board within the project</p> <p> TYPE: <code>int</code> </p> <code>projectId</code> <p>ID of the project the board belongs to</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the board was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Board.alwaysDisplayCardCreator","title":"alwaysDisplayCardCreator  <code>instance-attribute</code>","text":"<pre><code>alwaysDisplayCardCreator: bool\n</code></pre> <p>Whether to always display the card creator</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Board.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the board was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Board.defaultCardType","title":"defaultCardType  <code>instance-attribute</code>","text":"<pre><code>defaultCardType: Literal['project', 'story']\n</code></pre> <p>Default card type for new cards</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Board.defaultView","title":"defaultView  <code>instance-attribute</code>","text":"<pre><code>defaultView: Literal['kanban', 'grid', 'list']\n</code></pre> <p>Default view for the board</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Board.expandTaskListsByDefault","title":"expandTaskListsByDefault  <code>instance-attribute</code>","text":"<pre><code>expandTaskListsByDefault: bool\n</code></pre> <p>Whether to expand task lists by default</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Board.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the board</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Board.limitCardTypesToDefaultOne","title":"limitCardTypesToDefaultOne  <code>instance-attribute</code>","text":"<pre><code>limitCardTypesToDefaultOne: bool\n</code></pre> <p>Whether to limit card types to default one</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Board.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the board</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Board.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the board within the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Board.projectId","title":"projectId  <code>instance-attribute</code>","text":"<pre><code>projectId: str\n</code></pre> <p>ID of the project the board belongs to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Board.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the board was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.BoardMembership","title":"BoardMembership","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0board_memberships </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_createBoard <code></code>\u00a0boardMemberships </li> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0boardMemberships </li> <li> <code></code>\u00a0Included_getProject <code></code>\u00a0boardMemberships </li> <li> <code></code>\u00a0Included_getProjects <code></code>\u00a0boardMemberships </li> <li> <code></code>\u00a0Response_createBoardMembership <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteBoardMembership <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateBoardMembership <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Board Membership <code></code>\u00a0BoardMembership </li> </ul> ATTRIBUTE DESCRIPTION <code>boardId</code> <p>ID of the board the membership is associated with</p> <p> TYPE: <code>str</code> </p> <code>canComment</code> <p>Whether the user can comment on cards (applies only to viewers)</p> <p> TYPE: <code>bool</code> </p> <code>createdAt</code> <p>When the board membership was created</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the board membership</p> <p> TYPE: <code>str</code> </p> <code>projectId</code> <p>ID of the project the board membership belongs to (denormalized)</p> <p> TYPE: <code>str</code> </p> <code>role</code> <p>Role of the user in the board</p> <p> TYPE: <code>Literal['editor', 'viewer']</code> </p> <code>updatedAt</code> <p>When the board membership was last updated</p> <p> TYPE: <code>str</code> </p> <code>userId</code> <p>ID of the user who is a member of the board</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.BoardMembership.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: str\n</code></pre> <p>ID of the board the membership is associated with</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.BoardMembership.canComment","title":"canComment  <code>instance-attribute</code>","text":"<pre><code>canComment: bool\n</code></pre> <p>Whether the user can comment on cards (applies only to viewers)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.BoardMembership.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the board membership was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.BoardMembership.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the board membership</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.BoardMembership.projectId","title":"projectId  <code>instance-attribute</code>","text":"<pre><code>projectId: str\n</code></pre> <p>ID of the project the board membership belongs to (denormalized)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.BoardMembership.role","title":"role  <code>instance-attribute</code>","text":"<pre><code>role: Literal['editor', 'viewer']\n</code></pre> <p>Role of the user in the board</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.BoardMembership.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the board membership was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.BoardMembership.userId","title":"userId  <code>instance-attribute</code>","text":"<pre><code>userId: str\n</code></pre> <p>ID of the user who is a member of the board</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Card","title":"Card","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0cards </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_deleteList <code></code>\u00a0cards </li> <li> <code></code>\u00a0Included_moveListCards <code></code>\u00a0cards </li> <li> <code></code>\u00a0Included_sortList <code></code>\u00a0cards </li> <li> <code></code>\u00a0Response_createCard <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteCard <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_duplicateCard <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_readCardNotifications <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateCard <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 <ul> <li> models Card <code></code>\u00a0Card </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_getBoard_all </li> <li> <code></code>\u00a0Included_getList_all </li> <li> <code></code>\u00a0Item_getCard </li> <li> <code></code>\u00a0Items_getCards </li> </ul> </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>boardId</code> <p>ID of the board the card belongs to (denormalized)</p> <p> TYPE: <code>str</code> </p> <code>commentsTotal</code> <p>Total number of comments on the card</p> <p> TYPE: <code>int</code> </p> <code>coverAttachmentId</code> <p>ID of the attachment used as cover</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the card was created</p> <p> TYPE: <code>str</code> </p> <code>creatorUserId</code> <p>ID of the user who created the card</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>Detailed description of the card</p> <p> TYPE: <code>str</code> </p> <code>dueDate</code> <p>Due date for the card</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the card</p> <p> TYPE: <code>str</code> </p> <code>isClosed</code> <p>Whether the card is closed</p> <p> TYPE: <code>bool</code> </p> <code>isDueCompleted</code> <p>Whether the due date is completed</p> <p> TYPE: <code>bool</code> </p> <code>listChangedAt</code> <p>When the card was last moved between lists</p> <p> TYPE: <code>str</code> </p> <code>listId</code> <p>ID of the list the card belongs to</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the card</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the card within the list</p> <p> TYPE: <code>int</code> </p> <code>prevListId</code> <p>ID of the previous list the card was in (available when in archive or trash)</p> <p> TYPE: <code>str</code> </p> <code>stopwatch</code> <p>Stopwatch data for time tracking</p> <p> TYPE: <code>Stopwatch | None</code> </p> <code>type</code> <p>Type of the card</p> <p> TYPE: <code>Literal['project', 'story']</code> </p> <code>updatedAt</code> <p>When the card was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Card.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: str\n</code></pre> <p>ID of the board the card belongs to (denormalized)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Card.commentsTotal","title":"commentsTotal  <code>instance-attribute</code>","text":"<pre><code>commentsTotal: int\n</code></pre> <p>Total number of comments on the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Card.coverAttachmentId","title":"coverAttachmentId  <code>instance-attribute</code>","text":"<pre><code>coverAttachmentId: str\n</code></pre> <p>ID of the attachment used as cover</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Card.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the card was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Card.creatorUserId","title":"creatorUserId  <code>instance-attribute</code>","text":"<pre><code>creatorUserId: str\n</code></pre> <p>ID of the user who created the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Card.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str\n</code></pre> <p>Detailed description of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Card.dueDate","title":"dueDate  <code>instance-attribute</code>","text":"<pre><code>dueDate: str\n</code></pre> <p>Due date for the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Card.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Card.isClosed","title":"isClosed  <code>instance-attribute</code>","text":"<pre><code>isClosed: bool\n</code></pre> <p>Whether the card is closed</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Card.isDueCompleted","title":"isDueCompleted  <code>instance-attribute</code>","text":"<pre><code>isDueCompleted: bool\n</code></pre> <p>Whether the due date is completed</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Card.listChangedAt","title":"listChangedAt  <code>instance-attribute</code>","text":"<pre><code>listChangedAt: str\n</code></pre> <p>When the card was last moved between lists</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Card.listId","title":"listId  <code>instance-attribute</code>","text":"<pre><code>listId: str\n</code></pre> <p>ID of the list the card belongs to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Card.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Card.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the card within the list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Card.prevListId","title":"prevListId  <code>instance-attribute</code>","text":"<pre><code>prevListId: str\n</code></pre> <p>ID of the previous list the card was in (available when in archive or trash)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Card.stopwatch","title":"stopwatch  <code>instance-attribute</code>","text":"<pre><code>stopwatch: Stopwatch | None\n</code></pre> <p>Stopwatch data for time tracking</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Card.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['project', 'story']\n</code></pre> <p>Type of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Card.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the card was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CardLabel","title":"CardLabel","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0card_labels </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_duplicateCard <code></code>\u00a0cardLabels </li> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0cardLabels </li> <li> <code></code>\u00a0Included_getCard <code></code>\u00a0cardLabels </li> <li> <code></code>\u00a0Included_getCards <code></code>\u00a0cardLabels </li> <li> <code></code>\u00a0Included_getList <code></code>\u00a0cardLabels </li> <li> <code></code>\u00a0Response_createCardLabel <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteCardLabel <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Card Label <code></code>\u00a0CardLabel </li> </ul> ATTRIBUTE DESCRIPTION <code>cardId</code> <p>ID of the card the label is associated with</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the card-label association was created</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the card-label association</p> <p> TYPE: <code>str</code> </p> <code>labelId</code> <p>ID of the label associated with the card</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the card-label association was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CardLabel.cardId","title":"cardId  <code>instance-attribute</code>","text":"<pre><code>cardId: str\n</code></pre> <p>ID of the card the label is associated with</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CardLabel.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the card-label association was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CardLabel.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the card-label association</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CardLabel.labelId","title":"labelId  <code>instance-attribute</code>","text":"<pre><code>labelId: str\n</code></pre> <p>ID of the label associated with the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CardLabel.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the card-label association was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CardMembership","title":"CardMembership","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0card_memberships </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_duplicateCard <code></code>\u00a0cardMemberships </li> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0cardMemberships </li> <li> <code></code>\u00a0Included_getCard <code></code>\u00a0cardMemberships </li> <li> <code></code>\u00a0Included_getCards <code></code>\u00a0cardMemberships </li> <li> <code></code>\u00a0Included_getList <code></code>\u00a0cardMemberships </li> <li> <code></code>\u00a0Response_createCardMembership <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteCardMembership <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Card Membership <code></code>\u00a0CardMembership </li> </ul> ATTRIBUTE DESCRIPTION <code>cardId</code> <p>ID of the card the user is a member of</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the card membership was created</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the card membership</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the card membership was last updated</p> <p> TYPE: <code>str</code> </p> <code>userId</code> <p>ID of the user who is a member of the card</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CardMembership.cardId","title":"cardId  <code>instance-attribute</code>","text":"<pre><code>cardId: str\n</code></pre> <p>ID of the card the user is a member of</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CardMembership.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the card membership was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CardMembership.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the card membership</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CardMembership.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the card membership was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CardMembership.userId","title":"userId  <code>instance-attribute</code>","text":"<pre><code>userId: str\n</code></pre> <p>ID of the user who is a member of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Comment","title":"Comment","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0comments </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Response_createComment <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteComment <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_getComments <code></code>\u00a0items </li> <li> <code></code>\u00a0Response_updateComments <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Comment <code></code>\u00a0Comment </li> </ul> ATTRIBUTE DESCRIPTION <code>cardId</code> <p>ID of the card the comment belongs to</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the comment was created</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the comment</p> <p> TYPE: <code>str</code> </p> <code>text</code> <p>Content of the comment</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the comment was last updated</p> <p> TYPE: <code>str</code> </p> <code>userId</code> <p>ID of the user who created the comment</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Comment.cardId","title":"cardId  <code>instance-attribute</code>","text":"<pre><code>cardId: str\n</code></pre> <p>ID of the card the comment belongs to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Comment.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the comment was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Comment.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the comment</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Comment.text","title":"text  <code>instance-attribute</code>","text":"<pre><code>text: str\n</code></pre> <p>Content of the comment</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Comment.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the comment was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Comment.userId","title":"userId  <code>instance-attribute</code>","text":"<pre><code>userId: str\n</code></pre> <p>ID of the user who created the comment</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Config","title":"Config","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0config </li> <li> api REST Typing <code></code>\u00a0Response_getConfig <code></code>\u00a0item </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Config <code></code>\u00a0Config </li> </ul> ATTRIBUTE DESCRIPTION <code>activeUsersLimit</code> <p>Maximum number of active users allowed (conditionally added for admins if configured)</p> <p> TYPE: <code>NotRequired[int]</code> </p> <code>oidc</code> <p>OpenID Connect configuration (null if not configured)</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>version</code> <p>Current version of the PLANKA application</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Config.activeUsersLimit","title":"activeUsersLimit  <code>instance-attribute</code>","text":"<pre><code>activeUsersLimit: NotRequired[int]\n</code></pre> <p>Maximum number of active users allowed (conditionally added for admins if configured)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Config.oidc","title":"oidc  <code>instance-attribute</code>","text":"<pre><code>oidc: dict[str, Any]\n</code></pre> <p>OpenID Connect configuration (null if not configured)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Config.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str\n</code></pre> <p>Current version of the PLANKA application</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomField","title":"CustomField","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0custom_fields </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_duplicateCard <code></code>\u00a0customFields </li> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0customFields </li> <li> <code></code>\u00a0Included_getCard <code></code>\u00a0customFields </li> <li> <code></code>\u00a0Included_getCards <code></code>\u00a0customFields </li> <li> <code></code>\u00a0Included_getCustomFieldGroup <code></code>\u00a0customFields </li> <li> <code></code>\u00a0Included_getList <code></code>\u00a0customFields </li> <li> <code></code>\u00a0Included_getProject <code></code>\u00a0customFields </li> <li> <code></code>\u00a0Included_getProjects <code></code>\u00a0customFields </li> <li> <code></code>\u00a0Response_createCustomFieldInBaseGroup <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_createCustomFieldInGroup <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteCustomField <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateCustomField <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Custom Field <code></code>\u00a0CustomField </li> </ul> ATTRIBUTE DESCRIPTION <code>baseCustomFieldGroupId</code> <p>ID of the base custom field group the custom field belongs to</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the custom field was created</p> <p> TYPE: <code>str</code> </p> <code>customFieldGroupId</code> <p>ID of the custom field group the custom field belongs to</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the custom field</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the custom field</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the custom field within the group</p> <p> TYPE: <code>int</code> </p> <code>showOnFrontOfCard</code> <p>Whether to show the field on the front of cards</p> <p> TYPE: <code>bool</code> </p> <code>updatedAt</code> <p>When the custom field was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomField.baseCustomFieldGroupId","title":"baseCustomFieldGroupId  <code>instance-attribute</code>","text":"<pre><code>baseCustomFieldGroupId: str\n</code></pre> <p>ID of the base custom field group the custom field belongs to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomField.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the custom field was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomField.customFieldGroupId","title":"customFieldGroupId  <code>instance-attribute</code>","text":"<pre><code>customFieldGroupId: str\n</code></pre> <p>ID of the custom field group the custom field belongs to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomField.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the custom field</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomField.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the custom field</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomField.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the custom field within the group</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomField.showOnFrontOfCard","title":"showOnFrontOfCard  <code>instance-attribute</code>","text":"<pre><code>showOnFrontOfCard: bool\n</code></pre> <p>Whether to show the field on the front of cards</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomField.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the custom field was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomFieldGroup","title":"CustomFieldGroup","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <ul> <li> <code></code>\u00a0Included_duplicateCard <code></code>\u00a0customFieldGroups </li> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0customFieldGroups </li> <li> <code></code>\u00a0Included_getCard <code></code>\u00a0customFieldGroups </li> <li> <code></code>\u00a0Included_getCards <code></code>\u00a0customFieldGroups </li> <li> <code></code>\u00a0Included_getList <code></code>\u00a0customFieldGroups </li> <li> <code></code>\u00a0Response_createBoardCustomFieldGroup <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_createCardCustomFieldGroup <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteCustomFieldGroup <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_getCustomFieldGroup <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateCustomFieldGroup <code></code>\u00a0item </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Custom Field Group <code></code>\u00a0CustomFieldGroup </li> </ul> ATTRIBUTE DESCRIPTION <code>baseCustomFieldGroupId</code> <p>ID of the base custom field group used as a template</p> <p> TYPE: <code>str</code> </p> <code>boardId</code> <p>ID of the board the custom field group belongs to</p> <p> TYPE: <code>str</code> </p> <code>cardId</code> <p>ID of the card the custom field group belongs to</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the custom field group was created</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the custom field group</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the custom field group</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the custom field group within the board/card</p> <p> TYPE: <code>int</code> </p> <code>updatedAt</code> <p>When the custom field group was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomFieldGroup.baseCustomFieldGroupId","title":"baseCustomFieldGroupId  <code>instance-attribute</code>","text":"<pre><code>baseCustomFieldGroupId: str\n</code></pre> <p>ID of the base custom field group used as a template</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomFieldGroup.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: str\n</code></pre> <p>ID of the board the custom field group belongs to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomFieldGroup.cardId","title":"cardId  <code>instance-attribute</code>","text":"<pre><code>cardId: str\n</code></pre> <p>ID of the card the custom field group belongs to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomFieldGroup.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the custom field group was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomFieldGroup.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the custom field group</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomFieldGroup.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the custom field group</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomFieldGroup.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the custom field group within the board/card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomFieldGroup.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the custom field group was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomFieldValue","title":"CustomFieldValue","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <ul> <li> <code></code>\u00a0Included_duplicateCard <code></code>\u00a0customFieldValues </li> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0customFieldValues </li> <li> <code></code>\u00a0Included_getCard <code></code>\u00a0customFieldValues </li> <li> <code></code>\u00a0Included_getCards <code></code>\u00a0customFieldValues </li> <li> <code></code>\u00a0Included_getCustomFieldGroup <code></code>\u00a0customFieldValues </li> <li> <code></code>\u00a0Included_getList <code></code>\u00a0customFieldValues </li> <li> <code></code>\u00a0Response_deleteCustomFieldValue <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateCustomFieldValue <code></code>\u00a0item </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Custom Field Value <code></code>\u00a0CustomFieldValue </li> </ul> ATTRIBUTE DESCRIPTION <code>cardId</code> <p>ID of the card the value belongs to</p> <p> TYPE: <code>str</code> </p> <code>content</code> <p>Content/value of the custom field</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the custom field value was created</p> <p> TYPE: <code>str</code> </p> <code>customFieldGroupId</code> <p>ID of the custom field group the value belongs to</p> <p> TYPE: <code>str</code> </p> <code>customFieldId</code> <p>ID of the custom field the value belongs to</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the custom field value</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the custom field value was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomFieldValue.cardId","title":"cardId  <code>instance-attribute</code>","text":"<pre><code>cardId: str\n</code></pre> <p>ID of the card the value belongs to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomFieldValue.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: str\n</code></pre> <p>Content/value of the custom field</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomFieldValue.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the custom field value was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomFieldValue.customFieldGroupId","title":"customFieldGroupId  <code>instance-attribute</code>","text":"<pre><code>customFieldGroupId: str\n</code></pre> <p>ID of the custom field group the value belongs to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomFieldValue.customFieldId","title":"customFieldId  <code>instance-attribute</code>","text":"<pre><code>customFieldId: str\n</code></pre> <p>ID of the custom field the value belongs to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomFieldValue.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the custom field value</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.CustomFieldValue.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the custom field value was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_createBoard","title":"Included_createBoard","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_createBoard <code></code>\u00a0included </li> </ul> ATTRIBUTE DESCRIPTION <code>boardMemberships</code> <p> TYPE: <code>list[BoardMembership]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_createBoard.boardMemberships","title":"boardMemberships  <code>instance-attribute</code>","text":"<pre><code>boardMemberships: list[BoardMembership]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_createProject","title":"Included_createProject","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_createProject <code></code>\u00a0included </li> </ul> ATTRIBUTE DESCRIPTION <code>projectManagers</code> <p> TYPE: <code>list[ProjectManager]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_createProject.projectManagers","title":"projectManagers  <code>instance-attribute</code>","text":"<pre><code>projectManagers: list[ProjectManager]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_deleteList","title":"Included_deleteList","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_deleteList <code></code>\u00a0included </li> </ul> ATTRIBUTE DESCRIPTION <code>cards</code> <p> TYPE: <code>list[Card]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_deleteList.cards","title":"cards  <code>instance-attribute</code>","text":"<pre><code>cards: list[Card]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_duplicateCard","title":"Included_duplicateCard","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_duplicateCard <code></code>\u00a0included </li> </ul> ATTRIBUTE DESCRIPTION <code>attachments</code> <p> TYPE: <code>list[Attachment]</code> </p> <code>cardLabels</code> <p> TYPE: <code>list[CardLabel]</code> </p> <code>cardMemberships</code> <p> TYPE: <code>list[CardMembership]</code> </p> <code>customFieldGroups</code> <p> TYPE: <code>list[CustomFieldGroup]</code> </p> <code>customFieldValues</code> <p> TYPE: <code>list[CustomFieldValue]</code> </p> <code>customFields</code> <p> TYPE: <code>list[CustomField]</code> </p> <code>taskLists</code> <p> TYPE: <code>list[TaskList]</code> </p> <code>tasks</code> <p> TYPE: <code>list[Task]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_duplicateCard.attachments","title":"attachments  <code>instance-attribute</code>","text":"<pre><code>attachments: list[Attachment]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_duplicateCard.cardLabels","title":"cardLabels  <code>instance-attribute</code>","text":"<pre><code>cardLabels: list[CardLabel]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_duplicateCard.cardMemberships","title":"cardMemberships  <code>instance-attribute</code>","text":"<pre><code>cardMemberships: list[CardMembership]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_duplicateCard.customFieldGroups","title":"customFieldGroups  <code>instance-attribute</code>","text":"<pre><code>customFieldGroups: list[CustomFieldGroup]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_duplicateCard.customFieldValues","title":"customFieldValues  <code>instance-attribute</code>","text":"<pre><code>customFieldValues: list[CustomFieldValue]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_duplicateCard.customFields","title":"customFields  <code>instance-attribute</code>","text":"<pre><code>customFields: list[CustomField]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_duplicateCard.taskLists","title":"taskLists  <code>instance-attribute</code>","text":"<pre><code>taskLists: list[TaskList]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_duplicateCard.tasks","title":"tasks  <code>instance-attribute</code>","text":"<pre><code>tasks: list[Task]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard","title":"Included_getBoard","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_getBoard <code></code>\u00a0included </li> </ul> ATTRIBUTE DESCRIPTION <code>attachments</code> <p> TYPE: <code>list[Attachment]</code> </p> <code>boardMemberships</code> <p> TYPE: <code>list[BoardMembership]</code> </p> <code>cardLabels</code> <p> TYPE: <code>list[CardLabel]</code> </p> <code>cardMemberships</code> <p> TYPE: <code>list[CardMembership]</code> </p> <code>cards</code> <p>Related cards</p> <p> TYPE: <code>list[Included_getBoard_all]</code> </p> <code>customFieldGroups</code> <p> TYPE: <code>list[CustomFieldGroup]</code> </p> <code>customFieldValues</code> <p> TYPE: <code>list[CustomFieldValue]</code> </p> <code>customFields</code> <p> TYPE: <code>list[CustomField]</code> </p> <code>labels</code> <p> TYPE: <code>list[Label]</code> </p> <code>lists</code> <p> TYPE: <code>list[List]</code> </p> <code>projects</code> <p> TYPE: <code>list[Project]</code> </p> <code>taskLists</code> <p> TYPE: <code>list[TaskList]</code> </p> <code>tasks</code> <p> TYPE: <code>list[Task]</code> </p> <code>users</code> <p> TYPE: <code>list[User]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard.attachments","title":"attachments  <code>instance-attribute</code>","text":"<pre><code>attachments: list[Attachment]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard.boardMemberships","title":"boardMemberships  <code>instance-attribute</code>","text":"<pre><code>boardMemberships: list[BoardMembership]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard.cardLabels","title":"cardLabels  <code>instance-attribute</code>","text":"<pre><code>cardLabels: list[CardLabel]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard.cardMemberships","title":"cardMemberships  <code>instance-attribute</code>","text":"<pre><code>cardMemberships: list[CardMembership]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard.cards","title":"cards  <code>instance-attribute</code>","text":"<pre><code>cards: list[Included_getBoard_all]\n</code></pre> <p>Related cards</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard.customFieldGroups","title":"customFieldGroups  <code>instance-attribute</code>","text":"<pre><code>customFieldGroups: list[CustomFieldGroup]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard.customFieldValues","title":"customFieldValues  <code>instance-attribute</code>","text":"<pre><code>customFieldValues: list[CustomFieldValue]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard.customFields","title":"customFields  <code>instance-attribute</code>","text":"<pre><code>customFields: list[CustomField]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard.labels","title":"labels  <code>instance-attribute</code>","text":"<pre><code>labels: list[Label]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard.lists","title":"lists  <code>instance-attribute</code>","text":"<pre><code>lists: list[List]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard.projects","title":"projects  <code>instance-attribute</code>","text":"<pre><code>projects: list[Project]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard.taskLists","title":"taskLists  <code>instance-attribute</code>","text":"<pre><code>taskLists: list[TaskList]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard.tasks","title":"tasks  <code>instance-attribute</code>","text":"<pre><code>tasks: list[Task]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard.users","title":"users  <code>instance-attribute</code>","text":"<pre><code>users: list[User]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoardActions","title":"Included_getBoardActions","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_getBoardActions <code></code>\u00a0included </li> </ul> ATTRIBUTE DESCRIPTION <code>users</code> <p> TYPE: <code>list[User]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoardActions.users","title":"users  <code>instance-attribute</code>","text":"<pre><code>users: list[User]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard_all","title":"Included_getBoard_all","text":"<p>               Bases: <code>Card</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Included_getBoard <code></code>\u00a0cards </li> </ul> ATTRIBUTE DESCRIPTION <code>boardId</code> <p>ID of the board the card belongs to (denormalized)</p> <p> TYPE: <code>str</code> </p> <code>commentsTotal</code> <p>Total number of comments on the card</p> <p> TYPE: <code>int</code> </p> <code>coverAttachmentId</code> <p>ID of the attachment used as cover</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the card was created</p> <p> TYPE: <code>str</code> </p> <code>creatorUserId</code> <p>ID of the user who created the card</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>Detailed description of the card</p> <p> TYPE: <code>str</code> </p> <code>dueDate</code> <p>Due date for the card</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the card</p> <p> TYPE: <code>str</code> </p> <code>isClosed</code> <p>Whether the card is closed</p> <p> TYPE: <code>bool</code> </p> <code>isDueCompleted</code> <p>Whether the due date is completed</p> <p> TYPE: <code>bool</code> </p> <code>isSubscribed</code> <p>Whether the current user is subscribed to the card</p> <p> TYPE: <code>bool</code> </p> <code>listChangedAt</code> <p>When the card was last moved between lists</p> <p> TYPE: <code>str</code> </p> <code>listId</code> <p>ID of the list the card belongs to</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the card</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the card within the list</p> <p> TYPE: <code>int</code> </p> <code>prevListId</code> <p>ID of the previous list the card was in (available when in archive or trash)</p> <p> TYPE: <code>str</code> </p> <code>stopwatch</code> <p>Stopwatch data for time tracking</p> <p> TYPE: <code>Stopwatch | None</code> </p> <code>type</code> <p>Type of the card</p> <p> TYPE: <code>Literal['project', 'story']</code> </p> <code>updatedAt</code> <p>When the card was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard_all.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: str\n</code></pre> <p>ID of the board the card belongs to (denormalized)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard_all.commentsTotal","title":"commentsTotal  <code>instance-attribute</code>","text":"<pre><code>commentsTotal: int\n</code></pre> <p>Total number of comments on the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard_all.coverAttachmentId","title":"coverAttachmentId  <code>instance-attribute</code>","text":"<pre><code>coverAttachmentId: str\n</code></pre> <p>ID of the attachment used as cover</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard_all.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the card was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard_all.creatorUserId","title":"creatorUserId  <code>instance-attribute</code>","text":"<pre><code>creatorUserId: str\n</code></pre> <p>ID of the user who created the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard_all.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str\n</code></pre> <p>Detailed description of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard_all.dueDate","title":"dueDate  <code>instance-attribute</code>","text":"<pre><code>dueDate: str\n</code></pre> <p>Due date for the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard_all.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard_all.isClosed","title":"isClosed  <code>instance-attribute</code>","text":"<pre><code>isClosed: bool\n</code></pre> <p>Whether the card is closed</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard_all.isDueCompleted","title":"isDueCompleted  <code>instance-attribute</code>","text":"<pre><code>isDueCompleted: bool\n</code></pre> <p>Whether the due date is completed</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard_all.isSubscribed","title":"isSubscribed  <code>instance-attribute</code>","text":"<pre><code>isSubscribed: bool\n</code></pre> <p>Whether the current user is subscribed to the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard_all.listChangedAt","title":"listChangedAt  <code>instance-attribute</code>","text":"<pre><code>listChangedAt: str\n</code></pre> <p>When the card was last moved between lists</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard_all.listId","title":"listId  <code>instance-attribute</code>","text":"<pre><code>listId: str\n</code></pre> <p>ID of the list the card belongs to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard_all.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard_all.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the card within the list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard_all.prevListId","title":"prevListId  <code>instance-attribute</code>","text":"<pre><code>prevListId: str\n</code></pre> <p>ID of the previous list the card was in (available when in archive or trash)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard_all.stopwatch","title":"stopwatch  <code>instance-attribute</code>","text":"<pre><code>stopwatch: Stopwatch | None\n</code></pre> <p>Stopwatch data for time tracking</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard_all.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['project', 'story']\n</code></pre> <p>Type of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getBoard_all.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the card was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCard","title":"Included_getCard","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_getCard <code></code>\u00a0included </li> </ul> ATTRIBUTE DESCRIPTION <code>attachments</code> <p> TYPE: <code>list[Attachment]</code> </p> <code>cardLabels</code> <p> TYPE: <code>list[CardLabel]</code> </p> <code>cardMemberships</code> <p> TYPE: <code>list[CardMembership]</code> </p> <code>customFieldGroups</code> <p> TYPE: <code>list[CustomFieldGroup]</code> </p> <code>customFieldValues</code> <p> TYPE: <code>list[CustomFieldValue]</code> </p> <code>customFields</code> <p> TYPE: <code>list[CustomField]</code> </p> <code>taskLists</code> <p> TYPE: <code>list[TaskList]</code> </p> <code>tasks</code> <p> TYPE: <code>list[Task]</code> </p> <code>users</code> <p> TYPE: <code>list[User]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCard.attachments","title":"attachments  <code>instance-attribute</code>","text":"<pre><code>attachments: list[Attachment]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCard.cardLabels","title":"cardLabels  <code>instance-attribute</code>","text":"<pre><code>cardLabels: list[CardLabel]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCard.cardMemberships","title":"cardMemberships  <code>instance-attribute</code>","text":"<pre><code>cardMemberships: list[CardMembership]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCard.customFieldGroups","title":"customFieldGroups  <code>instance-attribute</code>","text":"<pre><code>customFieldGroups: list[CustomFieldGroup]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCard.customFieldValues","title":"customFieldValues  <code>instance-attribute</code>","text":"<pre><code>customFieldValues: list[CustomFieldValue]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCard.customFields","title":"customFields  <code>instance-attribute</code>","text":"<pre><code>customFields: list[CustomField]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCard.taskLists","title":"taskLists  <code>instance-attribute</code>","text":"<pre><code>taskLists: list[TaskList]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCard.tasks","title":"tasks  <code>instance-attribute</code>","text":"<pre><code>tasks: list[Task]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCard.users","title":"users  <code>instance-attribute</code>","text":"<pre><code>users: list[User]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCardActions","title":"Included_getCardActions","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_getCardActions <code></code>\u00a0included </li> </ul> ATTRIBUTE DESCRIPTION <code>users</code> <p> TYPE: <code>list[User]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCardActions.users","title":"users  <code>instance-attribute</code>","text":"<pre><code>users: list[User]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCards","title":"Included_getCards","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_getCards <code></code>\u00a0included </li> </ul> ATTRIBUTE DESCRIPTION <code>attachments</code> <p> TYPE: <code>list[Attachment]</code> </p> <code>cardLabels</code> <p> TYPE: <code>list[CardLabel]</code> </p> <code>cardMemberships</code> <p> TYPE: <code>list[CardMembership]</code> </p> <code>customFieldGroups</code> <p> TYPE: <code>list[CustomFieldGroup]</code> </p> <code>customFieldValues</code> <p> TYPE: <code>list[CustomFieldValue]</code> </p> <code>customFields</code> <p> TYPE: <code>list[CustomField]</code> </p> <code>taskLists</code> <p> TYPE: <code>list[TaskList]</code> </p> <code>tasks</code> <p> TYPE: <code>list[Task]</code> </p> <code>users</code> <p> TYPE: <code>list[User]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCards.attachments","title":"attachments  <code>instance-attribute</code>","text":"<pre><code>attachments: list[Attachment]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCards.cardLabels","title":"cardLabels  <code>instance-attribute</code>","text":"<pre><code>cardLabels: list[CardLabel]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCards.cardMemberships","title":"cardMemberships  <code>instance-attribute</code>","text":"<pre><code>cardMemberships: list[CardMembership]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCards.customFieldGroups","title":"customFieldGroups  <code>instance-attribute</code>","text":"<pre><code>customFieldGroups: list[CustomFieldGroup]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCards.customFieldValues","title":"customFieldValues  <code>instance-attribute</code>","text":"<pre><code>customFieldValues: list[CustomFieldValue]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCards.customFields","title":"customFields  <code>instance-attribute</code>","text":"<pre><code>customFields: list[CustomField]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCards.taskLists","title":"taskLists  <code>instance-attribute</code>","text":"<pre><code>taskLists: list[TaskList]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCards.tasks","title":"tasks  <code>instance-attribute</code>","text":"<pre><code>tasks: list[Task]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCards.users","title":"users  <code>instance-attribute</code>","text":"<pre><code>users: list[User]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getComments","title":"Included_getComments","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_getComments <code></code>\u00a0included </li> </ul> ATTRIBUTE DESCRIPTION <code>users</code> <p> TYPE: <code>list[User]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getComments.users","title":"users  <code>instance-attribute</code>","text":"<pre><code>users: list[User]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCustomFieldGroup","title":"Included_getCustomFieldGroup","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_getCustomFieldGroup <code></code>\u00a0included </li> </ul> ATTRIBUTE DESCRIPTION <code>customFieldValues</code> <p> TYPE: <code>list[CustomFieldValue]</code> </p> <code>customFields</code> <p> TYPE: <code>list[CustomField]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCustomFieldGroup.customFieldValues","title":"customFieldValues  <code>instance-attribute</code>","text":"<pre><code>customFieldValues: list[CustomFieldValue]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getCustomFieldGroup.customFields","title":"customFields  <code>instance-attribute</code>","text":"<pre><code>customFields: list[CustomField]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList","title":"Included_getList","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_getList <code></code>\u00a0included </li> </ul> ATTRIBUTE DESCRIPTION <code>attachments</code> <p> TYPE: <code>list[Attachment]</code> </p> <code>cardLabels</code> <p> TYPE: <code>list[CardLabel]</code> </p> <code>cardMemberships</code> <p> TYPE: <code>list[CardMembership]</code> </p> <code>cards</code> <p>Related cards</p> <p> TYPE: <code>list[Included_getList_all]</code> </p> <code>customFieldGroups</code> <p> TYPE: <code>list[CustomFieldGroup]</code> </p> <code>customFieldValues</code> <p> TYPE: <code>list[CustomFieldValue]</code> </p> <code>customFields</code> <p> TYPE: <code>list[CustomField]</code> </p> <code>taskLists</code> <p> TYPE: <code>list[TaskList]</code> </p> <code>tasks</code> <p> TYPE: <code>list[Task]</code> </p> <code>users</code> <p> TYPE: <code>list[User]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList.attachments","title":"attachments  <code>instance-attribute</code>","text":"<pre><code>attachments: list[Attachment]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList.cardLabels","title":"cardLabels  <code>instance-attribute</code>","text":"<pre><code>cardLabels: list[CardLabel]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList.cardMemberships","title":"cardMemberships  <code>instance-attribute</code>","text":"<pre><code>cardMemberships: list[CardMembership]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList.cards","title":"cards  <code>instance-attribute</code>","text":"<pre><code>cards: list[Included_getList_all]\n</code></pre> <p>Related cards</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList.customFieldGroups","title":"customFieldGroups  <code>instance-attribute</code>","text":"<pre><code>customFieldGroups: list[CustomFieldGroup]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList.customFieldValues","title":"customFieldValues  <code>instance-attribute</code>","text":"<pre><code>customFieldValues: list[CustomFieldValue]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList.customFields","title":"customFields  <code>instance-attribute</code>","text":"<pre><code>customFields: list[CustomField]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList.taskLists","title":"taskLists  <code>instance-attribute</code>","text":"<pre><code>taskLists: list[TaskList]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList.tasks","title":"tasks  <code>instance-attribute</code>","text":"<pre><code>tasks: list[Task]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList.users","title":"users  <code>instance-attribute</code>","text":"<pre><code>users: list[User]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList_all","title":"Included_getList_all","text":"<p>               Bases: <code>Card</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Included_getList <code></code>\u00a0cards </li> </ul> ATTRIBUTE DESCRIPTION <code>boardId</code> <p>ID of the board the card belongs to (denormalized)</p> <p> TYPE: <code>str</code> </p> <code>commentsTotal</code> <p>Total number of comments on the card</p> <p> TYPE: <code>int</code> </p> <code>coverAttachmentId</code> <p>ID of the attachment used as cover</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the card was created</p> <p> TYPE: <code>str</code> </p> <code>creatorUserId</code> <p>ID of the user who created the card</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>Detailed description of the card</p> <p> TYPE: <code>str</code> </p> <code>dueDate</code> <p>Due date for the card</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the card</p> <p> TYPE: <code>str</code> </p> <code>isClosed</code> <p>Whether the card is closed</p> <p> TYPE: <code>bool</code> </p> <code>isDueCompleted</code> <p>Whether the due date is completed</p> <p> TYPE: <code>bool</code> </p> <code>isSubscribed</code> <p>Whether the current user is subscribed to the card</p> <p> TYPE: <code>bool</code> </p> <code>listChangedAt</code> <p>When the card was last moved between lists</p> <p> TYPE: <code>str</code> </p> <code>listId</code> <p>ID of the list the card belongs to</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the card</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the card within the list</p> <p> TYPE: <code>int</code> </p> <code>prevListId</code> <p>ID of the previous list the card was in (available when in archive or trash)</p> <p> TYPE: <code>str</code> </p> <code>stopwatch</code> <p>Stopwatch data for time tracking</p> <p> TYPE: <code>Stopwatch | None</code> </p> <code>type</code> <p>Type of the card</p> <p> TYPE: <code>Literal['project', 'story']</code> </p> <code>updatedAt</code> <p>When the card was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList_all.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: str\n</code></pre> <p>ID of the board the card belongs to (denormalized)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList_all.commentsTotal","title":"commentsTotal  <code>instance-attribute</code>","text":"<pre><code>commentsTotal: int\n</code></pre> <p>Total number of comments on the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList_all.coverAttachmentId","title":"coverAttachmentId  <code>instance-attribute</code>","text":"<pre><code>coverAttachmentId: str\n</code></pre> <p>ID of the attachment used as cover</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList_all.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the card was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList_all.creatorUserId","title":"creatorUserId  <code>instance-attribute</code>","text":"<pre><code>creatorUserId: str\n</code></pre> <p>ID of the user who created the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList_all.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str\n</code></pre> <p>Detailed description of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList_all.dueDate","title":"dueDate  <code>instance-attribute</code>","text":"<pre><code>dueDate: str\n</code></pre> <p>Due date for the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList_all.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList_all.isClosed","title":"isClosed  <code>instance-attribute</code>","text":"<pre><code>isClosed: bool\n</code></pre> <p>Whether the card is closed</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList_all.isDueCompleted","title":"isDueCompleted  <code>instance-attribute</code>","text":"<pre><code>isDueCompleted: bool\n</code></pre> <p>Whether the due date is completed</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList_all.isSubscribed","title":"isSubscribed  <code>instance-attribute</code>","text":"<pre><code>isSubscribed: bool\n</code></pre> <p>Whether the current user is subscribed to the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList_all.listChangedAt","title":"listChangedAt  <code>instance-attribute</code>","text":"<pre><code>listChangedAt: str\n</code></pre> <p>When the card was last moved between lists</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList_all.listId","title":"listId  <code>instance-attribute</code>","text":"<pre><code>listId: str\n</code></pre> <p>ID of the list the card belongs to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList_all.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList_all.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the card within the list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList_all.prevListId","title":"prevListId  <code>instance-attribute</code>","text":"<pre><code>prevListId: str\n</code></pre> <p>ID of the previous list the card was in (available when in archive or trash)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList_all.stopwatch","title":"stopwatch  <code>instance-attribute</code>","text":"<pre><code>stopwatch: Stopwatch | None\n</code></pre> <p>Stopwatch data for time tracking</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList_all.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['project', 'story']\n</code></pre> <p>Type of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getList_all.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the card was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getNotification","title":"Included_getNotification","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_getNotification <code></code>\u00a0included </li> </ul> ATTRIBUTE DESCRIPTION <code>users</code> <p> TYPE: <code>list[User]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getNotification.users","title":"users  <code>instance-attribute</code>","text":"<pre><code>users: list[User]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getNotifications","title":"Included_getNotifications","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_getNotifications <code></code>\u00a0included </li> </ul> ATTRIBUTE DESCRIPTION <code>users</code> <p> TYPE: <code>list[User]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getNotifications.users","title":"users  <code>instance-attribute</code>","text":"<pre><code>users: list[User]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getProject","title":"Included_getProject","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_getProject <code></code>\u00a0included </li> </ul> ATTRIBUTE DESCRIPTION <code>backgroundImages</code> <p> TYPE: <code>list[BackgroundImage]</code> </p> <code>baseCustomFieldGroups</code> <p> TYPE: <code>list[BaseCustomFieldGroup]</code> </p> <code>boardMemberships</code> <p> TYPE: <code>list[BoardMembership]</code> </p> <code>boards</code> <p> TYPE: <code>list[Board]</code> </p> <code>customFields</code> <p> TYPE: <code>list[CustomField]</code> </p> <code>notificationServices</code> <p> TYPE: <code>list[NotificationService]</code> </p> <code>projectManagers</code> <p> TYPE: <code>list[ProjectManager]</code> </p> <code>users</code> <p> TYPE: <code>list[User]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getProject.backgroundImages","title":"backgroundImages  <code>instance-attribute</code>","text":"<pre><code>backgroundImages: list[BackgroundImage]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getProject.baseCustomFieldGroups","title":"baseCustomFieldGroups  <code>instance-attribute</code>","text":"<pre><code>baseCustomFieldGroups: list[BaseCustomFieldGroup]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getProject.boardMemberships","title":"boardMemberships  <code>instance-attribute</code>","text":"<pre><code>boardMemberships: list[BoardMembership]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getProject.boards","title":"boards  <code>instance-attribute</code>","text":"<pre><code>boards: list[Board]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getProject.customFields","title":"customFields  <code>instance-attribute</code>","text":"<pre><code>customFields: list[CustomField]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getProject.notificationServices","title":"notificationServices  <code>instance-attribute</code>","text":"<pre><code>notificationServices: list[NotificationService]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getProject.projectManagers","title":"projectManagers  <code>instance-attribute</code>","text":"<pre><code>projectManagers: list[ProjectManager]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getProject.users","title":"users  <code>instance-attribute</code>","text":"<pre><code>users: list[User]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getProjects","title":"Included_getProjects","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_getProjects <code></code>\u00a0included </li> </ul> ATTRIBUTE DESCRIPTION <code>backgroundImages</code> <p> TYPE: <code>list[BackgroundImage]</code> </p> <code>baseCustomFieldGroups</code> <p> TYPE: <code>list[BaseCustomFieldGroup]</code> </p> <code>boardMemberships</code> <p> TYPE: <code>list[BoardMembership]</code> </p> <code>boards</code> <p> TYPE: <code>list[Board]</code> </p> <code>customFields</code> <p> TYPE: <code>list[CustomField]</code> </p> <code>notificationServices</code> <p> TYPE: <code>list[NotificationService]</code> </p> <code>projectManagers</code> <p> TYPE: <code>list[ProjectManager]</code> </p> <code>users</code> <p> TYPE: <code>list[User]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getProjects.backgroundImages","title":"backgroundImages  <code>instance-attribute</code>","text":"<pre><code>backgroundImages: list[BackgroundImage]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getProjects.baseCustomFieldGroups","title":"baseCustomFieldGroups  <code>instance-attribute</code>","text":"<pre><code>baseCustomFieldGroups: list[BaseCustomFieldGroup]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getProjects.boardMemberships","title":"boardMemberships  <code>instance-attribute</code>","text":"<pre><code>boardMemberships: list[BoardMembership]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getProjects.boards","title":"boards  <code>instance-attribute</code>","text":"<pre><code>boards: list[Board]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getProjects.customFields","title":"customFields  <code>instance-attribute</code>","text":"<pre><code>customFields: list[CustomField]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getProjects.notificationServices","title":"notificationServices  <code>instance-attribute</code>","text":"<pre><code>notificationServices: list[NotificationService]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getProjects.projectManagers","title":"projectManagers  <code>instance-attribute</code>","text":"<pre><code>projectManagers: list[ProjectManager]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getProjects.users","title":"users  <code>instance-attribute</code>","text":"<pre><code>users: list[User]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getTaskList","title":"Included_getTaskList","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_getTaskList <code></code>\u00a0included </li> </ul> ATTRIBUTE DESCRIPTION <code>tasks</code> <p> TYPE: <code>list[Task]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getTaskList.tasks","title":"tasks  <code>instance-attribute</code>","text":"<pre><code>tasks: list[Task]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getUser","title":"Included_getUser","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_getUser <code></code>\u00a0included </li> </ul> ATTRIBUTE DESCRIPTION <code>notificationServices</code> <p> TYPE: <code>list[NotificationService]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_getUser.notificationServices","title":"notificationServices  <code>instance-attribute</code>","text":"<pre><code>notificationServices: list[NotificationService]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_moveListCards","title":"Included_moveListCards","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_moveListCards <code></code>\u00a0included </li> </ul> ATTRIBUTE DESCRIPTION <code>actions</code> <p> TYPE: <code>list[Action]</code> </p> <code>cards</code> <p> TYPE: <code>list[Card]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_moveListCards.actions","title":"actions  <code>instance-attribute</code>","text":"<pre><code>actions: list[Action]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_moveListCards.cards","title":"cards  <code>instance-attribute</code>","text":"<pre><code>cards: list[Card]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_readCardNotifications","title":"Included_readCardNotifications","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_readCardNotifications <code></code>\u00a0included </li> </ul> ATTRIBUTE DESCRIPTION <code>notifications</code> <p> TYPE: <code>list[Notification]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_readCardNotifications.notifications","title":"notifications  <code>instance-attribute</code>","text":"<pre><code>notifications: list[Notification]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_sortList","title":"Included_sortList","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_sortList <code></code>\u00a0included </li> </ul> ATTRIBUTE DESCRIPTION <code>cards</code> <p> TYPE: <code>list[Card]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_sortList.cards","title":"cards  <code>instance-attribute</code>","text":"<pre><code>cards: list[Card]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_updateUserPassword","title":"Included_updateUserPassword","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_updateUserPassword <code></code>\u00a0included </li> </ul> ATTRIBUTE DESCRIPTION <code>accessTokens</code> <p>New acces tokens (when updating own password)</p> <p> TYPE: <code>list[str]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Included_updateUserPassword.accessTokens","title":"accessTokens  <code>instance-attribute</code>","text":"<pre><code>accessTokens: list[str]\n</code></pre> <p>New acces tokens (when updating own password)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getBoard","title":"Item_getBoard","text":"<p>               Bases: <code>Board</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_getBoard <code></code>\u00a0item </li> </ul> ATTRIBUTE DESCRIPTION <code>alwaysDisplayCardCreator</code> <p>Whether to always display the card creator</p> <p> TYPE: <code>bool</code> </p> <code>createdAt</code> <p>When the board was created</p> <p> TYPE: <code>str</code> </p> <code>defaultCardType</code> <p>Default card type for new cards</p> <p> TYPE: <code>Literal['project', 'story']</code> </p> <code>defaultView</code> <p>Default view for the board</p> <p> TYPE: <code>Literal['kanban', 'grid', 'list']</code> </p> <code>expandTaskListsByDefault</code> <p>Whether to expand task lists by default</p> <p> TYPE: <code>bool</code> </p> <code>id</code> <p>Unique identifier for the board</p> <p> TYPE: <code>str</code> </p> <code>isSubscribed</code> <p>Whether the current user is subscribed to the board</p> <p> TYPE: <code>bool</code> </p> <code>limitCardTypesToDefaultOne</code> <p>Whether to limit card types to default one</p> <p> TYPE: <code>bool</code> </p> <code>name</code> <p>Name/title of the board</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the board within the project</p> <p> TYPE: <code>int</code> </p> <code>projectId</code> <p>ID of the project the board belongs to</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the board was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getBoard.alwaysDisplayCardCreator","title":"alwaysDisplayCardCreator  <code>instance-attribute</code>","text":"<pre><code>alwaysDisplayCardCreator: bool\n</code></pre> <p>Whether to always display the card creator</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getBoard.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the board was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getBoard.defaultCardType","title":"defaultCardType  <code>instance-attribute</code>","text":"<pre><code>defaultCardType: Literal['project', 'story']\n</code></pre> <p>Default card type for new cards</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getBoard.defaultView","title":"defaultView  <code>instance-attribute</code>","text":"<pre><code>defaultView: Literal['kanban', 'grid', 'list']\n</code></pre> <p>Default view for the board</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getBoard.expandTaskListsByDefault","title":"expandTaskListsByDefault  <code>instance-attribute</code>","text":"<pre><code>expandTaskListsByDefault: bool\n</code></pre> <p>Whether to expand task lists by default</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getBoard.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the board</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getBoard.isSubscribed","title":"isSubscribed  <code>instance-attribute</code>","text":"<pre><code>isSubscribed: bool\n</code></pre> <p>Whether the current user is subscribed to the board</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getBoard.limitCardTypesToDefaultOne","title":"limitCardTypesToDefaultOne  <code>instance-attribute</code>","text":"<pre><code>limitCardTypesToDefaultOne: bool\n</code></pre> <p>Whether to limit card types to default one</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getBoard.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the board</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getBoard.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the board within the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getBoard.projectId","title":"projectId  <code>instance-attribute</code>","text":"<pre><code>projectId: str\n</code></pre> <p>ID of the project the board belongs to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getBoard.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the board was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getCard","title":"Item_getCard","text":"<p>               Bases: <code>Card</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_getCard <code></code>\u00a0item </li> </ul> ATTRIBUTE DESCRIPTION <code>boardId</code> <p>ID of the board the card belongs to (denormalized)</p> <p> TYPE: <code>str</code> </p> <code>commentsTotal</code> <p>Total number of comments on the card</p> <p> TYPE: <code>int</code> </p> <code>coverAttachmentId</code> <p>ID of the attachment used as cover</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the card was created</p> <p> TYPE: <code>str</code> </p> <code>creatorUserId</code> <p>ID of the user who created the card</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>Detailed description of the card</p> <p> TYPE: <code>str</code> </p> <code>dueDate</code> <p>Due date for the card</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the card</p> <p> TYPE: <code>str</code> </p> <code>isClosed</code> <p>Whether the card is closed</p> <p> TYPE: <code>bool</code> </p> <code>isDueCompleted</code> <p>Whether the due date is completed</p> <p> TYPE: <code>bool</code> </p> <code>isSubscribed</code> <p>Whether the current user is subscribed to the card</p> <p> TYPE: <code>bool</code> </p> <code>listChangedAt</code> <p>When the card was last moved between lists</p> <p> TYPE: <code>str</code> </p> <code>listId</code> <p>ID of the list the card belongs to</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the card</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the card within the list</p> <p> TYPE: <code>int</code> </p> <code>prevListId</code> <p>ID of the previous list the card was in (available when in archive or trash)</p> <p> TYPE: <code>str</code> </p> <code>stopwatch</code> <p>Stopwatch data for time tracking</p> <p> TYPE: <code>Stopwatch | None</code> </p> <code>type</code> <p>Type of the card</p> <p> TYPE: <code>Literal['project', 'story']</code> </p> <code>updatedAt</code> <p>When the card was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getCard.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: str\n</code></pre> <p>ID of the board the card belongs to (denormalized)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getCard.commentsTotal","title":"commentsTotal  <code>instance-attribute</code>","text":"<pre><code>commentsTotal: int\n</code></pre> <p>Total number of comments on the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getCard.coverAttachmentId","title":"coverAttachmentId  <code>instance-attribute</code>","text":"<pre><code>coverAttachmentId: str\n</code></pre> <p>ID of the attachment used as cover</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getCard.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the card was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getCard.creatorUserId","title":"creatorUserId  <code>instance-attribute</code>","text":"<pre><code>creatorUserId: str\n</code></pre> <p>ID of the user who created the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getCard.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str\n</code></pre> <p>Detailed description of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getCard.dueDate","title":"dueDate  <code>instance-attribute</code>","text":"<pre><code>dueDate: str\n</code></pre> <p>Due date for the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getCard.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getCard.isClosed","title":"isClosed  <code>instance-attribute</code>","text":"<pre><code>isClosed: bool\n</code></pre> <p>Whether the card is closed</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getCard.isDueCompleted","title":"isDueCompleted  <code>instance-attribute</code>","text":"<pre><code>isDueCompleted: bool\n</code></pre> <p>Whether the due date is completed</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getCard.isSubscribed","title":"isSubscribed  <code>instance-attribute</code>","text":"<pre><code>isSubscribed: bool\n</code></pre> <p>Whether the current user is subscribed to the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getCard.listChangedAt","title":"listChangedAt  <code>instance-attribute</code>","text":"<pre><code>listChangedAt: str\n</code></pre> <p>When the card was last moved between lists</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getCard.listId","title":"listId  <code>instance-attribute</code>","text":"<pre><code>listId: str\n</code></pre> <p>ID of the list the card belongs to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getCard.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getCard.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the card within the list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getCard.prevListId","title":"prevListId  <code>instance-attribute</code>","text":"<pre><code>prevListId: str\n</code></pre> <p>ID of the previous list the card was in (available when in archive or trash)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getCard.stopwatch","title":"stopwatch  <code>instance-attribute</code>","text":"<pre><code>stopwatch: Stopwatch | None\n</code></pre> <p>Stopwatch data for time tracking</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getCard.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['project', 'story']\n</code></pre> <p>Type of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getCard.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the card was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getProject","title":"Item_getProject","text":"<p>               Bases: <code>Project</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_getProject <code></code>\u00a0item </li> </ul> ATTRIBUTE DESCRIPTION <code>backgroundGradient</code> <p>Gradient background for the project</p> <p> TYPE: <code>Literal['old-lime', 'ocean-dive', 'tzepesch-style', 'jungle-mesh', 'strawberry-dust', 'purple-rose', 'sun-scream', 'warm-rust', 'sky-change', 'green-eyes', 'blue-xchange', 'blood-orange', 'sour-peel', 'green-ninja', 'algae-green', 'coral-reef', 'steel-grey', 'heat-waves', 'velvet-lounge', 'purple-rain', 'blue-steel', 'blueish-curve', 'prism-light', 'green-mist', 'red-curtain']</code> </p> <code>backgroundImageId</code> <p>ID of the background image used as background</p> <p> TYPE: <code>str</code> </p> <code>backgroundType</code> <p>Type of background for the project</p> <p> TYPE: <code>Literal['gradient', 'image']</code> </p> <code>createdAt</code> <p>When the project was created</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>Detailed description of the project</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the project</p> <p> TYPE: <code>str</code> </p> <code>isFavorite</code> <p>Whether the project is marked as favorite by the current user</p> <p> TYPE: <code>bool</code> </p> <code>isHidden</code> <p>Whether the project is hidden</p> <p> TYPE: <code>bool</code> </p> <code>name</code> <p>Name/title of the project</p> <p> TYPE: <code>str</code> </p> <code>ownerProjectManagerId</code> <p>ID of the project manager who owns the project</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the project was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getProject.backgroundGradient","title":"backgroundGradient  <code>instance-attribute</code>","text":"<pre><code>backgroundGradient: Literal['old-lime', 'ocean-dive', 'tzepesch-style', 'jungle-mesh', 'strawberry-dust', 'purple-rose', 'sun-scream', 'warm-rust', 'sky-change', 'green-eyes', 'blue-xchange', 'blood-orange', 'sour-peel', 'green-ninja', 'algae-green', 'coral-reef', 'steel-grey', 'heat-waves', 'velvet-lounge', 'purple-rain', 'blue-steel', 'blueish-curve', 'prism-light', 'green-mist', 'red-curtain']\n</code></pre> <p>Gradient background for the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getProject.backgroundImageId","title":"backgroundImageId  <code>instance-attribute</code>","text":"<pre><code>backgroundImageId: str\n</code></pre> <p>ID of the background image used as background</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getProject.backgroundType","title":"backgroundType  <code>instance-attribute</code>","text":"<pre><code>backgroundType: Literal['gradient', 'image']\n</code></pre> <p>Type of background for the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getProject.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the project was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getProject.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str\n</code></pre> <p>Detailed description of the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getProject.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getProject.isFavorite","title":"isFavorite  <code>instance-attribute</code>","text":"<pre><code>isFavorite: bool\n</code></pre> <p>Whether the project is marked as favorite by the current user</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getProject.isHidden","title":"isHidden  <code>instance-attribute</code>","text":"<pre><code>isHidden: bool\n</code></pre> <p>Whether the project is hidden</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getProject.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getProject.ownerProjectManagerId","title":"ownerProjectManagerId  <code>instance-attribute</code>","text":"<pre><code>ownerProjectManagerId: str\n</code></pre> <p>ID of the project manager who owns the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getProject.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the project was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getTerms","title":"Item_getTerms","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_getTerms <code></code>\u00a0item </li> </ul> ATTRIBUTE DESCRIPTION <code>content</code> <p> TYPE: <code>str</code> </p> <code>language</code> <p> TYPE: <code>Literal['de-DE', 'en-US']</code> </p> <code>signature</code> <p> TYPE: <code>str</code> </p> <code>type</code> <p> TYPE: <code>Literal['general', 'extended']</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getTerms.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: str\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getTerms.language","title":"language  <code>instance-attribute</code>","text":"<pre><code>language: Literal['de-DE', 'en-US']\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getTerms.signature","title":"signature  <code>instance-attribute</code>","text":"<pre><code>signature: str\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Item_getTerms.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['general', 'extended']\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getCards","title":"Items_getCards","text":"<p>               Bases: <code>Card</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_getCards <code></code>\u00a0items </li> </ul> ATTRIBUTE DESCRIPTION <code>boardId</code> <p>ID of the board the card belongs to (denormalized)</p> <p> TYPE: <code>str</code> </p> <code>commentsTotal</code> <p>Total number of comments on the card</p> <p> TYPE: <code>int</code> </p> <code>coverAttachmentId</code> <p>ID of the attachment used as cover</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the card was created</p> <p> TYPE: <code>str</code> </p> <code>creatorUserId</code> <p>ID of the user who created the card</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>Detailed description of the card</p> <p> TYPE: <code>str</code> </p> <code>dueDate</code> <p>Due date for the card</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the card</p> <p> TYPE: <code>str</code> </p> <code>isClosed</code> <p>Whether the card is closed</p> <p> TYPE: <code>bool</code> </p> <code>isDueCompleted</code> <p>Whether the due date is completed</p> <p> TYPE: <code>bool</code> </p> <code>isSubscribed</code> <p>Whether the current user is subscribed to the card</p> <p> TYPE: <code>bool</code> </p> <code>listChangedAt</code> <p>When the card was last moved between lists</p> <p> TYPE: <code>str</code> </p> <code>listId</code> <p>ID of the list the card belongs to</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the card</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the card within the list</p> <p> TYPE: <code>int</code> </p> <code>prevListId</code> <p>ID of the previous list the card was in (available when in archive or trash)</p> <p> TYPE: <code>str</code> </p> <code>stopwatch</code> <p>Stopwatch data for time tracking</p> <p> TYPE: <code>Stopwatch | None</code> </p> <code>type</code> <p>Type of the card</p> <p> TYPE: <code>Literal['project', 'story']</code> </p> <code>updatedAt</code> <p>When the card was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getCards.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: str\n</code></pre> <p>ID of the board the card belongs to (denormalized)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getCards.commentsTotal","title":"commentsTotal  <code>instance-attribute</code>","text":"<pre><code>commentsTotal: int\n</code></pre> <p>Total number of comments on the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getCards.coverAttachmentId","title":"coverAttachmentId  <code>instance-attribute</code>","text":"<pre><code>coverAttachmentId: str\n</code></pre> <p>ID of the attachment used as cover</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getCards.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the card was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getCards.creatorUserId","title":"creatorUserId  <code>instance-attribute</code>","text":"<pre><code>creatorUserId: str\n</code></pre> <p>ID of the user who created the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getCards.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str\n</code></pre> <p>Detailed description of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getCards.dueDate","title":"dueDate  <code>instance-attribute</code>","text":"<pre><code>dueDate: str\n</code></pre> <p>Due date for the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getCards.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getCards.isClosed","title":"isClosed  <code>instance-attribute</code>","text":"<pre><code>isClosed: bool\n</code></pre> <p>Whether the card is closed</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getCards.isDueCompleted","title":"isDueCompleted  <code>instance-attribute</code>","text":"<pre><code>isDueCompleted: bool\n</code></pre> <p>Whether the due date is completed</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getCards.isSubscribed","title":"isSubscribed  <code>instance-attribute</code>","text":"<pre><code>isSubscribed: bool\n</code></pre> <p>Whether the current user is subscribed to the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getCards.listChangedAt","title":"listChangedAt  <code>instance-attribute</code>","text":"<pre><code>listChangedAt: str\n</code></pre> <p>When the card was last moved between lists</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getCards.listId","title":"listId  <code>instance-attribute</code>","text":"<pre><code>listId: str\n</code></pre> <p>ID of the list the card belongs to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getCards.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getCards.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the card within the list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getCards.prevListId","title":"prevListId  <code>instance-attribute</code>","text":"<pre><code>prevListId: str\n</code></pre> <p>ID of the previous list the card was in (available when in archive or trash)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getCards.stopwatch","title":"stopwatch  <code>instance-attribute</code>","text":"<pre><code>stopwatch: Stopwatch | None\n</code></pre> <p>Stopwatch data for time tracking</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getCards.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['project', 'story']\n</code></pre> <p>Type of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getCards.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the card was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getProjects","title":"Items_getProjects","text":"<p>               Bases: <code>Project</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <code></code>\u00a0Response_getProjects <code></code>\u00a0items </li> </ul> ATTRIBUTE DESCRIPTION <code>backgroundGradient</code> <p>Gradient background for the project</p> <p> TYPE: <code>Literal['old-lime', 'ocean-dive', 'tzepesch-style', 'jungle-mesh', 'strawberry-dust', 'purple-rose', 'sun-scream', 'warm-rust', 'sky-change', 'green-eyes', 'blue-xchange', 'blood-orange', 'sour-peel', 'green-ninja', 'algae-green', 'coral-reef', 'steel-grey', 'heat-waves', 'velvet-lounge', 'purple-rain', 'blue-steel', 'blueish-curve', 'prism-light', 'green-mist', 'red-curtain']</code> </p> <code>backgroundImageId</code> <p>ID of the background image used as background</p> <p> TYPE: <code>str</code> </p> <code>backgroundType</code> <p>Type of background for the project</p> <p> TYPE: <code>Literal['gradient', 'image']</code> </p> <code>createdAt</code> <p>When the project was created</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>Detailed description of the project</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the project</p> <p> TYPE: <code>str</code> </p> <code>isFavorite</code> <p>Whether the project is marked as favorite by the current user</p> <p> TYPE: <code>bool</code> </p> <code>isHidden</code> <p>Whether the project is hidden</p> <p> TYPE: <code>bool</code> </p> <code>name</code> <p>Name/title of the project</p> <p> TYPE: <code>str</code> </p> <code>ownerProjectManagerId</code> <p>ID of the project manager who owns the project</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the project was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getProjects.backgroundGradient","title":"backgroundGradient  <code>instance-attribute</code>","text":"<pre><code>backgroundGradient: Literal['old-lime', 'ocean-dive', 'tzepesch-style', 'jungle-mesh', 'strawberry-dust', 'purple-rose', 'sun-scream', 'warm-rust', 'sky-change', 'green-eyes', 'blue-xchange', 'blood-orange', 'sour-peel', 'green-ninja', 'algae-green', 'coral-reef', 'steel-grey', 'heat-waves', 'velvet-lounge', 'purple-rain', 'blue-steel', 'blueish-curve', 'prism-light', 'green-mist', 'red-curtain']\n</code></pre> <p>Gradient background for the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getProjects.backgroundImageId","title":"backgroundImageId  <code>instance-attribute</code>","text":"<pre><code>backgroundImageId: str\n</code></pre> <p>ID of the background image used as background</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getProjects.backgroundType","title":"backgroundType  <code>instance-attribute</code>","text":"<pre><code>backgroundType: Literal['gradient', 'image']\n</code></pre> <p>Type of background for the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getProjects.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the project was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getProjects.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str\n</code></pre> <p>Detailed description of the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getProjects.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getProjects.isFavorite","title":"isFavorite  <code>instance-attribute</code>","text":"<pre><code>isFavorite: bool\n</code></pre> <p>Whether the project is marked as favorite by the current user</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getProjects.isHidden","title":"isHidden  <code>instance-attribute</code>","text":"<pre><code>isHidden: bool\n</code></pre> <p>Whether the project is hidden</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getProjects.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getProjects.ownerProjectManagerId","title":"ownerProjectManagerId  <code>instance-attribute</code>","text":"<pre><code>ownerProjectManagerId: str\n</code></pre> <p>ID of the project manager who owns the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Items_getProjects.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the project was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Label","title":"Label","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0labels </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0labels </li> <li> <code></code>\u00a0Response_createLabel <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteLabel <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateLabel <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Label <code></code>\u00a0Label </li> </ul> ATTRIBUTE DESCRIPTION <code>boardId</code> <p>ID of the board the label belongs to</p> <p> TYPE: <code>str</code> </p> <code>color</code> <p>Color of the label</p> <p> TYPE: <code>Literal['muddy-grey', 'autumn-leafs', 'morning-sky', 'antique-blue', 'egg-yellow', 'desert-sand', 'dark-granite', 'fresh-salad', 'lagoon-blue', 'midnight-blue', 'light-orange', 'pumpkin-orange', 'light-concrete', 'sunny-grass', 'navy-blue', 'lilac-eyes', 'apricot-red', 'orange-peel', 'silver-glint', 'bright-moss', 'deep-ocean', 'summer-sky', 'berry-red', 'light-cocoa', 'grey-stone', 'tank-green', 'coral-green', 'sugar-plum', 'pink-tulip', 'shady-rust', 'wet-rock', 'wet-moss', 'turquoise-sea', 'lavender-fields', 'piggy-red', 'light-mud', 'gun-metal', 'modern-green', 'french-coast', 'sweet-lilac', 'red-burgundy', 'pirate-gold']</code> </p> <code>createdAt</code> <p>When the label was created</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the label</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the label</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the label within the board</p> <p> TYPE: <code>int</code> </p> <code>updatedAt</code> <p>When the label was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Label.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: str\n</code></pre> <p>ID of the board the label belongs to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Label.color","title":"color  <code>instance-attribute</code>","text":"<pre><code>color: Literal['muddy-grey', 'autumn-leafs', 'morning-sky', 'antique-blue', 'egg-yellow', 'desert-sand', 'dark-granite', 'fresh-salad', 'lagoon-blue', 'midnight-blue', 'light-orange', 'pumpkin-orange', 'light-concrete', 'sunny-grass', 'navy-blue', 'lilac-eyes', 'apricot-red', 'orange-peel', 'silver-glint', 'bright-moss', 'deep-ocean', 'summer-sky', 'berry-red', 'light-cocoa', 'grey-stone', 'tank-green', 'coral-green', 'sugar-plum', 'pink-tulip', 'shady-rust', 'wet-rock', 'wet-moss', 'turquoise-sea', 'lavender-fields', 'piggy-red', 'light-mud', 'gun-metal', 'modern-green', 'french-coast', 'sweet-lilac', 'red-burgundy', 'pirate-gold']\n</code></pre> <p>Color of the label</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Label.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the label was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Label.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the label</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Label.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the label</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Label.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the label within the board</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Label.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the label was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.List","title":"List","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0lists </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0lists </li> <li> <code></code>\u00a0Response_clearList <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_createList <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteList <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_getList <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_moveListCards <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_sortList <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateList <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models List <code></code>\u00a0List </li> </ul> ATTRIBUTE DESCRIPTION <code>boardId</code> <p>ID of the board the list belongs to</p> <p> TYPE: <code>str</code> </p> <code>color</code> <p>Color for the list</p> <p> TYPE: <code>Literal['berry-red', 'pumpkin-orange', 'lagoon-blue', 'pink-tulip', 'light-mud', 'orange-peel', 'bright-moss', 'antique-blue', 'dark-granite', 'turquoise-sea']</code> </p> <code>createdAt</code> <p>When the list was created</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the list</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the list</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the list within the board</p> <p> TYPE: <code>int</code> </p> <code>type</code> <p>Type/status of the list</p> <p> TYPE: <code>Literal['active', 'closed', 'archive', 'trash']</code> </p> <code>updatedAt</code> <p>When the list was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.List.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: str\n</code></pre> <p>ID of the board the list belongs to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.List.color","title":"color  <code>instance-attribute</code>","text":"<pre><code>color: Literal['berry-red', 'pumpkin-orange', 'lagoon-blue', 'pink-tulip', 'light-mud', 'orange-peel', 'bright-moss', 'antique-blue', 'dark-granite', 'turquoise-sea']\n</code></pre> <p>Color for the list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.List.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the list was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.List.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.List.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.List.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the list within the board</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.List.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['active', 'closed', 'archive', 'trash']\n</code></pre> <p>Type/status of the list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.List.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the list was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Notification","title":"Notification","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <ul> <li> <code></code>\u00a0Included_readCardNotifications <code></code>\u00a0notifications </li> <li> <code></code>\u00a0Response_getNotification <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_getNotifications <code></code>\u00a0items </li> <li> <code></code>\u00a0Response_readAllNotifications <code></code>\u00a0items </li> <li> <code></code>\u00a0Response_updateNotification <code></code>\u00a0item </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Notification <code></code>\u00a0Notification </li> </ul> ATTRIBUTE DESCRIPTION <code>actionId</code> <p>ID of the action associated with the notification</p> <p> TYPE: <code>str</code> </p> <code>boardId</code> <p>ID of the board associated with the notification (denormalized)</p> <p> TYPE: <code>str</code> </p> <code>cardId</code> <p>ID of the card associated with the notification</p> <p> TYPE: <code>str</code> </p> <code>commentId</code> <p>ID of the comment associated with the notification</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the notification was created</p> <p> TYPE: <code>str</code> </p> <code>creatorUserId</code> <p>ID of the user who created the notification</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>Notification specific data (varies by type)</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>id</code> <p>Unique identifier for the notification</p> <p> TYPE: <code>str</code> </p> <code>isRead</code> <p>Whether the notification has been read</p> <p> TYPE: <code>bool</code> </p> <code>type</code> <p>Type of the notification</p> <p> TYPE: <code>Literal['moveCard', 'commentCard', 'addMemberToCard', 'mentionInComment']</code> </p> <code>updatedAt</code> <p>When the notification was last updated</p> <p> TYPE: <code>str</code> </p> <code>userId</code> <p>ID of the user who receives the notification</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Notification.actionId","title":"actionId  <code>instance-attribute</code>","text":"<pre><code>actionId: str\n</code></pre> <p>ID of the action associated with the notification</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Notification.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: str\n</code></pre> <p>ID of the board associated with the notification (denormalized)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Notification.cardId","title":"cardId  <code>instance-attribute</code>","text":"<pre><code>cardId: str\n</code></pre> <p>ID of the card associated with the notification</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Notification.commentId","title":"commentId  <code>instance-attribute</code>","text":"<pre><code>commentId: str\n</code></pre> <p>ID of the comment associated with the notification</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Notification.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the notification was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Notification.creatorUserId","title":"creatorUserId  <code>instance-attribute</code>","text":"<pre><code>creatorUserId: str\n</code></pre> <p>ID of the user who created the notification</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Notification.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: dict[str, Any]\n</code></pre> <p>Notification specific data (varies by type)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Notification.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the notification</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Notification.isRead","title":"isRead  <code>instance-attribute</code>","text":"<pre><code>isRead: bool\n</code></pre> <p>Whether the notification has been read</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Notification.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['moveCard', 'commentCard', 'addMemberToCard', 'mentionInComment']\n</code></pre> <p>Type of the notification</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Notification.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the notification was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Notification.userId","title":"userId  <code>instance-attribute</code>","text":"<pre><code>userId: str\n</code></pre> <p>ID of the user who receives the notification</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.NotificationService","title":"NotificationService","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0notification_services </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_getProject <code></code>\u00a0notificationServices </li> <li> <code></code>\u00a0Included_getProjects <code></code>\u00a0notificationServices </li> <li> <code></code>\u00a0Included_getUser <code></code>\u00a0notificationServices </li> <li> <code></code>\u00a0Response_createBoardNotificationService <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_createUserNotificationService <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteNotificationService <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_testNotificationService <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateNotificationService <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Notification Service <code></code>\u00a0NotificationService </li> </ul> ATTRIBUTE DESCRIPTION <code>boardId</code> <p>ID of the board the service is associated with</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the notification service was created</p> <p> TYPE: <code>str</code> </p> <code>format</code> <p>Format for notification messages</p> <p> TYPE: <code>Literal['text', 'markdown', 'html']</code> </p> <code>id</code> <p>Unique identifier for the notification service</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the notification service was last updated</p> <p> TYPE: <code>str</code> </p> <code>url</code> <p>URL endpoint for notifications</p> <p> TYPE: <code>str</code> </p> <code>userId</code> <p>ID of the user the service is associated with</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.NotificationService.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: str\n</code></pre> <p>ID of the board the service is associated with</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.NotificationService.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the notification service was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.NotificationService.format","title":"format  <code>instance-attribute</code>","text":"<pre><code>format: Literal['text', 'markdown', 'html']\n</code></pre> <p>Format for notification messages</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.NotificationService.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the notification service</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.NotificationService.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the notification service was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.NotificationService.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre> <p>URL endpoint for notifications</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.NotificationService.userId","title":"userId  <code>instance-attribute</code>","text":"<pre><code>userId: str\n</code></pre> <p>ID of the user the service is associated with</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Project","title":"Project","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0projects </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0projects </li> <li> <code></code>\u00a0Response_createProject <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteProject <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateProject <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 <ul> <li> models Project <code></code>\u00a0Project </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Item_getProject </li> <li> <code></code>\u00a0Items_getProjects </li> </ul> </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>backgroundGradient</code> <p>Gradient background for the project</p> <p> TYPE: <code>Literal['old-lime', 'ocean-dive', 'tzepesch-style', 'jungle-mesh', 'strawberry-dust', 'purple-rose', 'sun-scream', 'warm-rust', 'sky-change', 'green-eyes', 'blue-xchange', 'blood-orange', 'sour-peel', 'green-ninja', 'algae-green', 'coral-reef', 'steel-grey', 'heat-waves', 'velvet-lounge', 'purple-rain', 'blue-steel', 'blueish-curve', 'prism-light', 'green-mist', 'red-curtain']</code> </p> <code>backgroundImageId</code> <p>ID of the background image used as background</p> <p> TYPE: <code>str</code> </p> <code>backgroundType</code> <p>Type of background for the project</p> <p> TYPE: <code>Literal['gradient', 'image']</code> </p> <code>createdAt</code> <p>When the project was created</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>Detailed description of the project</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the project</p> <p> TYPE: <code>str</code> </p> <code>isHidden</code> <p>Whether the project is hidden</p> <p> TYPE: <code>bool</code> </p> <code>name</code> <p>Name/title of the project</p> <p> TYPE: <code>str</code> </p> <code>ownerProjectManagerId</code> <p>ID of the project manager who owns the project</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the project was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Project.backgroundGradient","title":"backgroundGradient  <code>instance-attribute</code>","text":"<pre><code>backgroundGradient: Literal['old-lime', 'ocean-dive', 'tzepesch-style', 'jungle-mesh', 'strawberry-dust', 'purple-rose', 'sun-scream', 'warm-rust', 'sky-change', 'green-eyes', 'blue-xchange', 'blood-orange', 'sour-peel', 'green-ninja', 'algae-green', 'coral-reef', 'steel-grey', 'heat-waves', 'velvet-lounge', 'purple-rain', 'blue-steel', 'blueish-curve', 'prism-light', 'green-mist', 'red-curtain']\n</code></pre> <p>Gradient background for the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Project.backgroundImageId","title":"backgroundImageId  <code>instance-attribute</code>","text":"<pre><code>backgroundImageId: str\n</code></pre> <p>ID of the background image used as background</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Project.backgroundType","title":"backgroundType  <code>instance-attribute</code>","text":"<pre><code>backgroundType: Literal['gradient', 'image']\n</code></pre> <p>Type of background for the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Project.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the project was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Project.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str\n</code></pre> <p>Detailed description of the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Project.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Project.isHidden","title":"isHidden  <code>instance-attribute</code>","text":"<pre><code>isHidden: bool\n</code></pre> <p>Whether the project is hidden</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Project.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Project.ownerProjectManagerId","title":"ownerProjectManagerId  <code>instance-attribute</code>","text":"<pre><code>ownerProjectManagerId: str\n</code></pre> <p>ID of the project manager who owns the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Project.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the project was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.ProjectManager","title":"ProjectManager","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0project_managers </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_createProject <code></code>\u00a0projectManagers </li> <li> <code></code>\u00a0Included_getProject <code></code>\u00a0projectManagers </li> <li> <code></code>\u00a0Included_getProjects <code></code>\u00a0projectManagers </li> <li> <code></code>\u00a0Response_createProjectManager <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteProjectManager <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Project Manager <code></code>\u00a0ProjectManager </li> </ul> ATTRIBUTE DESCRIPTION <code>createdAt</code> <p>When the project manager was created</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the project manager</p> <p> TYPE: <code>str</code> </p> <code>projectId</code> <p>ID of the project the manager is associated with</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the project manager was last updated</p> <p> TYPE: <code>str</code> </p> <code>userId</code> <p>ID of the user who is assigned as project manager</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.ProjectManager.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the project manager was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.ProjectManager.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the project manager</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.ProjectManager.projectId","title":"projectId  <code>instance-attribute</code>","text":"<pre><code>projectId: str\n</code></pre> <p>ID of the project the manager is associated with</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.ProjectManager.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the project manager was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.ProjectManager.userId","title":"userId  <code>instance-attribute</code>","text":"<pre><code>userId: str\n</code></pre> <p>ID of the user who is assigned as project manager</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_acceptTerms","title":"Request_acceptTerms","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0acceptTerms </li> </ul> ATTRIBUTE DESCRIPTION <code>pendingToken</code> <p>Pending token received from the authentication flow</p> <p> TYPE: <code>str</code> </p> <code>signature</code> <p>Terms signature hash based on user role</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_acceptTerms.pendingToken","title":"pendingToken  <code>instance-attribute</code>","text":"<pre><code>pendingToken: str\n</code></pre> <p>Pending token received from the authentication flow</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_acceptTerms.signature","title":"signature  <code>instance-attribute</code>","text":"<pre><code>signature: str\n</code></pre> <p>Terms signature hash based on user role</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createAccessToken","title":"Request_createAccessToken","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createAccessToken </li> </ul> ATTRIBUTE DESCRIPTION <code>emailOrUsername</code> <p>Email address or username of the user</p> <p> TYPE: <code>str</code> </p> <code>password</code> <p>Password of the user</p> <p> TYPE: <code>str</code> </p> <code>withHttpOnlyToken</code> <p>Whether to include an HTTP-only authentication cookie</p> <p> TYPE: <code>NotRequired[bool]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createAccessToken.emailOrUsername","title":"emailOrUsername  <code>instance-attribute</code>","text":"<pre><code>emailOrUsername: str\n</code></pre> <p>Email address or username of the user</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createAccessToken.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password: str\n</code></pre> <p>Password of the user</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createAccessToken.withHttpOnlyToken","title":"withHttpOnlyToken  <code>instance-attribute</code>","text":"<pre><code>withHttpOnlyToken: NotRequired[bool]\n</code></pre> <p>Whether to include an HTTP-only authentication cookie</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createAttachment","title":"Request_createAttachment","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createAttachment </li> </ul> ATTRIBUTE DESCRIPTION <code>file</code> <p>File to upload</p> <p> TYPE: <code>NotRequired[str | bytes]</code> </p> <code>name</code> <p>Name/title of the attachment</p> <p> TYPE: <code>str</code> </p> <code>requestId</code> <p>Request ID for tracking</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>type</code> <p>Type of the attachment</p> <p> TYPE: <code>Literal['file', 'link']</code> </p> <code>url</code> <p>URL for the link attachment</p> <p> TYPE: <code>NotRequired[str]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createAttachment.file","title":"file  <code>instance-attribute</code>","text":"<pre><code>file: NotRequired[str | bytes]\n</code></pre> <p>File to upload</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createAttachment.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the attachment</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createAttachment.requestId","title":"requestId  <code>instance-attribute</code>","text":"<pre><code>requestId: NotRequired[str]\n</code></pre> <p>Request ID for tracking</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createAttachment.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['file', 'link']\n</code></pre> <p>Type of the attachment</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createAttachment.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: NotRequired[str]\n</code></pre> <p>URL for the link attachment</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createBackgroundImage","title":"Request_createBackgroundImage","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createBackgroundImage </li> </ul> ATTRIBUTE DESCRIPTION <code>file</code> <p>Background image file (must be an image format)</p> <p> TYPE: <code>bytes</code> </p> <code>requestId</code> <p>Request ID for tracking</p> <p> TYPE: <code>NotRequired[str]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createBackgroundImage.file","title":"file  <code>instance-attribute</code>","text":"<pre><code>file: bytes\n</code></pre> <p>Background image file (must be an image format)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createBackgroundImage.requestId","title":"requestId  <code>instance-attribute</code>","text":"<pre><code>requestId: NotRequired[str]\n</code></pre> <p>Request ID for tracking</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createBaseCustomFieldGroup","title":"Request_createBaseCustomFieldGroup","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createBaseCustomFieldGroup </li> </ul> ATTRIBUTE DESCRIPTION <code>name</code> <p>Name/title of the base custom field group</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createBaseCustomFieldGroup.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the base custom field group</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createBoard","title":"Request_createBoard","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createBoard </li> </ul> ATTRIBUTE DESCRIPTION <code>importFile</code> <p>Import file</p> <p> TYPE: <code>NotRequired[bytes]</code> </p> <code>importType</code> <p>Type of import</p> <p> TYPE: <code>NotRequired[Literal['trello']]</code> </p> <code>name</code> <p>Name/title of the board</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the board within the project</p> <p> TYPE: <code>int</code> </p> <code>requestId</code> <p>Request ID for tracking</p> <p> TYPE: <code>NotRequired[str]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createBoard.importFile","title":"importFile  <code>instance-attribute</code>","text":"<pre><code>importFile: NotRequired[bytes]\n</code></pre> <p>Import file</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createBoard.importType","title":"importType  <code>instance-attribute</code>","text":"<pre><code>importType: NotRequired[Literal['trello']]\n</code></pre> <p>Type of import</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createBoard.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the board</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createBoard.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the board within the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createBoard.requestId","title":"requestId  <code>instance-attribute</code>","text":"<pre><code>requestId: NotRequired[str]\n</code></pre> <p>Request ID for tracking</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createBoardCustomFieldGroup","title":"Request_createBoardCustomFieldGroup","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createBoardCustomFieldGroup </li> </ul> ATTRIBUTE DESCRIPTION <code>baseCustomFieldGroupId</code> <p>ID of the base custom field group used as a template</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>name</code> <p>Name/title of the custom field group (required if <code>baseCustomFieldGroupId</code> is not provided)</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>position</code> <p>Position of the custom field group within the board</p> <p> TYPE: <code>int</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createBoardCustomFieldGroup.baseCustomFieldGroupId","title":"baseCustomFieldGroupId  <code>instance-attribute</code>","text":"<pre><code>baseCustomFieldGroupId: NotRequired[str]\n</code></pre> <p>ID of the base custom field group used as a template</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createBoardCustomFieldGroup.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: NotRequired[str | None]\n</code></pre> <p>Name/title of the custom field group (required if <code>baseCustomFieldGroupId</code> is not provided)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createBoardCustomFieldGroup.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the custom field group within the board</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createBoardMembership","title":"Request_createBoardMembership","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createBoardMembership </li> </ul> ATTRIBUTE DESCRIPTION <code>canComment</code> <p>Whether the user can comment on cards (applies only to viewers)</p> <p> TYPE: <code>NotRequired[bool | None]</code> </p> <code>role</code> <p>Role of the user in the board</p> <p> TYPE: <code>Literal['editor', 'viewer']</code> </p> <code>userId</code> <p>ID of the user who is a member of the board</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createBoardMembership.canComment","title":"canComment  <code>instance-attribute</code>","text":"<pre><code>canComment: NotRequired[bool | None]\n</code></pre> <p>Whether the user can comment on cards (applies only to viewers)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createBoardMembership.role","title":"role  <code>instance-attribute</code>","text":"<pre><code>role: Literal['editor', 'viewer']\n</code></pre> <p>Role of the user in the board</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createBoardMembership.userId","title":"userId  <code>instance-attribute</code>","text":"<pre><code>userId: str\n</code></pre> <p>ID of the user who is a member of the board</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createBoardNotificationService","title":"Request_createBoardNotificationService","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createBoardNotificationService </li> </ul> ATTRIBUTE DESCRIPTION <code>format</code> <p>Format for notification messages</p> <p> TYPE: <code>Literal['text', 'markdown', 'html']</code> </p> <code>url</code> <p>URL endpoint for notifications</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createBoardNotificationService.format","title":"format  <code>instance-attribute</code>","text":"<pre><code>format: Literal['text', 'markdown', 'html']\n</code></pre> <p>Format for notification messages</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createBoardNotificationService.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre> <p>URL endpoint for notifications</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCard","title":"Request_createCard","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createCard </li> </ul> ATTRIBUTE DESCRIPTION <code>description</code> <p>Detailed description of the card</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>dueDate</code> <p>Due date for the card (<code>datetime</code> only allowed when using <code>Card.create_card</code>, otherwise use ISO string)</p> <p> TYPE: <code>NotRequired[str | datetime]</code> </p> <code>isDueCompleted</code> <p>Whether the due date is completed</p> <p> TYPE: <code>NotRequired[bool | None]</code> </p> <code>name</code> <p>Name/title of the card</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the card within the list</p> <p> TYPE: <code>NotRequired[int | None]</code> </p> <code>stopwatch</code> <p>Stopwatch data for time tracking</p> <p> TYPE: <code>NotRequired[dict[str, Any] | None]</code> </p> <code>type</code> <p>Type of the card</p> <p> TYPE: <code>Literal['project', 'story']</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCard.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: NotRequired[str | None]\n</code></pre> <p>Detailed description of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCard.dueDate","title":"dueDate  <code>instance-attribute</code>","text":"<pre><code>dueDate: NotRequired[str | datetime]\n</code></pre> <p>Due date for the card (<code>datetime</code> only allowed when using <code>Card.create_card</code>, otherwise use ISO string)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCard.isDueCompleted","title":"isDueCompleted  <code>instance-attribute</code>","text":"<pre><code>isDueCompleted: NotRequired[bool | None]\n</code></pre> <p>Whether the due date is completed</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCard.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCard.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: NotRequired[int | None]\n</code></pre> <p>Position of the card within the list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCard.stopwatch","title":"stopwatch  <code>instance-attribute</code>","text":"<pre><code>stopwatch: NotRequired[dict[str, Any] | None]\n</code></pre> <p>Stopwatch data for time tracking</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCard.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['project', 'story']\n</code></pre> <p>Type of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCardCustomFieldGroup","title":"Request_createCardCustomFieldGroup","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createCardCustomFieldGroup </li> </ul> ATTRIBUTE DESCRIPTION <code>baseCustomFieldGroupId</code> <p>ID of the base custom field group used as a template</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>name</code> <p>Name/title of the custom field group (required if <code>baseCustomFieldGroupId</code> is not provided)</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>position</code> <p>Position of the custom field group within the card</p> <p> TYPE: <code>int</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCardCustomFieldGroup.baseCustomFieldGroupId","title":"baseCustomFieldGroupId  <code>instance-attribute</code>","text":"<pre><code>baseCustomFieldGroupId: NotRequired[str]\n</code></pre> <p>ID of the base custom field group used as a template</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCardCustomFieldGroup.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: NotRequired[str | None]\n</code></pre> <p>Name/title of the custom field group (required if <code>baseCustomFieldGroupId</code> is not provided)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCardCustomFieldGroup.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the custom field group within the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCardLabel","title":"Request_createCardLabel","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createCardLabel </li> </ul> ATTRIBUTE DESCRIPTION <code>labelId</code> <p>ID of the label to add to the card</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCardLabel.labelId","title":"labelId  <code>instance-attribute</code>","text":"<pre><code>labelId: str\n</code></pre> <p>ID of the label to add to the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCardMembership","title":"Request_createCardMembership","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createCardMembership </li> </ul> ATTRIBUTE DESCRIPTION <code>userId</code> <p>ID of the card to add the user to</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCardMembership.userId","title":"userId  <code>instance-attribute</code>","text":"<pre><code>userId: str\n</code></pre> <p>ID of the card to add the user to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createComment","title":"Request_createComment","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createComment </li> </ul> ATTRIBUTE DESCRIPTION <code>text</code> <p>Content of the comment</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createComment.text","title":"text  <code>instance-attribute</code>","text":"<pre><code>text: str\n</code></pre> <p>Content of the comment</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCustomFieldInBaseGroup","title":"Request_createCustomFieldInBaseGroup","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createCustomFieldInBaseGroup </li> </ul> ATTRIBUTE DESCRIPTION <code>name</code> <p>Name/title of the custom field</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the custom field within the group</p> <p> TYPE: <code>int</code> </p> <code>showOnFrontOfCard</code> <p>Whether to show the field on the front of cards</p> <p> TYPE: <code>NotRequired[bool]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCustomFieldInBaseGroup.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the custom field</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCustomFieldInBaseGroup.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the custom field within the group</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCustomFieldInBaseGroup.showOnFrontOfCard","title":"showOnFrontOfCard  <code>instance-attribute</code>","text":"<pre><code>showOnFrontOfCard: NotRequired[bool]\n</code></pre> <p>Whether to show the field on the front of cards</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCustomFieldInGroup","title":"Request_createCustomFieldInGroup","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createCustomFieldInGroup </li> </ul> ATTRIBUTE DESCRIPTION <code>name</code> <p>Name/title of the custom field</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the custom field within the group</p> <p> TYPE: <code>int</code> </p> <code>showOnFrontOfCard</code> <p>Whether to show the field on the front of cards</p> <p> TYPE: <code>NotRequired[bool]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCustomFieldInGroup.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the custom field</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCustomFieldInGroup.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the custom field within the group</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createCustomFieldInGroup.showOnFrontOfCard","title":"showOnFrontOfCard  <code>instance-attribute</code>","text":"<pre><code>showOnFrontOfCard: NotRequired[bool]\n</code></pre> <p>Whether to show the field on the front of cards</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createLabel","title":"Request_createLabel","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createLabel </li> </ul> ATTRIBUTE DESCRIPTION <code>color</code> <p>Color of the label</p> <p> TYPE: <code>Literal['muddy-grey', 'autumn-leafs', 'morning-sky', 'antique-blue', 'egg-yellow', 'desert-sand', 'dark-granite', 'fresh-salad', 'lagoon-blue', 'midnight-blue', 'light-orange', 'pumpkin-orange', 'light-concrete', 'sunny-grass', 'navy-blue', 'lilac-eyes', 'apricot-red', 'orange-peel', 'silver-glint', 'bright-moss', 'deep-ocean', 'summer-sky', 'berry-red', 'light-cocoa', 'grey-stone', 'tank-green', 'coral-green', 'sugar-plum', 'pink-tulip', 'shady-rust', 'wet-rock', 'wet-moss', 'turquoise-sea', 'lavender-fields', 'piggy-red', 'light-mud', 'gun-metal', 'modern-green', 'french-coast', 'sweet-lilac', 'red-burgundy', 'pirate-gold']</code> </p> <code>name</code> <p>Name/title of the label</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>position</code> <p>Position of the label within the board</p> <p> TYPE: <code>int</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createLabel.color","title":"color  <code>instance-attribute</code>","text":"<pre><code>color: Literal['muddy-grey', 'autumn-leafs', 'morning-sky', 'antique-blue', 'egg-yellow', 'desert-sand', 'dark-granite', 'fresh-salad', 'lagoon-blue', 'midnight-blue', 'light-orange', 'pumpkin-orange', 'light-concrete', 'sunny-grass', 'navy-blue', 'lilac-eyes', 'apricot-red', 'orange-peel', 'silver-glint', 'bright-moss', 'deep-ocean', 'summer-sky', 'berry-red', 'light-cocoa', 'grey-stone', 'tank-green', 'coral-green', 'sugar-plum', 'pink-tulip', 'shady-rust', 'wet-rock', 'wet-moss', 'turquoise-sea', 'lavender-fields', 'piggy-red', 'light-mud', 'gun-metal', 'modern-green', 'french-coast', 'sweet-lilac', 'red-burgundy', 'pirate-gold']\n</code></pre> <p>Color of the label</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createLabel.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: NotRequired[str | None]\n</code></pre> <p>Name/title of the label</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createLabel.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the label within the board</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createList","title":"Request_createList","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createList </li> </ul> ATTRIBUTE DESCRIPTION <code>name</code> <p>Name/title of the list</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the list within the board</p> <p> TYPE: <code>int</code> </p> <code>type</code> <p>Type/status of the list</p> <p> TYPE: <code>Literal['active', 'closed']</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createList.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createList.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the list within the board</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createList.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['active', 'closed']\n</code></pre> <p>Type/status of the list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createProject","title":"Request_createProject","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createProject </li> </ul> ATTRIBUTE DESCRIPTION <code>description</code> <p>Detailed description of the project</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>name</code> <p>Name/title of the project</p> <p> TYPE: <code>str</code> </p> <code>type</code> <p>Type of the project</p> <p> TYPE: <code>Literal['shared', 'private']</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createProject.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: NotRequired[str | None]\n</code></pre> <p>Detailed description of the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createProject.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createProject.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['shared', 'private']\n</code></pre> <p>Type of the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createProjectManager","title":"Request_createProjectManager","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createProjectManager </li> </ul> ATTRIBUTE DESCRIPTION <code>userId</code> <p>ID of the user who is assigned as project manager</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createProjectManager.userId","title":"userId  <code>instance-attribute</code>","text":"<pre><code>userId: str\n</code></pre> <p>ID of the user who is assigned as project manager</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createTask","title":"Request_createTask","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createTask </li> </ul> ATTRIBUTE DESCRIPTION <code>isCompleted</code> <p>Whether the task is completed</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>linkedCardId</code> <p>ID of the card linked to the task</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>name</code> <p>Name/title of the task (required if <code>linkedCardId</code> is not provided)</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>position</code> <p>Position of the task within the task list</p> <p> TYPE: <code>int</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createTask.isCompleted","title":"isCompleted  <code>instance-attribute</code>","text":"<pre><code>isCompleted: NotRequired[bool]\n</code></pre> <p>Whether the task is completed</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createTask.linkedCardId","title":"linkedCardId  <code>instance-attribute</code>","text":"<pre><code>linkedCardId: NotRequired[str]\n</code></pre> <p>ID of the card linked to the task</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createTask.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: NotRequired[str | None]\n</code></pre> <p>Name/title of the task (required if <code>linkedCardId</code> is not provided)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createTask.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the task within the task list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createTaskList","title":"Request_createTaskList","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createTaskList </li> </ul> ATTRIBUTE DESCRIPTION <code>hideCompletedTasks</code> <p>Whether to hide completed tasks</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>name</code> <p>Name/title of the task list</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the task list within the card</p> <p> TYPE: <code>int</code> </p> <code>showOnFrontOfCard</code> <p>Whether to show the task list on the front of the card</p> <p> TYPE: <code>NotRequired[bool]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createTaskList.hideCompletedTasks","title":"hideCompletedTasks  <code>instance-attribute</code>","text":"<pre><code>hideCompletedTasks: NotRequired[bool]\n</code></pre> <p>Whether to hide completed tasks</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createTaskList.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the task list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createTaskList.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the task list within the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createTaskList.showOnFrontOfCard","title":"showOnFrontOfCard  <code>instance-attribute</code>","text":"<pre><code>showOnFrontOfCard: NotRequired[bool]\n</code></pre> <p>Whether to show the task list on the front of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createUser","title":"Request_createUser","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createUser </li> </ul> ATTRIBUTE DESCRIPTION <code>email</code> <p>Email address for login and notifications</p> <p> TYPE: <code>str</code> </p> <code>language</code> <p>Preferred language for user interface and notifications</p> <p> TYPE: <code>NotRequired[Literal['ar-YE', 'bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-GB', 'en-US', 'es-ES', 'et-EE', 'fa-IR', 'fi-FI', 'fr-FR', 'hu-HU', 'id-ID', 'it-IT', 'ja-JP', 'ko-KR', 'nl-NL', 'pl-PL', 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sk-SK', 'sr-Cyrl-RS', 'sr-Latn-RS', 'sv-SE', 'tr-TR', 'uk-UA', 'uz-UZ', 'zh-CN', 'zh-TW'] | None]</code> </p> <code>name</code> <p>Full display name of the user</p> <p> TYPE: <code>str</code> </p> <code>organization</code> <p>Organization or company name</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>password</code> <p>Password for user authentication (must meet password requirements)</p> <p> TYPE: <code>str</code> </p> <code>phone</code> <p>Contact phone number</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>role</code> <p>User role defining access permissions</p> <p> TYPE: <code>Literal['admin', 'projectOwner', 'boardUser']</code> </p> <code>subscribeToCardWhenCommenting</code> <p>Whether the user subscribes to cards when commenting</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>subscribeToOwnCards</code> <p>Whether the user subscribes to their own cards</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>turnOffRecentCardHighlighting</code> <p>Whether recent card highlighting is disabled</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>username</code> <p>Unique username for user identification</p> <p> TYPE: <code>NotRequired[str | None]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createUser.email","title":"email  <code>instance-attribute</code>","text":"<pre><code>email: str\n</code></pre> <p>Email address for login and notifications</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createUser.language","title":"language  <code>instance-attribute</code>","text":"<pre><code>language: NotRequired[Literal['ar-YE', 'bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-GB', 'en-US', 'es-ES', 'et-EE', 'fa-IR', 'fi-FI', 'fr-FR', 'hu-HU', 'id-ID', 'it-IT', 'ja-JP', 'ko-KR', 'nl-NL', 'pl-PL', 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sk-SK', 'sr-Cyrl-RS', 'sr-Latn-RS', 'sv-SE', 'tr-TR', 'uk-UA', 'uz-UZ', 'zh-CN', 'zh-TW'] | None]\n</code></pre> <p>Preferred language for user interface and notifications</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createUser.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Full display name of the user</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createUser.organization","title":"organization  <code>instance-attribute</code>","text":"<pre><code>organization: NotRequired[str | None]\n</code></pre> <p>Organization or company name</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createUser.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password: str\n</code></pre> <p>Password for user authentication (must meet password requirements)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createUser.phone","title":"phone  <code>instance-attribute</code>","text":"<pre><code>phone: NotRequired[str | None]\n</code></pre> <p>Contact phone number</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createUser.role","title":"role  <code>instance-attribute</code>","text":"<pre><code>role: Literal['admin', 'projectOwner', 'boardUser']\n</code></pre> <p>User role defining access permissions</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createUser.subscribeToCardWhenCommenting","title":"subscribeToCardWhenCommenting  <code>instance-attribute</code>","text":"<pre><code>subscribeToCardWhenCommenting: NotRequired[bool]\n</code></pre> <p>Whether the user subscribes to cards when commenting</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createUser.subscribeToOwnCards","title":"subscribeToOwnCards  <code>instance-attribute</code>","text":"<pre><code>subscribeToOwnCards: NotRequired[bool]\n</code></pre> <p>Whether the user subscribes to their own cards</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createUser.turnOffRecentCardHighlighting","title":"turnOffRecentCardHighlighting  <code>instance-attribute</code>","text":"<pre><code>turnOffRecentCardHighlighting: NotRequired[bool]\n</code></pre> <p>Whether recent card highlighting is disabled</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createUser.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username: NotRequired[str | None]\n</code></pre> <p>Unique username for user identification</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createUserNotificationService","title":"Request_createUserNotificationService","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 <ul> <li> api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createUserNotificationService </li> <li> models User <code></code>\u00a0User <code></code>\u00a0create_notification_service </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>format</code> <p>Format for notification messages</p> <p> TYPE: <code>Literal['text', 'markdown', 'html']</code> </p> <code>url</code> <p>URL endpoint for notifications</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createUserNotificationService.format","title":"format  <code>instance-attribute</code>","text":"<pre><code>format: Literal['text', 'markdown', 'html']\n</code></pre> <p>Format for notification messages</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createUserNotificationService.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre> <p>URL endpoint for notifications</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createWebhook","title":"Request_createWebhook","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createWebhook </li> </ul> ATTRIBUTE DESCRIPTION <code>accessToken</code> <p>Access token for webhook authentication</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>events</code> <p>Comma-separated list of events that trigger the webhook</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>excludedEvents</code> <p>Comma-separated list of events excluded from the webhook</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>name</code> <p>Name/title of the webhook</p> <p> TYPE: <code>str</code> </p> <code>url</code> <p>URL endpoint for the webhook</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createWebhook.accessToken","title":"accessToken  <code>instance-attribute</code>","text":"<pre><code>accessToken: NotRequired[str | None]\n</code></pre> <p>Access token for webhook authentication</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createWebhook.events","title":"events  <code>instance-attribute</code>","text":"<pre><code>events: NotRequired[str | None]\n</code></pre> <p>Comma-separated list of events that trigger the webhook</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createWebhook.excludedEvents","title":"excludedEvents  <code>instance-attribute</code>","text":"<pre><code>excludedEvents: NotRequired[str | None]\n</code></pre> <p>Comma-separated list of events excluded from the webhook</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createWebhook.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the webhook</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_createWebhook.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre> <p>URL endpoint for the webhook</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_duplicateCard","title":"Request_duplicateCard","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0duplicateCard </li> </ul> ATTRIBUTE DESCRIPTION <code>name</code> <p>Name/title for the duplicated card</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position for the duplicated card within the list</p> <p> TYPE: <code>int</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_duplicateCard.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title for the duplicated card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_duplicateCard.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position for the duplicated card within the list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_exchangeForAccessTokenWithOidc","title":"Request_exchangeForAccessTokenWithOidc","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0exchangeForAccessTokenWithOidc </li> </ul> ATTRIBUTE DESCRIPTION <code>code</code> <p>Authorization code from OIDC provider</p> <p> TYPE: <code>str</code> </p> <code>nonce</code> <p>Nonce value for OIDC security</p> <p> TYPE: <code>str</code> </p> <code>withHttpOnlyToken</code> <p>Whether to include HTTP-only authentication cookie</p> <p> TYPE: <code>NotRequired[bool]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_exchangeForAccessTokenWithOidc.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: str\n</code></pre> <p>Authorization code from OIDC provider</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_exchangeForAccessTokenWithOidc.nonce","title":"nonce  <code>instance-attribute</code>","text":"<pre><code>nonce: str\n</code></pre> <p>Nonce value for OIDC security</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_exchangeForAccessTokenWithOidc.withHttpOnlyToken","title":"withHttpOnlyToken  <code>instance-attribute</code>","text":"<pre><code>withHttpOnlyToken: NotRequired[bool]\n</code></pre> <p>Whether to include HTTP-only authentication cookie</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_getBoard","title":"Request_getBoard","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getBoard </li> </ul> ATTRIBUTE DESCRIPTION <code>subscribe</code> <p>Whether to subscribe to real-time updates for this board (only for socket connections)</p> <p> TYPE: <code>NotRequired[bool]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_getBoard.subscribe","title":"subscribe  <code>instance-attribute</code>","text":"<pre><code>subscribe: NotRequired[bool]\n</code></pre> <p>Whether to subscribe to real-time updates for this board (only for socket connections)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_getBoardActions","title":"Request_getBoardActions","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getBoardActions </li> </ul> ATTRIBUTE DESCRIPTION <code>beforeId</code> <p>ID to get actions before (for pagination)</p> <p> TYPE: <code>NotRequired[str]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_getBoardActions.beforeId","title":"beforeId  <code>instance-attribute</code>","text":"<pre><code>beforeId: NotRequired[str]\n</code></pre> <p>ID to get actions before (for pagination)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_getCardActions","title":"Request_getCardActions","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getCardActions </li> </ul> ATTRIBUTE DESCRIPTION <code>beforeId</code> <p>ID to get actions before (for pagination)</p> <p> TYPE: <code>NotRequired[str]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_getCardActions.beforeId","title":"beforeId  <code>instance-attribute</code>","text":"<pre><code>beforeId: NotRequired[str]\n</code></pre> <p>ID to get actions before (for pagination)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_getCards","title":"Request_getCards","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getCards </li> </ul> ATTRIBUTE DESCRIPTION <code>before</code> <p>Pagination cursor (JSON object with id and listChangedAt)</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>labelIds</code> <p>Comma-separated label IDs to filter by labels</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>search</code> <p>Search term to filter cards</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>userIds</code> <p>Comma-separated user IDs to filter by members</p> <p> TYPE: <code>NotRequired[str]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_getCards.before","title":"before  <code>instance-attribute</code>","text":"<pre><code>before: NotRequired[str]\n</code></pre> <p>Pagination cursor (JSON object with id and listChangedAt)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_getCards.labelIds","title":"labelIds  <code>instance-attribute</code>","text":"<pre><code>labelIds: NotRequired[str]\n</code></pre> <p>Comma-separated label IDs to filter by labels</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_getCards.search","title":"search  <code>instance-attribute</code>","text":"<pre><code>search: NotRequired[str]\n</code></pre> <p>Search term to filter cards</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_getCards.userIds","title":"userIds  <code>instance-attribute</code>","text":"<pre><code>userIds: NotRequired[str]\n</code></pre> <p>Comma-separated user IDs to filter by members</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_getComments","title":"Request_getComments","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getComments </li> </ul> ATTRIBUTE DESCRIPTION <code>beforeId</code> <p>ID to get comments before (for pagination)</p> <p> TYPE: <code>NotRequired[str]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_getComments.beforeId","title":"beforeId  <code>instance-attribute</code>","text":"<pre><code>beforeId: NotRequired[str]\n</code></pre> <p>ID to get comments before (for pagination)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_getTerms","title":"Request_getTerms","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getTerms </li> </ul> ATTRIBUTE DESCRIPTION <code>language</code> <p>Language code for terms localization</p> <p> TYPE: <code>NotRequired[str]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_getTerms.language","title":"language  <code>instance-attribute</code>","text":"<pre><code>language: NotRequired[str]\n</code></pre> <p>Language code for terms localization</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_getUser","title":"Request_getUser","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getUser </li> </ul> ATTRIBUTE DESCRIPTION <code>subscribe</code> <p>Whether to subscribe to real-time updates for this user (only for socket connections)</p> <p> TYPE: <code>NotRequired[bool]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_getUser.subscribe","title":"subscribe  <code>instance-attribute</code>","text":"<pre><code>subscribe: NotRequired[bool]\n</code></pre> <p>Whether to subscribe to real-time updates for this user (only for socket connections)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_moveListCards","title":"Request_moveListCards","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0moveListCards </li> </ul> ATTRIBUTE DESCRIPTION <code>listId</code> <p>ID of the target list (must be an archive-type list)</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_moveListCards.listId","title":"listId  <code>instance-attribute</code>","text":"<pre><code>listId: str\n</code></pre> <p>ID of the target list (must be an archive-type list)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_revokePendingToken","title":"Request_revokePendingToken","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0revokePendingToken </li> </ul> ATTRIBUTE DESCRIPTION <code>pendingToken</code> <p>Pending token to revoke</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_revokePendingToken.pendingToken","title":"pendingToken  <code>instance-attribute</code>","text":"<pre><code>pendingToken: str\n</code></pre> <p>Pending token to revoke</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_sortList","title":"Request_sortList","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 <ul> <li> models List <code></code>\u00a0List <code></code>\u00a0sort_cards </li> <li> api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0sortList </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>fieldName</code> <p>Field to sort cards by</p> <p> TYPE: <code>Literal['name', 'dueDate', 'createdAt']</code> </p> <code>order</code> <p>Sorting order</p> <p> TYPE: <code>NotRequired[Literal['asc', 'desc']]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_sortList.fieldName","title":"fieldName  <code>instance-attribute</code>","text":"<pre><code>fieldName: Literal['name', 'dueDate', 'createdAt']\n</code></pre> <p>Field to sort cards by</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_sortList.order","title":"order  <code>instance-attribute</code>","text":"<pre><code>order: NotRequired[Literal['asc', 'desc']]\n</code></pre> <p>Sorting order</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateAttachment","title":"Request_updateAttachment","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 <ul> <li> models Attachment <code></code>\u00a0Attachment <code></code>\u00a0update </li> <li> api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateAttachment </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>name</code> <p>Name/title of the attachment</p> <p> TYPE: <code>NotRequired[str]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateAttachment.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: NotRequired[str]\n</code></pre> <p>Name/title of the attachment</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateBaseCustomFieldGroup","title":"Request_updateBaseCustomFieldGroup","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 <ul> <li> models Base Custom Field Group <code></code>\u00a0BaseCustomFieldGroup <code></code>\u00a0update </li> <li> api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateBaseCustomFieldGroup </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>name</code> <p>Name/title of the base custom field group</p> <p> TYPE: <code>NotRequired[str]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateBaseCustomFieldGroup.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: NotRequired[str]\n</code></pre> <p>Name/title of the base custom field group</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateBoard","title":"Request_updateBoard","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 <ul> <li> models Board <code></code>\u00a0Board <code></code>\u00a0update </li> <li> api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateBoard </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>alwaysDisplayCardCreator</code> <p>Whether to always display card creators</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>defaultCardType</code> <p>Default card type for new cards</p> <p> TYPE: <code>NotRequired[Literal['project', 'story']]</code> </p> <code>defaultView</code> <p>Default view for the board</p> <p> TYPE: <code>NotRequired[Literal['kanban', 'grid', 'list']]</code> </p> <code>expandTaskListsByDefault</code> <p>Whether to expand task lists by default</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>isSubscribed</code> <p>Whether the current user is subscribed to the board</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>limitCardTypesToDefaultOne</code> <p>Whether to limit card types to default one</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>name</code> <p>Name/title of the board</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>position</code> <p>Position of the board within the project</p> <p> TYPE: <code>NotRequired[int]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateBoard.alwaysDisplayCardCreator","title":"alwaysDisplayCardCreator  <code>instance-attribute</code>","text":"<pre><code>alwaysDisplayCardCreator: NotRequired[bool]\n</code></pre> <p>Whether to always display card creators</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateBoard.defaultCardType","title":"defaultCardType  <code>instance-attribute</code>","text":"<pre><code>defaultCardType: NotRequired[Literal['project', 'story']]\n</code></pre> <p>Default card type for new cards</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateBoard.defaultView","title":"defaultView  <code>instance-attribute</code>","text":"<pre><code>defaultView: NotRequired[Literal['kanban', 'grid', 'list']]\n</code></pre> <p>Default view for the board</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateBoard.expandTaskListsByDefault","title":"expandTaskListsByDefault  <code>instance-attribute</code>","text":"<pre><code>expandTaskListsByDefault: NotRequired[bool]\n</code></pre> <p>Whether to expand task lists by default</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateBoard.isSubscribed","title":"isSubscribed  <code>instance-attribute</code>","text":"<pre><code>isSubscribed: NotRequired[bool]\n</code></pre> <p>Whether the current user is subscribed to the board</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateBoard.limitCardTypesToDefaultOne","title":"limitCardTypesToDefaultOne  <code>instance-attribute</code>","text":"<pre><code>limitCardTypesToDefaultOne: NotRequired[bool]\n</code></pre> <p>Whether to limit card types to default one</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateBoard.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: NotRequired[str]\n</code></pre> <p>Name/title of the board</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateBoard.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: NotRequired[int]\n</code></pre> <p>Position of the board within the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateBoardMembership","title":"Request_updateBoardMembership","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 <ul> <li> models Board Membership <code></code>\u00a0BoardMembership <code></code>\u00a0update </li> <li> api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateBoardMembership </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>canComment</code> <p>Whether the user can comment on cards (applies only to viewers)</p> <p> TYPE: <code>NotRequired[bool | None]</code> </p> <code>role</code> <p>Role of the user in the board</p> <p> TYPE: <code>NotRequired[Literal['editor', 'viewer']]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateBoardMembership.canComment","title":"canComment  <code>instance-attribute</code>","text":"<pre><code>canComment: NotRequired[bool | None]\n</code></pre> <p>Whether the user can comment on cards (applies only to viewers)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateBoardMembership.role","title":"role  <code>instance-attribute</code>","text":"<pre><code>role: NotRequired[Literal['editor', 'viewer']]\n</code></pre> <p>Role of the user in the board</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateCard","title":"Request_updateCard","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 <ul> <li> models Card <code></code>\u00a0Card <code></code>\u00a0update </li> <li> api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateCard </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>boardId</code> <p>ID of the board to move the card to</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>coverAttachmentId</code> <p>ID of the attachment used as cover</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>description</code> <p>Detailed description of the card</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>dueDate</code> <p>Due date for the card</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>isDueCompleted</code> <p>Whether the due date is completed</p> <p> TYPE: <code>NotRequired[bool | None]</code> </p> <code>isSubscribed</code> <p>Whether the current user is subscribed to the card</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>listId</code> <p>ID of the list to move the card to</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>name</code> <p>Name/title of the card</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>position</code> <p>Position of the card within the list</p> <p> TYPE: <code>NotRequired[int | None]</code> </p> <code>stopwatch</code> <p>Stopwatch data for time tracking</p> <p> TYPE: <code>NotRequired[Stopwatch | None]</code> </p> <code>type</code> <p>Type of the card</p> <p> TYPE: <code>NotRequired[Literal['project', 'story']]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateCard.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: NotRequired[str]\n</code></pre> <p>ID of the board to move the card to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateCard.coverAttachmentId","title":"coverAttachmentId  <code>instance-attribute</code>","text":"<pre><code>coverAttachmentId: NotRequired[str | None]\n</code></pre> <p>ID of the attachment used as cover</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateCard.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: NotRequired[str | None]\n</code></pre> <p>Detailed description of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateCard.dueDate","title":"dueDate  <code>instance-attribute</code>","text":"<pre><code>dueDate: NotRequired[str | None]\n</code></pre> <p>Due date for the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateCard.isDueCompleted","title":"isDueCompleted  <code>instance-attribute</code>","text":"<pre><code>isDueCompleted: NotRequired[bool | None]\n</code></pre> <p>Whether the due date is completed</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateCard.isSubscribed","title":"isSubscribed  <code>instance-attribute</code>","text":"<pre><code>isSubscribed: NotRequired[bool]\n</code></pre> <p>Whether the current user is subscribed to the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateCard.listId","title":"listId  <code>instance-attribute</code>","text":"<pre><code>listId: NotRequired[str]\n</code></pre> <p>ID of the list to move the card to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateCard.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: NotRequired[str]\n</code></pre> <p>Name/title of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateCard.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: NotRequired[int | None]\n</code></pre> <p>Position of the card within the list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateCard.stopwatch","title":"stopwatch  <code>instance-attribute</code>","text":"<pre><code>stopwatch: NotRequired[Stopwatch | None]\n</code></pre> <p>Stopwatch data for time tracking</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateCard.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: NotRequired[Literal['project', 'story']]\n</code></pre> <p>Type of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateComments","title":"Request_updateComments","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 <ul> <li> models Comment <code></code>\u00a0Comment <code></code>\u00a0update </li> <li> api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateComments </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>text</code> <p>Content of the comment</p> <p> TYPE: <code>NotRequired[str]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateComments.text","title":"text  <code>instance-attribute</code>","text":"<pre><code>text: NotRequired[str]\n</code></pre> <p>Content of the comment</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateCustomField","title":"Request_updateCustomField","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 <ul> <li> models Custom Field <code></code>\u00a0CustomField <code></code>\u00a0update </li> <li> api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateCustomField </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>name</code> <p>Name/title of the custom field</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>position</code> <p>Position of the custom field within the group</p> <p> TYPE: <code>NotRequired[int]</code> </p> <code>showOnFrontOfCard</code> <p>Whether to show the field on the front of cards</p> <p> TYPE: <code>NotRequired[bool]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateCustomField.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: NotRequired[str]\n</code></pre> <p>Name/title of the custom field</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateCustomField.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: NotRequired[int]\n</code></pre> <p>Position of the custom field within the group</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateCustomField.showOnFrontOfCard","title":"showOnFrontOfCard  <code>instance-attribute</code>","text":"<pre><code>showOnFrontOfCard: NotRequired[bool]\n</code></pre> <p>Whether to show the field on the front of cards</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateCustomFieldGroup","title":"Request_updateCustomFieldGroup","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 <ul> <li> models Custom Field Group <code></code>\u00a0CustomFieldGroup <code></code>\u00a0update </li> <li> api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateCustomFieldGroup </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>name</code> <p>Name/title of the custom field group</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>position</code> <p>Position of the custom field group within the board/card</p> <p> TYPE: <code>NotRequired[int]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateCustomFieldGroup.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: NotRequired[str | None]\n</code></pre> <p>Name/title of the custom field group</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateCustomFieldGroup.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: NotRequired[int]\n</code></pre> <p>Position of the custom field group within the board/card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateCustomFieldValue","title":"Request_updateCustomFieldValue","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 <ul> <li> models Custom Field Value <code></code>\u00a0CustomFieldValue <code></code>\u00a0update </li> <li> api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateCustomFieldValue </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>content</code> <p>Content/value of the custom field</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateCustomFieldValue.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: str\n</code></pre> <p>Content/value of the custom field</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateLabel","title":"Request_updateLabel","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 <ul> <li> models Label <code></code>\u00a0Label <code></code>\u00a0update </li> <li> api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateLabel </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>color</code> <p>Color of the label</p> <p> TYPE: <code>NotRequired[Literal['muddy-grey', 'autumn-leafs', 'morning-sky', 'antique-blue', 'egg-yellow', 'desert-sand', 'dark-granite', 'fresh-salad', 'lagoon-blue', 'midnight-blue', 'light-orange', 'pumpkin-orange', 'light-concrete', 'sunny-grass', 'navy-blue', 'lilac-eyes', 'apricot-red', 'orange-peel', 'silver-glint', 'bright-moss', 'deep-ocean', 'summer-sky', 'berry-red', 'light-cocoa', 'grey-stone', 'tank-green', 'coral-green', 'sugar-plum', 'pink-tulip', 'shady-rust', 'wet-rock', 'wet-moss', 'turquoise-sea', 'lavender-fields', 'piggy-red', 'light-mud', 'gun-metal', 'modern-green', 'french-coast', 'sweet-lilac', 'red-burgundy', 'pirate-gold']]</code> </p> <code>name</code> <p>Name/title of the label</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>position</code> <p>Position of the label within the board</p> <p> TYPE: <code>NotRequired[int]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateLabel.color","title":"color  <code>instance-attribute</code>","text":"<pre><code>color: NotRequired[Literal['muddy-grey', 'autumn-leafs', 'morning-sky', 'antique-blue', 'egg-yellow', 'desert-sand', 'dark-granite', 'fresh-salad', 'lagoon-blue', 'midnight-blue', 'light-orange', 'pumpkin-orange', 'light-concrete', 'sunny-grass', 'navy-blue', 'lilac-eyes', 'apricot-red', 'orange-peel', 'silver-glint', 'bright-moss', 'deep-ocean', 'summer-sky', 'berry-red', 'light-cocoa', 'grey-stone', 'tank-green', 'coral-green', 'sugar-plum', 'pink-tulip', 'shady-rust', 'wet-rock', 'wet-moss', 'turquoise-sea', 'lavender-fields', 'piggy-red', 'light-mud', 'gun-metal', 'modern-green', 'french-coast', 'sweet-lilac', 'red-burgundy', 'pirate-gold']]\n</code></pre> <p>Color of the label</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateLabel.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: NotRequired[str | None]\n</code></pre> <p>Name/title of the label</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateLabel.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: NotRequired[int]\n</code></pre> <p>Position of the label within the board</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateList","title":"Request_updateList","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 <ul> <li> models List <code></code>\u00a0List <code></code>\u00a0update </li> <li> api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateList </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>boardId</code> <p>ID of the board to move list to</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>color</code> <p>Color for the list</p> <p> TYPE: <code>NotRequired[Literal['berry-red', 'pumpkin-orange', 'lagoon-blue', 'pink-tulip', 'light-mud', 'orange-peel', 'bright-moss', 'antique-blue', 'dark-granite', 'turquoise-sea'] | None]</code> </p> <code>name</code> <p>Name/title of the list</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>position</code> <p>Position of the list within the board</p> <p> TYPE: <code>NotRequired[int]</code> </p> <code>type</code> <p>Type/status of the list</p> <p> TYPE: <code>NotRequired[Literal['active', 'closed']]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateList.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: NotRequired[str]\n</code></pre> <p>ID of the board to move list to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateList.color","title":"color  <code>instance-attribute</code>","text":"<pre><code>color: NotRequired[Literal['berry-red', 'pumpkin-orange', 'lagoon-blue', 'pink-tulip', 'light-mud', 'orange-peel', 'bright-moss', 'antique-blue', 'dark-granite', 'turquoise-sea'] | None]\n</code></pre> <p>Color for the list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateList.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: NotRequired[str]\n</code></pre> <p>Name/title of the list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateList.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: NotRequired[int]\n</code></pre> <p>Position of the list within the board</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateList.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: NotRequired[Literal['active', 'closed']]\n</code></pre> <p>Type/status of the list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateNotification","title":"Request_updateNotification","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 <ul> <li> models Notification <code></code>\u00a0Notification <code></code>\u00a0update </li> <li> api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateNotification </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>isRead</code> <p>Whether the notification has been read</p> <p> TYPE: <code>NotRequired[bool]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateNotification.isRead","title":"isRead  <code>instance-attribute</code>","text":"<pre><code>isRead: NotRequired[bool]\n</code></pre> <p>Whether the notification has been read</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateNotificationService","title":"Request_updateNotificationService","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 <ul> <li> models Notification Service <code></code>\u00a0NotificationService <code></code>\u00a0update </li> <li> api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateNotificationService </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>format</code> <p>Format for notification messages</p> <p> TYPE: <code>NotRequired[Literal['text', 'markdown', 'html']]</code> </p> <code>url</code> <p>URL endpoint for notifications</p> <p> TYPE: <code>NotRequired[str]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateNotificationService.format","title":"format  <code>instance-attribute</code>","text":"<pre><code>format: NotRequired[Literal['text', 'markdown', 'html']]\n</code></pre> <p>Format for notification messages</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateNotificationService.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: NotRequired[str]\n</code></pre> <p>URL endpoint for notifications</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateProject","title":"Request_updateProject","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 <ul> <li> api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateProject </li> <li> models Project <code></code>\u00a0Project <code></code>\u00a0update </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>backgroundGradient</code> <p>Gradient background for the project</p> <p> TYPE: <code>NotRequired[Literal['old-lime', 'ocean-dive', 'tzepesch-style', 'jungle-mesh', 'strawberry-dust', 'purple-rose', 'sun-scream', 'warm-rust', 'sky-change', 'green-eyes', 'blue-xchange', 'blood-orange', 'sour-peel', 'green-ninja', 'algae-green', 'coral-reef', 'steel-grey', 'heat-waves', 'velvet-lounge', 'purple-rain', 'blue-steel', 'blueish-curve', 'prism-light', 'green-mist', 'red-curtain'] | None]</code> </p> <code>backgroundImageId</code> <p>ID of the background image used as background</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>backgroundType</code> <p>Type of background for the project</p> <p> TYPE: <code>NotRequired[Literal['gradient', 'image'] | None]</code> </p> <code>description</code> <p>Detailed description of the project</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>isFavorite</code> <p>Whether the project is marked as favorite by the current user</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>isHidden</code> <p>Whether the project is hidden</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>name</code> <p>Name/title of the project</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>ownerProjectManagerId</code> <p>ID of the project manager who owns the project</p> <p> TYPE: <code>NotRequired[str | None]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateProject.backgroundGradient","title":"backgroundGradient  <code>instance-attribute</code>","text":"<pre><code>backgroundGradient: NotRequired[Literal['old-lime', 'ocean-dive', 'tzepesch-style', 'jungle-mesh', 'strawberry-dust', 'purple-rose', 'sun-scream', 'warm-rust', 'sky-change', 'green-eyes', 'blue-xchange', 'blood-orange', 'sour-peel', 'green-ninja', 'algae-green', 'coral-reef', 'steel-grey', 'heat-waves', 'velvet-lounge', 'purple-rain', 'blue-steel', 'blueish-curve', 'prism-light', 'green-mist', 'red-curtain'] | None]\n</code></pre> <p>Gradient background for the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateProject.backgroundImageId","title":"backgroundImageId  <code>instance-attribute</code>","text":"<pre><code>backgroundImageId: NotRequired[str | None]\n</code></pre> <p>ID of the background image used as background</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateProject.backgroundType","title":"backgroundType  <code>instance-attribute</code>","text":"<pre><code>backgroundType: NotRequired[Literal['gradient', 'image'] | None]\n</code></pre> <p>Type of background for the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateProject.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: NotRequired[str | None]\n</code></pre> <p>Detailed description of the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateProject.isFavorite","title":"isFavorite  <code>instance-attribute</code>","text":"<pre><code>isFavorite: NotRequired[bool]\n</code></pre> <p>Whether the project is marked as favorite by the current user</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateProject.isHidden","title":"isHidden  <code>instance-attribute</code>","text":"<pre><code>isHidden: NotRequired[bool]\n</code></pre> <p>Whether the project is hidden</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateProject.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: NotRequired[str]\n</code></pre> <p>Name/title of the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateProject.ownerProjectManagerId","title":"ownerProjectManagerId  <code>instance-attribute</code>","text":"<pre><code>ownerProjectManagerId: NotRequired[str | None]\n</code></pre> <p>ID of the project manager who owns the project</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateTask","title":"Request_updateTask","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 <ul> <li> api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateTask </li> <li> models Task <code></code>\u00a0Task <code></code>\u00a0update </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>assigneeUserId</code> <p>ID of the user assigned to the task (null to unassign)</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>isCompleted</code> <p>Whether the task is completed</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>name</code> <p>Name/title of the task</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>position</code> <p>Position of the task within the task list</p> <p> TYPE: <code>NotRequired[int]</code> </p> <code>taskListId</code> <p>ID of the task list to move the task to</p> <p> TYPE: <code>NotRequired[str]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateTask.assigneeUserId","title":"assigneeUserId  <code>instance-attribute</code>","text":"<pre><code>assigneeUserId: NotRequired[str | None]\n</code></pre> <p>ID of the user assigned to the task (null to unassign)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateTask.isCompleted","title":"isCompleted  <code>instance-attribute</code>","text":"<pre><code>isCompleted: NotRequired[bool]\n</code></pre> <p>Whether the task is completed</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateTask.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: NotRequired[str]\n</code></pre> <p>Name/title of the task</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateTask.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: NotRequired[int]\n</code></pre> <p>Position of the task within the task list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateTask.taskListId","title":"taskListId  <code>instance-attribute</code>","text":"<pre><code>taskListId: NotRequired[str]\n</code></pre> <p>ID of the task list to move the task to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateTaskList","title":"Request_updateTaskList","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 <ul> <li> api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateTaskList </li> <li> models Task List <code></code>\u00a0TaskList <code></code>\u00a0update </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>hideCompletedTasks</code> <p>Whether to hide completed tasks</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>name</code> <p>Name/title of the task list</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>position</code> <p>Position of the task list within the card</p> <p> TYPE: <code>NotRequired[int]</code> </p> <code>showOnFrontOfCard</code> <p>Whether to show the task list on the front of the card</p> <p> TYPE: <code>NotRequired[bool]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateTaskList.hideCompletedTasks","title":"hideCompletedTasks  <code>instance-attribute</code>","text":"<pre><code>hideCompletedTasks: NotRequired[bool]\n</code></pre> <p>Whether to hide completed tasks</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateTaskList.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: NotRequired[str]\n</code></pre> <p>Name/title of the task list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateTaskList.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: NotRequired[int]\n</code></pre> <p>Position of the task list within the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateTaskList.showOnFrontOfCard","title":"showOnFrontOfCard  <code>instance-attribute</code>","text":"<pre><code>showOnFrontOfCard: NotRequired[bool]\n</code></pre> <p>Whether to show the task list on the front of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUser","title":"Request_updateUser","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 <ul> <li> api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateUser </li> <li> models User <code></code>\u00a0User <code></code>\u00a0update </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>avatar</code> <p>Avatar of the user (only null value to remove avatar)</p> <p> TYPE: <code>NotRequired[dict[str, Any] | None]</code> </p> <code>defaultEditorMode</code> <p>Default markdown editor mode</p> <p> TYPE: <code>NotRequired[Literal['wysiwyg', 'markup']]</code> </p> <code>defaultHomeView</code> <p>Default view mode for the home page</p> <p> TYPE: <code>NotRequired[Literal['gridProjects', 'groupedProjects']]</code> </p> <code>defaultProjectsOrder</code> <p>Default sort order for projects display</p> <p> TYPE: <code>NotRequired[Literal['byDefault', 'alphabetically', 'byCreationTime']]</code> </p> <code>enableFavoritesByDefault</code> <p>Whether favorites are enabled by default</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>isDeactivated</code> <p>Whether the user account is deactivated and cannot log in (for admins)</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>language</code> <p>Preferred language for user interface and notifications</p> <p> TYPE: <code>NotRequired[Literal['ar-YE', 'bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-GB', 'en-US', 'es-ES', 'et-EE', 'fa-IR', 'fi-FI', 'fr-FR', 'hu-HU', 'id-ID', 'it-IT', 'ja-JP', 'ko-KR', 'nl-NL', 'pl-PL', 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sk-SK', 'sr-Cyrl-RS', 'sr-Latn-RS', 'sv-SE', 'tr-TR', 'uk-UA', 'uz-UZ', 'zh-CN', 'zh-TW'] | None]</code> </p> <code>name</code> <p>Full display name of the user</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>organization</code> <p>Organization or company name</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>phone</code> <p>Contact phone number</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>role</code> <p>User role defining access permissions</p> <p> TYPE: <code>NotRequired[Literal['admin', 'projectOwner', 'boardUser']]</code> </p> <code>subscribeToCardWhenCommenting</code> <p>Whether the user subscribes to cards when commenting</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>subscribeToOwnCards</code> <p>Whether the user subscribes to their own cards</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>turnOffRecentCardHighlighting</code> <p>Whether recent card highlighting is disabled</p> <p> TYPE: <code>NotRequired[bool]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUser.avatar","title":"avatar  <code>instance-attribute</code>","text":"<pre><code>avatar: NotRequired[dict[str, Any] | None]\n</code></pre> <p>Avatar of the user (only null value to remove avatar)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUser.defaultEditorMode","title":"defaultEditorMode  <code>instance-attribute</code>","text":"<pre><code>defaultEditorMode: NotRequired[Literal['wysiwyg', 'markup']]\n</code></pre> <p>Default markdown editor mode</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUser.defaultHomeView","title":"defaultHomeView  <code>instance-attribute</code>","text":"<pre><code>defaultHomeView: NotRequired[Literal['gridProjects', 'groupedProjects']]\n</code></pre> <p>Default view mode for the home page</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUser.defaultProjectsOrder","title":"defaultProjectsOrder  <code>instance-attribute</code>","text":"<pre><code>defaultProjectsOrder: NotRequired[Literal['byDefault', 'alphabetically', 'byCreationTime']]\n</code></pre> <p>Default sort order for projects display</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUser.enableFavoritesByDefault","title":"enableFavoritesByDefault  <code>instance-attribute</code>","text":"<pre><code>enableFavoritesByDefault: NotRequired[bool]\n</code></pre> <p>Whether favorites are enabled by default</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUser.isDeactivated","title":"isDeactivated  <code>instance-attribute</code>","text":"<pre><code>isDeactivated: NotRequired[bool]\n</code></pre> <p>Whether the user account is deactivated and cannot log in (for admins)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUser.language","title":"language  <code>instance-attribute</code>","text":"<pre><code>language: NotRequired[Literal['ar-YE', 'bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-GB', 'en-US', 'es-ES', 'et-EE', 'fa-IR', 'fi-FI', 'fr-FR', 'hu-HU', 'id-ID', 'it-IT', 'ja-JP', 'ko-KR', 'nl-NL', 'pl-PL', 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sk-SK', 'sr-Cyrl-RS', 'sr-Latn-RS', 'sv-SE', 'tr-TR', 'uk-UA', 'uz-UZ', 'zh-CN', 'zh-TW'] | None]\n</code></pre> <p>Preferred language for user interface and notifications</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUser.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: NotRequired[str]\n</code></pre> <p>Full display name of the user</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUser.organization","title":"organization  <code>instance-attribute</code>","text":"<pre><code>organization: NotRequired[str | None]\n</code></pre> <p>Organization or company name</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUser.phone","title":"phone  <code>instance-attribute</code>","text":"<pre><code>phone: NotRequired[str | None]\n</code></pre> <p>Contact phone number</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUser.role","title":"role  <code>instance-attribute</code>","text":"<pre><code>role: NotRequired[Literal['admin', 'projectOwner', 'boardUser']]\n</code></pre> <p>User role defining access permissions</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUser.subscribeToCardWhenCommenting","title":"subscribeToCardWhenCommenting  <code>instance-attribute</code>","text":"<pre><code>subscribeToCardWhenCommenting: NotRequired[bool]\n</code></pre> <p>Whether the user subscribes to cards when commenting</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUser.subscribeToOwnCards","title":"subscribeToOwnCards  <code>instance-attribute</code>","text":"<pre><code>subscribeToOwnCards: NotRequired[bool]\n</code></pre> <p>Whether the user subscribes to their own cards</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUser.turnOffRecentCardHighlighting","title":"turnOffRecentCardHighlighting  <code>instance-attribute</code>","text":"<pre><code>turnOffRecentCardHighlighting: NotRequired[bool]\n</code></pre> <p>Whether recent card highlighting is disabled</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUserAvatar","title":"Request_updateUserAvatar","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateUserAvatar </li> </ul> ATTRIBUTE DESCRIPTION <code>file</code> <p>Avatar image file (must be an image format)</p> <p> TYPE: <code>bytes</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUserAvatar.file","title":"file  <code>instance-attribute</code>","text":"<pre><code>file: bytes\n</code></pre> <p>Avatar image file (must be an image format)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUserEmail","title":"Request_updateUserEmail","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateUserEmail </li> </ul> ATTRIBUTE DESCRIPTION <code>currentPassword</code> <p>Current password (required when updating own email)</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>email</code> <p>Email address for login and notifications</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUserEmail.currentPassword","title":"currentPassword  <code>instance-attribute</code>","text":"<pre><code>currentPassword: NotRequired[str]\n</code></pre> <p>Current password (required when updating own email)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUserEmail.email","title":"email  <code>instance-attribute</code>","text":"<pre><code>email: str\n</code></pre> <p>Email address for login and notifications</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUserPassword","title":"Request_updateUserPassword","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateUserPassword </li> </ul> ATTRIBUTE DESCRIPTION <code>currentPassword</code> <p>Current password (required when updating own password)</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>password</code> <p>Password (must meet password requirements)</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUserPassword.currentPassword","title":"currentPassword  <code>instance-attribute</code>","text":"<pre><code>currentPassword: NotRequired[str]\n</code></pre> <p>Current password (required when updating own password)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUserPassword.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password: str\n</code></pre> <p>Password (must meet password requirements)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUserUsername","title":"Request_updateUserUsername","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateUserUsername </li> </ul> ATTRIBUTE DESCRIPTION <code>currentPassword</code> <p>Current password (required when updating own username)</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>username</code> <p>Unique username for user identification</p> <p> TYPE: <code>NotRequired[str | None]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUserUsername.currentPassword","title":"currentPassword  <code>instance-attribute</code>","text":"<pre><code>currentPassword: NotRequired[str]\n</code></pre> <p>Current password (required when updating own username)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateUserUsername.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username: NotRequired[str | None]\n</code></pre> <p>Unique username for user identification</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateWebhook","title":"Request_updateWebhook","text":"<p>               Bases: <code>TypedDict</code></p> Used by: <ul> <li> Plankapy v2 <ul> <li> api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateWebhook </li> <li> models Webhook <code></code>\u00a0Webhook <code></code>\u00a0update </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>accessToken</code> <p>Access token for webhook authentication</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>events</code> <p>Comma-separated list of events that trigger the webhook</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>excludedEvents</code> <p>Comma-separated list of events excluded from the webhook</p> <p> TYPE: <code>NotRequired[str | None]</code> </p> <code>name</code> <p>Name/title of the webhook</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>url</code> <p>URL endpoint for the webhook</p> <p> TYPE: <code>NotRequired[str]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateWebhook.accessToken","title":"accessToken  <code>instance-attribute</code>","text":"<pre><code>accessToken: NotRequired[str | None]\n</code></pre> <p>Access token for webhook authentication</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateWebhook.events","title":"events  <code>instance-attribute</code>","text":"<pre><code>events: NotRequired[str | None]\n</code></pre> <p>Comma-separated list of events that trigger the webhook</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateWebhook.excludedEvents","title":"excludedEvents  <code>instance-attribute</code>","text":"<pre><code>excludedEvents: NotRequired[str | None]\n</code></pre> <p>Comma-separated list of events excluded from the webhook</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateWebhook.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: NotRequired[str]\n</code></pre> <p>Name/title of the webhook</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Request_updateWebhook.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: NotRequired[str]\n</code></pre> <p>URL endpoint for the webhook</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_acceptTerms","title":"Response_acceptTerms","text":"<p>               Bases: <code>TypedDict</code></p> <p>Terms accepted successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0acceptTerms </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p>Access token for API authentication</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_acceptTerms.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: str\n</code></pre> <p>Access token for API authentication</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_clearList","title":"Response_clearList","text":"<p>               Bases: <code>TypedDict</code></p> <p>List cleared successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0clearList </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>List</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_clearList.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: List\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createAccessToken","title":"Response_createAccessToken","text":"<p>               Bases: <code>TypedDict</code></p> <p>Login successful</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createAccessToken </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p>Access token for API authentication</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createAccessToken.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: str\n</code></pre> <p>Access token for API authentication</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createAttachment","title":"Response_createAttachment","text":"<p>               Bases: <code>TypedDict</code></p> <p>Attachment created successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createAttachment </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Attachment</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createAttachment.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Attachment\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createBackgroundImage","title":"Response_createBackgroundImage","text":"<p>               Bases: <code>TypedDict</code></p> <p>Background image uploaded successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createBackgroundImage </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>BackgroundImage</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createBackgroundImage.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: BackgroundImage\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createBaseCustomFieldGroup","title":"Response_createBaseCustomFieldGroup","text":"<p>               Bases: <code>TypedDict</code></p> <p>Base custom field group created successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createBaseCustomFieldGroup </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>BaseCustomFieldGroup</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createBaseCustomFieldGroup.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: BaseCustomFieldGroup\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createBoard","title":"Response_createBoard","text":"<p>               Bases: <code>TypedDict</code></p> <p>Board created successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createBoard </li> </ul> ATTRIBUTE DESCRIPTION <code>included</code> <p> TYPE: <code>Included_createBoard</code> </p> <code>item</code> <p> TYPE: <code>Board</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createBoard.included","title":"included  <code>instance-attribute</code>","text":"<pre><code>included: Included_createBoard\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createBoard.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Board\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createBoardCustomFieldGroup","title":"Response_createBoardCustomFieldGroup","text":"<p>               Bases: <code>TypedDict</code></p> <p>Custom field group created successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createBoardCustomFieldGroup </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>CustomFieldGroup</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createBoardCustomFieldGroup.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: CustomFieldGroup\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createBoardMembership","title":"Response_createBoardMembership","text":"<p>               Bases: <code>TypedDict</code></p> <p>Board membership created successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createBoardMembership </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>BoardMembership</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createBoardMembership.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: BoardMembership\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createBoardNotificationService","title":"Response_createBoardNotificationService","text":"<p>               Bases: <code>TypedDict</code></p> <p>Notification service created successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createBoardNotificationService </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>NotificationService</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createBoardNotificationService.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: NotificationService\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createCard","title":"Response_createCard","text":"<p>               Bases: <code>TypedDict</code></p> <p>Card created successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createCard </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Card</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createCard.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Card\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createCardCustomFieldGroup","title":"Response_createCardCustomFieldGroup","text":"<p>               Bases: <code>TypedDict</code></p> <p>Custom field group created successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createCardCustomFieldGroup </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>CustomFieldGroup</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createCardCustomFieldGroup.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: CustomFieldGroup\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createCardLabel","title":"Response_createCardLabel","text":"<p>               Bases: <code>TypedDict</code></p> <p>Label added to card successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createCardLabel </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>CardLabel</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createCardLabel.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: CardLabel\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createCardMembership","title":"Response_createCardMembership","text":"<p>               Bases: <code>TypedDict</code></p> <p>User added to card successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createCardMembership </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>CardMembership</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createCardMembership.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: CardMembership\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createComment","title":"Response_createComment","text":"<p>               Bases: <code>TypedDict</code></p> <p>Comment created successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createComment </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Comment</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createComment.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Comment\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createCustomFieldInBaseGroup","title":"Response_createCustomFieldInBaseGroup","text":"<p>               Bases: <code>TypedDict</code></p> <p>Custom field created successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createCustomFieldInBaseGroup </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>CustomField</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createCustomFieldInBaseGroup.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: CustomField\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createCustomFieldInGroup","title":"Response_createCustomFieldInGroup","text":"<p>               Bases: <code>TypedDict</code></p> <p>Custom field created successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createCustomFieldInGroup </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>CustomField</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createCustomFieldInGroup.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: CustomField\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createLabel","title":"Response_createLabel","text":"<p>               Bases: <code>TypedDict</code></p> <p>Label created successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createLabel </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Label</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createLabel.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Label\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createList","title":"Response_createList","text":"<p>               Bases: <code>TypedDict</code></p> <p>List created successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createList </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>List</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createList.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: List\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createProject","title":"Response_createProject","text":"<p>               Bases: <code>TypedDict</code></p> <p>Project created successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createProject </li> </ul> ATTRIBUTE DESCRIPTION <code>included</code> <p> TYPE: <code>Included_createProject</code> </p> <code>item</code> <p> TYPE: <code>Project</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createProject.included","title":"included  <code>instance-attribute</code>","text":"<pre><code>included: Included_createProject\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createProject.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Project\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createProjectManager","title":"Response_createProjectManager","text":"<p>               Bases: <code>TypedDict</code></p> <p>Project manager created successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createProjectManager </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>ProjectManager</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createProjectManager.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: ProjectManager\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createTask","title":"Response_createTask","text":"<p>               Bases: <code>TypedDict</code></p> <p>Task created successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createTask </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Task</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createTask.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Task\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createTaskList","title":"Response_createTaskList","text":"<p>               Bases: <code>TypedDict</code></p> <p>Task list created successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createTaskList </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>TaskList</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createTaskList.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: TaskList\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createUser","title":"Response_createUser","text":"<p>               Bases: <code>TypedDict</code></p> <p>User created successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createUser </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>User</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createUser.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: User\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createUserNotificationService","title":"Response_createUserNotificationService","text":"<p>               Bases: <code>TypedDict</code></p> <p>Notification service created successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createUserNotificationService </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>NotificationService</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createUserNotificationService.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: NotificationService\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createWebhook","title":"Response_createWebhook","text":"<p>               Bases: <code>TypedDict</code></p> <p>Webhook created successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0createWebhook </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Webhook</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_createWebhook.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Webhook\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteAccessToken","title":"Response_deleteAccessToken","text":"<p>               Bases: <code>TypedDict</code></p> <p>Logout successful</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0deleteAccessToken </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p>Revoked access token</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteAccessToken.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: str\n</code></pre> <p>Revoked access token</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteAttachment","title":"Response_deleteAttachment","text":"<p>               Bases: <code>TypedDict</code></p> <p>Attachment deleted successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0deleteAttachment </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Attachment</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteAttachment.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Attachment\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteBackgroundImage","title":"Response_deleteBackgroundImage","text":"<p>               Bases: <code>TypedDict</code></p> <p>Background image deleted successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0deleteBackgroundImage </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>BackgroundImage</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteBackgroundImage.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: BackgroundImage\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteBaseCustomFieldGroup","title":"Response_deleteBaseCustomFieldGroup","text":"<p>               Bases: <code>TypedDict</code></p> <p>Base custom field group deleted successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0deleteBaseCustomFieldGroup </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>BaseCustomFieldGroup</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteBaseCustomFieldGroup.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: BaseCustomFieldGroup\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteBoard","title":"Response_deleteBoard","text":"<p>               Bases: <code>TypedDict</code></p> <p>Board deleted successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0deleteBoard </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Board</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteBoard.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Board\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteBoardMembership","title":"Response_deleteBoardMembership","text":"<p>               Bases: <code>TypedDict</code></p> <p>Board membership deleted successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0deleteBoardMembership </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>BoardMembership</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteBoardMembership.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: BoardMembership\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteCard","title":"Response_deleteCard","text":"<p>               Bases: <code>TypedDict</code></p> <p>Card deleted successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0deleteCard </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Card</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteCard.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Card\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteCardLabel","title":"Response_deleteCardLabel","text":"<p>               Bases: <code>TypedDict</code></p> <p>Label removed from card successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0deleteCardLabel </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>CardLabel</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteCardLabel.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: CardLabel\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteCardMembership","title":"Response_deleteCardMembership","text":"<p>               Bases: <code>TypedDict</code></p> <p>User removed from card successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0deleteCardMembership </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>CardMembership</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteCardMembership.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: CardMembership\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteComment","title":"Response_deleteComment","text":"<p>               Bases: <code>TypedDict</code></p> <p>Comment deleted successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0deleteComment </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Comment</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteComment.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Comment\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteCustomField","title":"Response_deleteCustomField","text":"<p>               Bases: <code>TypedDict</code></p> <p>Custom field deleted successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0deleteCustomField </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>CustomField</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteCustomField.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: CustomField\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteCustomFieldGroup","title":"Response_deleteCustomFieldGroup","text":"<p>               Bases: <code>TypedDict</code></p> <p>Custom field group deleted successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0deleteCustomFieldGroup </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>CustomFieldGroup</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteCustomFieldGroup.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: CustomFieldGroup\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteCustomFieldValue","title":"Response_deleteCustomFieldValue","text":"<p>               Bases: <code>TypedDict</code></p> <p>Custom field value deleted successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0deleteCustomFieldValue </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>CustomFieldValue</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteCustomFieldValue.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: CustomFieldValue\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteLabel","title":"Response_deleteLabel","text":"<p>               Bases: <code>TypedDict</code></p> <p>Label deleted successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0deleteLabel </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Label</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteLabel.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Label\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteList","title":"Response_deleteList","text":"<p>               Bases: <code>TypedDict</code></p> <p>List deleted successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0deleteList </li> </ul> ATTRIBUTE DESCRIPTION <code>included</code> <p> TYPE: <code>Included_deleteList</code> </p> <code>item</code> <p> TYPE: <code>List</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteList.included","title":"included  <code>instance-attribute</code>","text":"<pre><code>included: Included_deleteList\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteList.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: List\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteNotificationService","title":"Response_deleteNotificationService","text":"<p>               Bases: <code>TypedDict</code></p> <p>Notification service deleted successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0deleteNotificationService </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>NotificationService</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteNotificationService.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: NotificationService\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteProject","title":"Response_deleteProject","text":"<p>               Bases: <code>TypedDict</code></p> <p>Project deleted successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0deleteProject </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Project</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteProject.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Project\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteProjectManager","title":"Response_deleteProjectManager","text":"<p>               Bases: <code>TypedDict</code></p> <p>Project manager deleted successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0deleteProjectManager </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>ProjectManager</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteProjectManager.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: ProjectManager\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteTask","title":"Response_deleteTask","text":"<p>               Bases: <code>TypedDict</code></p> <p>Task deleted successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0deleteTask </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Task</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteTask.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Task\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteTaskList","title":"Response_deleteTaskList","text":"<p>               Bases: <code>TypedDict</code></p> <p>Task list deleted successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0deleteTaskList </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>TaskList</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteTaskList.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: TaskList\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteUser","title":"Response_deleteUser","text":"<p>               Bases: <code>TypedDict</code></p> <p>User deleted successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0deleteUser </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>User</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteUser.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: User\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteWebhook","title":"Response_deleteWebhook","text":"<p>               Bases: <code>TypedDict</code></p> <p>Webhook deleted successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0deleteWebhook </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Webhook</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_deleteWebhook.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Webhook\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_duplicateCard","title":"Response_duplicateCard","text":"<p>               Bases: <code>TypedDict</code></p> <p>Card duplicated successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0duplicateCard </li> </ul> ATTRIBUTE DESCRIPTION <code>included</code> <p> TYPE: <code>Included_duplicateCard</code> </p> <code>item</code> <p> TYPE: <code>Card</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_duplicateCard.included","title":"included  <code>instance-attribute</code>","text":"<pre><code>included: Included_duplicateCard\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_duplicateCard.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Card\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_exchangeForAccessTokenWithOidc","title":"Response_exchangeForAccessTokenWithOidc","text":"<p>               Bases: <code>TypedDict</code></p> <p>OIDC exchange successful</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0exchangeForAccessTokenWithOidc </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p>Access token for API authentication</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_exchangeForAccessTokenWithOidc.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: str\n</code></pre> <p>Access token for API authentication</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getBoard","title":"Response_getBoard","text":"<p>               Bases: <code>TypedDict</code></p> <p>Board details retrieved successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getBoard </li> </ul> ATTRIBUTE DESCRIPTION <code>included</code> <p> TYPE: <code>Included_getBoard</code> </p> <code>item</code> <p> TYPE: <code>Item_getBoard</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getBoard.included","title":"included  <code>instance-attribute</code>","text":"<pre><code>included: Included_getBoard\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getBoard.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Item_getBoard\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getBoardActions","title":"Response_getBoardActions","text":"<p>               Bases: <code>TypedDict</code></p> <p>Board actions retrieved successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getBoardActions </li> </ul> ATTRIBUTE DESCRIPTION <code>included</code> <p> TYPE: <code>Included_getBoardActions</code> </p> <code>items</code> <p> TYPE: <code>list[Action]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getBoardActions.included","title":"included  <code>instance-attribute</code>","text":"<pre><code>included: Included_getBoardActions\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getBoardActions.items","title":"items  <code>instance-attribute</code>","text":"<pre><code>items: list[Action]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getCard","title":"Response_getCard","text":"<p>               Bases: <code>TypedDict</code></p> <p>Card details retrieved successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getCard </li> </ul> ATTRIBUTE DESCRIPTION <code>included</code> <p> TYPE: <code>Included_getCard</code> </p> <code>item</code> <p> TYPE: <code>Item_getCard</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getCard.included","title":"included  <code>instance-attribute</code>","text":"<pre><code>included: Included_getCard\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getCard.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Item_getCard\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getCardActions","title":"Response_getCardActions","text":"<p>               Bases: <code>TypedDict</code></p> <p>Card actions retrieved successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getCardActions </li> </ul> ATTRIBUTE DESCRIPTION <code>included</code> <p> TYPE: <code>Included_getCardActions</code> </p> <code>items</code> <p> TYPE: <code>list[Action]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getCardActions.included","title":"included  <code>instance-attribute</code>","text":"<pre><code>included: Included_getCardActions\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getCardActions.items","title":"items  <code>instance-attribute</code>","text":"<pre><code>items: list[Action]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getCards","title":"Response_getCards","text":"<p>               Bases: <code>TypedDict</code></p> <p>Cards retrieved successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getCards </li> </ul> ATTRIBUTE DESCRIPTION <code>included</code> <p> TYPE: <code>Included_getCards</code> </p> <code>items</code> <p> TYPE: <code>list[Items_getCards]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getCards.included","title":"included  <code>instance-attribute</code>","text":"<pre><code>included: Included_getCards\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getCards.items","title":"items  <code>instance-attribute</code>","text":"<pre><code>items: list[Items_getCards]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getComments","title":"Response_getComments","text":"<p>               Bases: <code>TypedDict</code></p> <p>Comments retrieved successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getComments </li> </ul> ATTRIBUTE DESCRIPTION <code>included</code> <p> TYPE: <code>Included_getComments</code> </p> <code>items</code> <p> TYPE: <code>list[Comment]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getComments.included","title":"included  <code>instance-attribute</code>","text":"<pre><code>included: Included_getComments\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getComments.items","title":"items  <code>instance-attribute</code>","text":"<pre><code>items: list[Comment]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getConfig","title":"Response_getConfig","text":"<p>               Bases: <code>TypedDict</code></p> <p>Configuration retrieved successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getConfig </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Config</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getConfig.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Config\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getCustomFieldGroup","title":"Response_getCustomFieldGroup","text":"<p>               Bases: <code>TypedDict</code></p> <p>Custom field group details retrieved successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getCustomFieldGroup </li> </ul> ATTRIBUTE DESCRIPTION <code>included</code> <p> TYPE: <code>Included_getCustomFieldGroup</code> </p> <code>item</code> <p> TYPE: <code>CustomFieldGroup</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getCustomFieldGroup.included","title":"included  <code>instance-attribute</code>","text":"<pre><code>included: Included_getCustomFieldGroup\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getCustomFieldGroup.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: CustomFieldGroup\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getList","title":"Response_getList","text":"<p>               Bases: <code>TypedDict</code></p> <p>List details retrieved successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getList </li> </ul> ATTRIBUTE DESCRIPTION <code>included</code> <p> TYPE: <code>Included_getList</code> </p> <code>item</code> <p> TYPE: <code>List</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getList.included","title":"included  <code>instance-attribute</code>","text":"<pre><code>included: Included_getList\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getList.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: List\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getNotification","title":"Response_getNotification","text":"<p>               Bases: <code>TypedDict</code></p> <p>Notification details retrieved successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getNotification </li> </ul> ATTRIBUTE DESCRIPTION <code>included</code> <p> TYPE: <code>Included_getNotification</code> </p> <code>item</code> <p> TYPE: <code>Notification</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getNotification.included","title":"included  <code>instance-attribute</code>","text":"<pre><code>included: Included_getNotification\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getNotification.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Notification\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getNotifications","title":"Response_getNotifications","text":"<p>               Bases: <code>TypedDict</code></p> <p>Notifications retrieved successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getNotifications </li> </ul> ATTRIBUTE DESCRIPTION <code>included</code> <p> TYPE: <code>Included_getNotifications</code> </p> <code>items</code> <p> TYPE: <code>list[Notification]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getNotifications.included","title":"included  <code>instance-attribute</code>","text":"<pre><code>included: Included_getNotifications\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getNotifications.items","title":"items  <code>instance-attribute</code>","text":"<pre><code>items: list[Notification]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getProject","title":"Response_getProject","text":"<p>               Bases: <code>TypedDict</code></p> <p>Project details retrieved successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getProject </li> </ul> ATTRIBUTE DESCRIPTION <code>included</code> <p> TYPE: <code>Included_getProject</code> </p> <code>item</code> <p> TYPE: <code>Item_getProject</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getProject.included","title":"included  <code>instance-attribute</code>","text":"<pre><code>included: Included_getProject\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getProject.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Item_getProject\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getProjects","title":"Response_getProjects","text":"<p>               Bases: <code>TypedDict</code></p> <p>Projects retrieved successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getProjects </li> </ul> ATTRIBUTE DESCRIPTION <code>included</code> <p> TYPE: <code>Included_getProjects</code> </p> <code>items</code> <p> TYPE: <code>list[Items_getProjects]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getProjects.included","title":"included  <code>instance-attribute</code>","text":"<pre><code>included: Included_getProjects\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getProjects.items","title":"items  <code>instance-attribute</code>","text":"<pre><code>items: list[Items_getProjects]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getTaskList","title":"Response_getTaskList","text":"<p>               Bases: <code>TypedDict</code></p> <p>Task list details retrieved successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getTaskList </li> </ul> ATTRIBUTE DESCRIPTION <code>included</code> <p> TYPE: <code>Included_getTaskList</code> </p> <code>item</code> <p> TYPE: <code>TaskList</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getTaskList.included","title":"included  <code>instance-attribute</code>","text":"<pre><code>included: Included_getTaskList\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getTaskList.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: TaskList\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getTerms","title":"Response_getTerms","text":"<p>               Bases: <code>TypedDict</code></p> <p>Terms content retrieved successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getTerms </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Item_getTerms</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getTerms.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Item_getTerms\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getUser","title":"Response_getUser","text":"<p>               Bases: <code>TypedDict</code></p> <p>User details retrieved successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getUser </li> </ul> ATTRIBUTE DESCRIPTION <code>included</code> <p> TYPE: <code>Included_getUser</code> </p> <code>item</code> <p> TYPE: <code>User</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getUser.included","title":"included  <code>instance-attribute</code>","text":"<pre><code>included: Included_getUser\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getUser.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: User\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getUsers","title":"Response_getUsers","text":"<p>               Bases: <code>TypedDict</code></p> <p>List of users retrieved successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getUsers </li> </ul> ATTRIBUTE DESCRIPTION <code>items</code> <p> TYPE: <code>list[User]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getUsers.items","title":"items  <code>instance-attribute</code>","text":"<pre><code>items: list[User]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getWebhooks","title":"Response_getWebhooks","text":"<p>               Bases: <code>TypedDict</code></p> <p>List of webhooks retrieved successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0getWebhooks </li> </ul> ATTRIBUTE DESCRIPTION <code>items</code> <p> TYPE: <code>list[Webhook]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_getWebhooks.items","title":"items  <code>instance-attribute</code>","text":"<pre><code>items: list[Webhook]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_moveListCards","title":"Response_moveListCards","text":"<p>               Bases: <code>TypedDict</code></p> <p>Cards moved successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0moveListCards </li> </ul> ATTRIBUTE DESCRIPTION <code>included</code> <p> TYPE: <code>Included_moveListCards</code> </p> <code>item</code> <p> TYPE: <code>List</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_moveListCards.included","title":"included  <code>instance-attribute</code>","text":"<pre><code>included: Included_moveListCards\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_moveListCards.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: List\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_readAllNotifications","title":"Response_readAllNotifications","text":"<p>               Bases: <code>TypedDict</code></p> <p>Notifications marked as read successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0readAllNotifications </li> </ul> ATTRIBUTE DESCRIPTION <code>items</code> <p> TYPE: <code>list[Notification]</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_readAllNotifications.items","title":"items  <code>instance-attribute</code>","text":"<pre><code>items: list[Notification]\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_readCardNotifications","title":"Response_readCardNotifications","text":"<p>               Bases: <code>TypedDict</code></p> <p>Notifications marked as read successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0readCardNotifications </li> </ul> ATTRIBUTE DESCRIPTION <code>included</code> <p> TYPE: <code>Included_readCardNotifications</code> </p> <code>item</code> <p> TYPE: <code>Card</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_readCardNotifications.included","title":"included  <code>instance-attribute</code>","text":"<pre><code>included: Included_readCardNotifications\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_readCardNotifications.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Card\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_revokePendingToken","title":"Response_revokePendingToken","text":"<p>               Bases: <code>TypedDict</code></p> <p>Pending token revoked successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0revokePendingToken </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p>No data returned</p> <p> TYPE: <code>dict[str, Any] | None</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_revokePendingToken.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: dict[str, Any] | None\n</code></pre> <p>No data returned</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_sortList","title":"Response_sortList","text":"<p>               Bases: <code>TypedDict</code></p> <p>List sorted successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0sortList </li> </ul> ATTRIBUTE DESCRIPTION <code>included</code> <p> TYPE: <code>Included_sortList</code> </p> <code>item</code> <p> TYPE: <code>List</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_sortList.included","title":"included  <code>instance-attribute</code>","text":"<pre><code>included: Included_sortList\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_sortList.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: List\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_testNotificationService","title":"Response_testNotificationService","text":"<p>               Bases: <code>TypedDict</code></p> <p>Test notification sent successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0testNotificationService </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>NotificationService</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_testNotificationService.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: NotificationService\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateAttachment","title":"Response_updateAttachment","text":"<p>               Bases: <code>TypedDict</code></p> <p>Attachment updated successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateAttachment </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Attachment</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateAttachment.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Attachment\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateBaseCustomFieldGroup","title":"Response_updateBaseCustomFieldGroup","text":"<p>               Bases: <code>TypedDict</code></p> <p>Base custom field group updated successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateBaseCustomFieldGroup </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>BaseCustomFieldGroup</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateBaseCustomFieldGroup.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: BaseCustomFieldGroup\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateBoard","title":"Response_updateBoard","text":"<p>               Bases: <code>TypedDict</code></p> <p>Board updated successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateBoard </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Board</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateBoard.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Board\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateBoardMembership","title":"Response_updateBoardMembership","text":"<p>               Bases: <code>TypedDict</code></p> <p>Board membership updated successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateBoardMembership </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>BoardMembership</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateBoardMembership.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: BoardMembership\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateCard","title":"Response_updateCard","text":"<p>               Bases: <code>TypedDict</code></p> <p>Card updated successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateCard </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Card</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateCard.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Card\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateComments","title":"Response_updateComments","text":"<p>               Bases: <code>TypedDict</code></p> <p>Comment updated successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateComments </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Comment</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateComments.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Comment\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateCustomField","title":"Response_updateCustomField","text":"<p>               Bases: <code>TypedDict</code></p> <p>Custom field updated successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateCustomField </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>CustomField</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateCustomField.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: CustomField\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateCustomFieldGroup","title":"Response_updateCustomFieldGroup","text":"<p>               Bases: <code>TypedDict</code></p> <p>Custom field group updated successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateCustomFieldGroup </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>CustomFieldGroup</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateCustomFieldGroup.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: CustomFieldGroup\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateCustomFieldValue","title":"Response_updateCustomFieldValue","text":"<p>               Bases: <code>TypedDict</code></p> <p>Custom field value created or updated successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateCustomFieldValue </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>CustomFieldValue</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateCustomFieldValue.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: CustomFieldValue\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateLabel","title":"Response_updateLabel","text":"<p>               Bases: <code>TypedDict</code></p> <p>Label updated successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateLabel </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Label</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateLabel.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Label\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateList","title":"Response_updateList","text":"<p>               Bases: <code>TypedDict</code></p> <p>List updated successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateList </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>List</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateList.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: List\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateNotification","title":"Response_updateNotification","text":"<p>               Bases: <code>TypedDict</code></p> <p>Notification updated successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateNotification </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Notification</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateNotification.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Notification\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateNotificationService","title":"Response_updateNotificationService","text":"<p>               Bases: <code>TypedDict</code></p> <p>Notification service updated successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateNotificationService </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>NotificationService</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateNotificationService.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: NotificationService\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateProject","title":"Response_updateProject","text":"<p>               Bases: <code>TypedDict</code></p> <p>Project updated successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateProject </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Project</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateProject.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Project\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateTask","title":"Response_updateTask","text":"<p>               Bases: <code>TypedDict</code></p> <p>Task updated successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateTask </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Task</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateTask.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Task\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateTaskList","title":"Response_updateTaskList","text":"<p>               Bases: <code>TypedDict</code></p> <p>Task list updated successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateTaskList </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>TaskList</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateTaskList.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: TaskList\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateUser","title":"Response_updateUser","text":"<p>               Bases: <code>TypedDict</code></p> <p>User updated successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateUser </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>User</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateUser.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: User\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateUserAvatar","title":"Response_updateUserAvatar","text":"<p>               Bases: <code>TypedDict</code></p> <p>Avatar updated successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateUserAvatar </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>User</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateUserAvatar.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: User\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateUserEmail","title":"Response_updateUserEmail","text":"<p>               Bases: <code>TypedDict</code></p> <p>Email updated successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateUserEmail </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>User</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateUserEmail.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: User\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateUserPassword","title":"Response_updateUserPassword","text":"<p>               Bases: <code>TypedDict</code></p> <p>Password updated successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateUserPassword </li> </ul> ATTRIBUTE DESCRIPTION <code>included</code> <p> TYPE: <code>Included_updateUserPassword</code> </p> <code>item</code> <p> TYPE: <code>User</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateUserPassword.included","title":"included  <code>instance-attribute</code>","text":"<pre><code>included: Included_updateUserPassword\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateUserPassword.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: User\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateUserUsername","title":"Response_updateUserUsername","text":"<p>               Bases: <code>TypedDict</code></p> <p>Username updated successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateUserUsername </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>User</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateUserUsername.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: User\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateWebhook","title":"Response_updateWebhook","text":"<p>               Bases: <code>TypedDict</code></p> <p>Webhook updated successfully</p> Returned by: <ul> <li> Plankapy v2 api Paths/Endpoints <code></code>\u00a0PlankaEndpoints <code></code>\u00a0updateWebhook </li> </ul> ATTRIBUTE DESCRIPTION <code>item</code> <p> TYPE: <code>Webhook</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Response_updateWebhook.item","title":"item  <code>instance-attribute</code>","text":"<pre><code>item: Webhook\n</code></pre>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Stopwatch","title":"Stopwatch","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api <ul> <li> REST Typing <ul> <li> <code></code>\u00a0Card <code></code>\u00a0stopwatch </li> <li> <code></code>\u00a0Included_getBoard_all <code></code>\u00a0stopwatch </li> <li> <code></code>\u00a0Included_getList_all <code></code>\u00a0stopwatch </li> <li> <code></code>\u00a0Item_getCard <code></code>\u00a0stopwatch </li> <li> <code></code>\u00a0Items_getCards <code></code>\u00a0stopwatch </li> <li> <code></code>\u00a0Request_updateCard <code></code>\u00a0stopwatch </li> </ul> </li> <li> Schemas <code></code>\u00a0Card <code></code>\u00a0stopwatch </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>startedAt</code> <p>The time that a running stopwatch was started</p> <p> TYPE: <code>str | None</code> </p> <code>total</code> <p>The number of seconds that the stopwatch has been running</p> <p> TYPE: <code>int</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Stopwatch.startedAt","title":"startedAt  <code>instance-attribute</code>","text":"<pre><code>startedAt: str | None\n</code></pre> <p>The time that a running stopwatch was started</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Stopwatch.total","title":"total  <code>instance-attribute</code>","text":"<pre><code>total: int\n</code></pre> <p>The number of seconds that the stopwatch has been running</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Task","title":"Task","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0tasks </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_duplicateCard <code></code>\u00a0tasks </li> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0tasks </li> <li> <code></code>\u00a0Included_getCard <code></code>\u00a0tasks </li> <li> <code></code>\u00a0Included_getCards <code></code>\u00a0tasks </li> <li> <code></code>\u00a0Included_getList <code></code>\u00a0tasks </li> <li> <code></code>\u00a0Included_getTaskList <code></code>\u00a0tasks </li> <li> <code></code>\u00a0Response_createTask <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteTask <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateTask <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Task <code></code>\u00a0Task </li> </ul> ATTRIBUTE DESCRIPTION <code>assigneeUserId</code> <p>ID of the user assigned to the task</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the task was created</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the task</p> <p> TYPE: <code>str</code> </p> <code>isCompleted</code> <p>Whether the task is completed</p> <p> TYPE: <code>bool</code> </p> <code>linkedCardId</code> <p>ID of the card linked to the task</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the task</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the task within the task list</p> <p> TYPE: <code>int</code> </p> <code>taskListId</code> <p>ID of the task list the task belongs to</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the task was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Task.assigneeUserId","title":"assigneeUserId  <code>instance-attribute</code>","text":"<pre><code>assigneeUserId: str\n</code></pre> <p>ID of the user assigned to the task</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Task.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the task was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Task.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the task</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Task.isCompleted","title":"isCompleted  <code>instance-attribute</code>","text":"<pre><code>isCompleted: bool\n</code></pre> <p>Whether the task is completed</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Task.linkedCardId","title":"linkedCardId  <code>instance-attribute</code>","text":"<pre><code>linkedCardId: str\n</code></pre> <p>ID of the card linked to the task</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Task.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the task</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Task.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the task within the task list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Task.taskListId","title":"taskListId  <code>instance-attribute</code>","text":"<pre><code>taskListId: str\n</code></pre> <p>ID of the task list the task belongs to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Task.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the task was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.TaskList","title":"TaskList","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0task_lists </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_duplicateCard <code></code>\u00a0taskLists </li> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0taskLists </li> <li> <code></code>\u00a0Included_getCard <code></code>\u00a0taskLists </li> <li> <code></code>\u00a0Included_getCards <code></code>\u00a0taskLists </li> <li> <code></code>\u00a0Included_getList <code></code>\u00a0taskLists </li> <li> <code></code>\u00a0Response_createTaskList <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteTaskList <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_getTaskList <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateTaskList <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Task List <code></code>\u00a0TaskList </li> </ul> ATTRIBUTE DESCRIPTION <code>cardId</code> <p>ID of the card the task list belongs to</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the task list was created</p> <p> TYPE: <code>str</code> </p> <code>hideCompletedTasks</code> <p>Whether to hide completed tasks</p> <p> TYPE: <code>bool</code> </p> <code>id</code> <p>Unique identifier for the task list</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the task list</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the task list within the card</p> <p> TYPE: <code>int</code> </p> <code>showOnFrontOfCard</code> <p>Whether to show the task list on the front of the card</p> <p> TYPE: <code>bool</code> </p> <code>updatedAt</code> <p>When the task list was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.TaskList.cardId","title":"cardId  <code>instance-attribute</code>","text":"<pre><code>cardId: str\n</code></pre> <p>ID of the card the task list belongs to</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.TaskList.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the task list was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.TaskList.hideCompletedTasks","title":"hideCompletedTasks  <code>instance-attribute</code>","text":"<pre><code>hideCompletedTasks: bool\n</code></pre> <p>Whether to hide completed tasks</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.TaskList.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the task list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.TaskList.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the task list</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.TaskList.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the task list within the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.TaskList.showOnFrontOfCard","title":"showOnFrontOfCard  <code>instance-attribute</code>","text":"<pre><code>showOnFrontOfCard: bool\n</code></pre> <p>Whether to show the task list on the front of the card</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.TaskList.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the task list was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User","title":"User","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0users </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0users </li> <li> <code></code>\u00a0Included_getBoardActions <code></code>\u00a0users </li> <li> <code></code>\u00a0Included_getCard <code></code>\u00a0users </li> <li> <code></code>\u00a0Included_getCardActions <code></code>\u00a0users </li> <li> <code></code>\u00a0Included_getCards <code></code>\u00a0users </li> <li> <code></code>\u00a0Included_getComments <code></code>\u00a0users </li> <li> <code></code>\u00a0Included_getList <code></code>\u00a0users </li> <li> <code></code>\u00a0Included_getNotification <code></code>\u00a0users </li> <li> <code></code>\u00a0Included_getNotifications <code></code>\u00a0users </li> <li> <code></code>\u00a0Included_getProject <code></code>\u00a0users </li> <li> <code></code>\u00a0Included_getProjects <code></code>\u00a0users </li> <li> <code></code>\u00a0Response_createUser <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteUser <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_getUser <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_getUsers <code></code>\u00a0items </li> <li> <code></code>\u00a0Response_updateUser <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateUserAvatar <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateUserEmail <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateUserPassword <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateUserUsername <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models User <code></code>\u00a0User </li> </ul> ATTRIBUTE DESCRIPTION <code>apiKeyPrefix</code> <p>The prefix for the user's API key if one is active</p> <p> TYPE: <code>str | None</code> </p> <code>avatar</code> <p>Avatar information for the user with generated URLs</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>createdAt</code> <p>When the user was created</p> <p> TYPE: <code>str</code> </p> <code>defaultEditorMode</code> <p>Default markdown editor mode (personal field)</p> <p> TYPE: <code>NotRequired[Literal['wysiwyg', 'markup']]</code> </p> <code>defaultHomeView</code> <p>Default view mode for the home page (personal field)</p> <p> TYPE: <code>NotRequired[Literal['gridProjects', 'groupedProjects']]</code> </p> <code>defaultProjectsOrder</code> <p>Default sort order for projects display (personal field)</p> <p> TYPE: <code>NotRequired[Literal['byDefault', 'alphabetically', 'byCreationTime']]</code> </p> <code>email</code> <p>Email address for login and notifications (private field)</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>enableFavoritesByDefault</code> <p>Whether favorites are enabled by default (personal field)</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>gravatarUrl</code> <p>Gravatar URL for the user (conditionally added if configured)</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>id</code> <p>Unique identifier for the user</p> <p> TYPE: <code>str</code> </p> <code>isDeactivated</code> <p>Whether the user account is deactivated and cannot log in</p> <p> TYPE: <code>bool</code> </p> <code>isDefaultAdmin</code> <p>Whether the user is the default admin (visible only to current user or admin)</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>isSsoUser</code> <p>Whether the user is SSO user (private field)</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>language</code> <p>Preferred language for user interface and notifications (personal field)</p> <p> TYPE: <code>NotRequired[Literal['ar-YE', 'bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-GB', 'en-US', 'es-ES', 'et-EE', 'fa-IR', 'fi-FI', 'fr-FR', 'hu-HU', 'id-ID', 'it-IT', 'ja-JP', 'ko-KR', 'nl-NL', 'pl-PL', 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sk-SK', 'sr-Cyrl-RS', 'sr-Latn-RS', 'sv-SE', 'tr-TR', 'uk-UA', 'uz-UZ', 'zh-CN', 'zh-TW']]</code> </p> <code>lockedFieldNames</code> <p>List of fields locked from editing (visible only to current user or admin)</p> <p> TYPE: <code>NotRequired[list[Literal['email', 'password', 'name']]]</code> </p> <code>name</code> <p>Full display name of the user</p> <p> TYPE: <code>str</code> </p> <code>organization</code> <p>Organization or company name</p> <p> TYPE: <code>str</code> </p> <code>phone</code> <p>Contact phone number</p> <p> TYPE: <code>str</code> </p> <code>role</code> <p>User role defining access permissions</p> <p> TYPE: <code>Literal['admin', 'projectOwner', 'boardUser']</code> </p> <code>subscribeToCardWhenCommenting</code> <p>Whether the user subscribes to cards when commenting (personal field)</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>subscribeToOwnCards</code> <p>Whether the user subscribes to their own cards (personal field)</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>termsType</code> <p>Type of terms applicable to the user based on role</p> <p> TYPE: <code>Literal['general', 'extended']</code> </p> <code>turnOffRecentCardHighlighting</code> <p>Whether recent card highlighting is disabled (personal field)</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>updatedAt</code> <p>When the user was last updated</p> <p> TYPE: <code>str</code> </p> <code>username</code> <p>Unique username for user identification</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.apiKeyPrefix","title":"apiKeyPrefix  <code>instance-attribute</code>","text":"<pre><code>apiKeyPrefix: str | None\n</code></pre> <p>The prefix for the user's API key if one is active</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.avatar","title":"avatar  <code>instance-attribute</code>","text":"<pre><code>avatar: dict[str, Any]\n</code></pre> <p>Avatar information for the user with generated URLs</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the user was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.defaultEditorMode","title":"defaultEditorMode  <code>instance-attribute</code>","text":"<pre><code>defaultEditorMode: NotRequired[Literal['wysiwyg', 'markup']]\n</code></pre> <p>Default markdown editor mode (personal field)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.defaultHomeView","title":"defaultHomeView  <code>instance-attribute</code>","text":"<pre><code>defaultHomeView: NotRequired[Literal['gridProjects', 'groupedProjects']]\n</code></pre> <p>Default view mode for the home page (personal field)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.defaultProjectsOrder","title":"defaultProjectsOrder  <code>instance-attribute</code>","text":"<pre><code>defaultProjectsOrder: NotRequired[Literal['byDefault', 'alphabetically', 'byCreationTime']]\n</code></pre> <p>Default sort order for projects display (personal field)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.email","title":"email  <code>instance-attribute</code>","text":"<pre><code>email: NotRequired[str]\n</code></pre> <p>Email address for login and notifications (private field)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.enableFavoritesByDefault","title":"enableFavoritesByDefault  <code>instance-attribute</code>","text":"<pre><code>enableFavoritesByDefault: NotRequired[bool]\n</code></pre> <p>Whether favorites are enabled by default (personal field)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.gravatarUrl","title":"gravatarUrl  <code>instance-attribute</code>","text":"<pre><code>gravatarUrl: NotRequired[str]\n</code></pre> <p>Gravatar URL for the user (conditionally added if configured)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the user</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.isDeactivated","title":"isDeactivated  <code>instance-attribute</code>","text":"<pre><code>isDeactivated: bool\n</code></pre> <p>Whether the user account is deactivated and cannot log in</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.isDefaultAdmin","title":"isDefaultAdmin  <code>instance-attribute</code>","text":"<pre><code>isDefaultAdmin: NotRequired[bool]\n</code></pre> <p>Whether the user is the default admin (visible only to current user or admin)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.isSsoUser","title":"isSsoUser  <code>instance-attribute</code>","text":"<pre><code>isSsoUser: NotRequired[bool]\n</code></pre> <p>Whether the user is SSO user (private field)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.language","title":"language  <code>instance-attribute</code>","text":"<pre><code>language: NotRequired[Literal['ar-YE', 'bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-GB', 'en-US', 'es-ES', 'et-EE', 'fa-IR', 'fi-FI', 'fr-FR', 'hu-HU', 'id-ID', 'it-IT', 'ja-JP', 'ko-KR', 'nl-NL', 'pl-PL', 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sk-SK', 'sr-Cyrl-RS', 'sr-Latn-RS', 'sv-SE', 'tr-TR', 'uk-UA', 'uz-UZ', 'zh-CN', 'zh-TW']]\n</code></pre> <p>Preferred language for user interface and notifications (personal field)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.lockedFieldNames","title":"lockedFieldNames  <code>instance-attribute</code>","text":"<pre><code>lockedFieldNames: NotRequired[list[Literal['email', 'password', 'name']]]\n</code></pre> <p>List of fields locked from editing (visible only to current user or admin)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Full display name of the user</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.organization","title":"organization  <code>instance-attribute</code>","text":"<pre><code>organization: str\n</code></pre> <p>Organization or company name</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.phone","title":"phone  <code>instance-attribute</code>","text":"<pre><code>phone: str\n</code></pre> <p>Contact phone number</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.role","title":"role  <code>instance-attribute</code>","text":"<pre><code>role: Literal['admin', 'projectOwner', 'boardUser']\n</code></pre> <p>User role defining access permissions</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.subscribeToCardWhenCommenting","title":"subscribeToCardWhenCommenting  <code>instance-attribute</code>","text":"<pre><code>subscribeToCardWhenCommenting: NotRequired[bool]\n</code></pre> <p>Whether the user subscribes to cards when commenting (personal field)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.subscribeToOwnCards","title":"subscribeToOwnCards  <code>instance-attribute</code>","text":"<pre><code>subscribeToOwnCards: NotRequired[bool]\n</code></pre> <p>Whether the user subscribes to their own cards (personal field)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.termsType","title":"termsType  <code>instance-attribute</code>","text":"<pre><code>termsType: Literal['general', 'extended']\n</code></pre> <p>Type of terms applicable to the user based on role</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.turnOffRecentCardHighlighting","title":"turnOffRecentCardHighlighting  <code>instance-attribute</code>","text":"<pre><code>turnOffRecentCardHighlighting: NotRequired[bool]\n</code></pre> <p>Whether recent card highlighting is disabled (personal field)</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the user was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.User.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username: str\n</code></pre> <p>Unique username for user identification</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Webhook","title":"Webhook","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0webhooks </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Response_createWebhook <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteWebhook <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_getWebhooks <code></code>\u00a0items </li> <li> <code></code>\u00a0Response_updateWebhook <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Webhook <code></code>\u00a0Webhook </li> </ul> ATTRIBUTE DESCRIPTION <code>accessToken</code> <p>Access token for webhook authentication</p> <p> TYPE: <code>str</code> </p> <code>boardId</code> <p>The board that the webhook is associated with</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the webhook was created</p> <p> TYPE: <code>str</code> </p> <code>events</code> <p>List of events that trigger the webhook</p> <p> TYPE: <code>list[WebhookEvent]</code> </p> <code>excludedEvents</code> <p>List of events excluded from the webhook</p> <p> TYPE: <code>list[WebhookEvent]</code> </p> <code>id</code> <p>Unique identifier for the webhook</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the webhook</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the webhook was last updated</p> <p> TYPE: <code>str</code> </p> <code>url</code> <p>URL endpoint for the webhook</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Webhook.accessToken","title":"accessToken  <code>instance-attribute</code>","text":"<pre><code>accessToken: str\n</code></pre> <p>Access token for webhook authentication</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Webhook.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: str\n</code></pre> <p>The board that the webhook is associated with</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Webhook.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the webhook was created</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Webhook.events","title":"events  <code>instance-attribute</code>","text":"<pre><code>events: list[WebhookEvent]\n</code></pre> <p>List of events that trigger the webhook</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Webhook.excludedEvents","title":"excludedEvents  <code>instance-attribute</code>","text":"<pre><code>excludedEvents: list[WebhookEvent]\n</code></pre> <p>List of events excluded from the webhook</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Webhook.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the webhook</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Webhook.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the webhook</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Webhook.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the webhook was last updated</p>"},{"location":"v2/api/rest-typing/#plankapy.v2.api.typ.Webhook.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre> <p>URL endpoint for the webhook</p>"},{"location":"v2/api/schemas/","title":"Schemas","text":"<p>Typed JSON schemas for all Planka objects</p> CLASS DESCRIPTION <code>Action</code> <code>Attachment</code> <code>BackgroundImage</code> <code>BaseCustomFieldGroup</code> <code>Board</code> <code>BoardMembership</code> <code>Card</code> <code>CardLabel</code> <code>CardMembership</code> <code>Comment</code> <code>Config</code> <code>CustomField</code> <code>CustomFieldGroup</code> <code>CustomFieldValue</code> <code>Label</code> <code>List</code> <code>Notification</code> <code>NotificationService</code> <code>Project</code> <code>ProjectManager</code> <code>Stopwatch</code> <code>Task</code> <code>TaskList</code> <code>User</code> <code>Webhook</code>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Action","title":"Action","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0actions </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_moveListCards <code></code>\u00a0actions </li> <li> <code></code>\u00a0Response_getBoardActions <code></code>\u00a0items </li> <li> <code></code>\u00a0Response_getCardActions <code></code>\u00a0items </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Action <code></code>\u00a0Action </li> </ul> ATTRIBUTE DESCRIPTION <code>boardId</code> <p>ID of the board where the action occurred</p> <p> TYPE: <code>str</code> </p> <code>cardId</code> <p>ID of the card where the action occurred</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the action was created</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>Action specific data (varies by type)</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>id</code> <p>Unique identifier for the action</p> <p> TYPE: <code>str</code> </p> <code>type</code> <p>Type of the action</p> <p> TYPE: <code>Literal['createCard', 'moveCard', 'addMemberToCard', 'removeMemberFromCard', 'completeTask', 'uncompleteTask']</code> </p> <code>updatedAt</code> <p>When the action was last updated</p> <p> TYPE: <code>str</code> </p> <code>userId</code> <p>ID of the user who performed the action</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Action.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: str\n</code></pre> <p>ID of the board where the action occurred</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Action.cardId","title":"cardId  <code>instance-attribute</code>","text":"<pre><code>cardId: str\n</code></pre> <p>ID of the card where the action occurred</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Action.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the action was created</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Action.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: dict[str, Any]\n</code></pre> <p>Action specific data (varies by type)</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Action.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the action</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Action.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['createCard', 'moveCard', 'addMemberToCard', 'removeMemberFromCard', 'completeTask', 'uncompleteTask']\n</code></pre> <p>Type of the action</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Action.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the action was last updated</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Action.userId","title":"userId  <code>instance-attribute</code>","text":"<pre><code>userId: str\n</code></pre> <p>ID of the user who performed the action</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Attachment","title":"Attachment","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <ul> <li> <code></code>\u00a0Included_duplicateCard <code></code>\u00a0attachments </li> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0attachments </li> <li> <code></code>\u00a0Included_getCard <code></code>\u00a0attachments </li> <li> <code></code>\u00a0Included_getCards <code></code>\u00a0attachments </li> <li> <code></code>\u00a0Included_getList <code></code>\u00a0attachments </li> <li> <code></code>\u00a0Response_createAttachment <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteAttachment <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateAttachment <code></code>\u00a0item </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Attachment <code></code>\u00a0Attachment </li> </ul> ATTRIBUTE DESCRIPTION <code>cardId</code> <p>ID of the card the attachment belongs to</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the attachment was created</p> <p> TYPE: <code>str</code> </p> <code>creatorUserId</code> <p>ID of the user who created the attachment</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>Attachment specific data (varies by type)</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>id</code> <p>Unique identifier for the attachment</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the attachment</p> <p> TYPE: <code>str</code> </p> <code>type</code> <p>Type of the attachment</p> <p> TYPE: <code>Literal['file', 'link']</code> </p> <code>updatedAt</code> <p>When the attachment was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Attachment.cardId","title":"cardId  <code>instance-attribute</code>","text":"<pre><code>cardId: str\n</code></pre> <p>ID of the card the attachment belongs to</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Attachment.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the attachment was created</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Attachment.creatorUserId","title":"creatorUserId  <code>instance-attribute</code>","text":"<pre><code>creatorUserId: str\n</code></pre> <p>ID of the user who created the attachment</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Attachment.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: dict[str, Any]\n</code></pre> <p>Attachment specific data (varies by type)</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Attachment.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the attachment</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Attachment.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the attachment</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Attachment.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['file', 'link']\n</code></pre> <p>Type of the attachment</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Attachment.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the attachment was last updated</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.BackgroundImage","title":"BackgroundImage","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <ul> <li> <code></code>\u00a0Included_getProject <code></code>\u00a0backgroundImages </li> <li> <code></code>\u00a0Included_getProjects <code></code>\u00a0backgroundImages </li> <li> <code></code>\u00a0Response_createBackgroundImage <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteBackgroundImage <code></code>\u00a0item </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Background Image <code></code>\u00a0BackgroundImage </li> </ul> ATTRIBUTE DESCRIPTION <code>createdAt</code> <p>When the background image was created</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the background image</p> <p> TYPE: <code>str</code> </p> <code>projectId</code> <p>ID of the project the background image belongs to</p> <p> TYPE: <code>str</code> </p> <code>sizeInBytes</code> <p>File size of the background image in bytes</p> <p> TYPE: <code>str</code> </p> <code>thumbnailUrls</code> <p>URLs for different thumbnail sizes of the background image</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>updatedAt</code> <p>When the background image was last updated</p> <p> TYPE: <code>str</code> </p> <code>url</code> <p>URL to access the full-size background image</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.BackgroundImage.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the background image was created</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.BackgroundImage.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the background image</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.BackgroundImage.projectId","title":"projectId  <code>instance-attribute</code>","text":"<pre><code>projectId: str\n</code></pre> <p>ID of the project the background image belongs to</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.BackgroundImage.sizeInBytes","title":"sizeInBytes  <code>instance-attribute</code>","text":"<pre><code>sizeInBytes: str\n</code></pre> <p>File size of the background image in bytes</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.BackgroundImage.thumbnailUrls","title":"thumbnailUrls  <code>instance-attribute</code>","text":"<pre><code>thumbnailUrls: dict[str, Any]\n</code></pre> <p>URLs for different thumbnail sizes of the background image</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.BackgroundImage.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the background image was last updated</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.BackgroundImage.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre> <p>URL to access the full-size background image</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.BaseCustomFieldGroup","title":"BaseCustomFieldGroup","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0base_custom_field_groups </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_getProject <code></code>\u00a0baseCustomFieldGroups </li> <li> <code></code>\u00a0Included_getProjects <code></code>\u00a0baseCustomFieldGroups </li> <li> <code></code>\u00a0Response_createBaseCustomFieldGroup <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteBaseCustomFieldGroup <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateBaseCustomFieldGroup <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Base Custom Field Group <code></code>\u00a0BaseCustomFieldGroup </li> </ul> ATTRIBUTE DESCRIPTION <code>createdAt</code> <p>When the base custom field group was created</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the base custom field group</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the base custom field group</p> <p> TYPE: <code>str</code> </p> <code>projectId</code> <p>ID of the project the base custom field group belongs to</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the base custom field group was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.BaseCustomFieldGroup.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the base custom field group was created</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.BaseCustomFieldGroup.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the base custom field group</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.BaseCustomFieldGroup.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the base custom field group</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.BaseCustomFieldGroup.projectId","title":"projectId  <code>instance-attribute</code>","text":"<pre><code>projectId: str\n</code></pre> <p>ID of the project the base custom field group belongs to</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.BaseCustomFieldGroup.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the base custom field group was last updated</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Board","title":"Board","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0boards </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_getProject <code></code>\u00a0boards </li> <li> <code></code>\u00a0Included_getProjects <code></code>\u00a0boards </li> <li> <code></code>\u00a0Response_createBoard <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteBoard <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateBoard <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 <ul> <li> models Board <code></code>\u00a0Board </li> <li> api REST Typing <code></code>\u00a0Item_getBoard </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>alwaysDisplayCardCreator</code> <p>Whether to always display the card creator</p> <p> TYPE: <code>bool</code> </p> <code>createdAt</code> <p>When the board was created</p> <p> TYPE: <code>str</code> </p> <code>defaultCardType</code> <p>Default card type for new cards</p> <p> TYPE: <code>Literal['project', 'story']</code> </p> <code>defaultView</code> <p>Default view for the board</p> <p> TYPE: <code>Literal['kanban', 'grid', 'list']</code> </p> <code>expandTaskListsByDefault</code> <p>Whether to expand task lists by default</p> <p> TYPE: <code>bool</code> </p> <code>id</code> <p>Unique identifier for the board</p> <p> TYPE: <code>str</code> </p> <code>limitCardTypesToDefaultOne</code> <p>Whether to limit card types to default one</p> <p> TYPE: <code>bool</code> </p> <code>name</code> <p>Name/title of the board</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the board within the project</p> <p> TYPE: <code>int</code> </p> <code>projectId</code> <p>ID of the project the board belongs to</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the board was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Board.alwaysDisplayCardCreator","title":"alwaysDisplayCardCreator  <code>instance-attribute</code>","text":"<pre><code>alwaysDisplayCardCreator: bool\n</code></pre> <p>Whether to always display the card creator</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Board.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the board was created</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Board.defaultCardType","title":"defaultCardType  <code>instance-attribute</code>","text":"<pre><code>defaultCardType: Literal['project', 'story']\n</code></pre> <p>Default card type for new cards</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Board.defaultView","title":"defaultView  <code>instance-attribute</code>","text":"<pre><code>defaultView: Literal['kanban', 'grid', 'list']\n</code></pre> <p>Default view for the board</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Board.expandTaskListsByDefault","title":"expandTaskListsByDefault  <code>instance-attribute</code>","text":"<pre><code>expandTaskListsByDefault: bool\n</code></pre> <p>Whether to expand task lists by default</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Board.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the board</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Board.limitCardTypesToDefaultOne","title":"limitCardTypesToDefaultOne  <code>instance-attribute</code>","text":"<pre><code>limitCardTypesToDefaultOne: bool\n</code></pre> <p>Whether to limit card types to default one</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Board.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the board</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Board.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the board within the project</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Board.projectId","title":"projectId  <code>instance-attribute</code>","text":"<pre><code>projectId: str\n</code></pre> <p>ID of the project the board belongs to</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Board.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the board was last updated</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.BoardMembership","title":"BoardMembership","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0board_memberships </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_createBoard <code></code>\u00a0boardMemberships </li> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0boardMemberships </li> <li> <code></code>\u00a0Included_getProject <code></code>\u00a0boardMemberships </li> <li> <code></code>\u00a0Included_getProjects <code></code>\u00a0boardMemberships </li> <li> <code></code>\u00a0Response_createBoardMembership <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteBoardMembership <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateBoardMembership <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Board Membership <code></code>\u00a0BoardMembership </li> </ul> ATTRIBUTE DESCRIPTION <code>boardId</code> <p>ID of the board the membership is associated with</p> <p> TYPE: <code>str</code> </p> <code>canComment</code> <p>Whether the user can comment on cards (applies only to viewers)</p> <p> TYPE: <code>bool</code> </p> <code>createdAt</code> <p>When the board membership was created</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the board membership</p> <p> TYPE: <code>str</code> </p> <code>projectId</code> <p>ID of the project the board membership belongs to (denormalized)</p> <p> TYPE: <code>str</code> </p> <code>role</code> <p>Role of the user in the board</p> <p> TYPE: <code>Literal['editor', 'viewer']</code> </p> <code>updatedAt</code> <p>When the board membership was last updated</p> <p> TYPE: <code>str</code> </p> <code>userId</code> <p>ID of the user who is a member of the board</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.BoardMembership.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: str\n</code></pre> <p>ID of the board the membership is associated with</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.BoardMembership.canComment","title":"canComment  <code>instance-attribute</code>","text":"<pre><code>canComment: bool\n</code></pre> <p>Whether the user can comment on cards (applies only to viewers)</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.BoardMembership.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the board membership was created</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.BoardMembership.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the board membership</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.BoardMembership.projectId","title":"projectId  <code>instance-attribute</code>","text":"<pre><code>projectId: str\n</code></pre> <p>ID of the project the board membership belongs to (denormalized)</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.BoardMembership.role","title":"role  <code>instance-attribute</code>","text":"<pre><code>role: Literal['editor', 'viewer']\n</code></pre> <p>Role of the user in the board</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.BoardMembership.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the board membership was last updated</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.BoardMembership.userId","title":"userId  <code>instance-attribute</code>","text":"<pre><code>userId: str\n</code></pre> <p>ID of the user who is a member of the board</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Card","title":"Card","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0cards </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_deleteList <code></code>\u00a0cards </li> <li> <code></code>\u00a0Included_moveListCards <code></code>\u00a0cards </li> <li> <code></code>\u00a0Included_sortList <code></code>\u00a0cards </li> <li> <code></code>\u00a0Response_createCard <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteCard <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_duplicateCard <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_readCardNotifications <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateCard <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 <ul> <li> models Card <code></code>\u00a0Card </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_getBoard_all </li> <li> <code></code>\u00a0Included_getList_all </li> <li> <code></code>\u00a0Item_getCard </li> <li> <code></code>\u00a0Items_getCards </li> </ul> </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>boardId</code> <p>ID of the board the card belongs to (denormalized)</p> <p> TYPE: <code>str</code> </p> <code>commentsTotal</code> <p>Total number of comments on the card</p> <p> TYPE: <code>int</code> </p> <code>coverAttachmentId</code> <p>ID of the attachment used as cover</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the card was created</p> <p> TYPE: <code>str</code> </p> <code>creatorUserId</code> <p>ID of the user who created the card</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>Detailed description of the card</p> <p> TYPE: <code>str</code> </p> <code>dueDate</code> <p>Due date for the card</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the card</p> <p> TYPE: <code>str</code> </p> <code>isClosed</code> <p>Whether the card is closed</p> <p> TYPE: <code>bool</code> </p> <code>isDueCompleted</code> <p>Whether the due date is completed</p> <p> TYPE: <code>bool</code> </p> <code>listChangedAt</code> <p>When the card was last moved between lists</p> <p> TYPE: <code>str</code> </p> <code>listId</code> <p>ID of the list the card belongs to</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the card</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the card within the list</p> <p> TYPE: <code>int</code> </p> <code>prevListId</code> <p>ID of the previous list the card was in (available when in archive or trash)</p> <p> TYPE: <code>str</code> </p> <code>stopwatch</code> <p>Stopwatch data for time tracking</p> <p> TYPE: <code>Stopwatch | None</code> </p> <code>type</code> <p>Type of the card</p> <p> TYPE: <code>Literal['project', 'story']</code> </p> <code>updatedAt</code> <p>When the card was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Card.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: str\n</code></pre> <p>ID of the board the card belongs to (denormalized)</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Card.commentsTotal","title":"commentsTotal  <code>instance-attribute</code>","text":"<pre><code>commentsTotal: int\n</code></pre> <p>Total number of comments on the card</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Card.coverAttachmentId","title":"coverAttachmentId  <code>instance-attribute</code>","text":"<pre><code>coverAttachmentId: str\n</code></pre> <p>ID of the attachment used as cover</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Card.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the card was created</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Card.creatorUserId","title":"creatorUserId  <code>instance-attribute</code>","text":"<pre><code>creatorUserId: str\n</code></pre> <p>ID of the user who created the card</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Card.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str\n</code></pre> <p>Detailed description of the card</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Card.dueDate","title":"dueDate  <code>instance-attribute</code>","text":"<pre><code>dueDate: str\n</code></pre> <p>Due date for the card</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Card.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the card</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Card.isClosed","title":"isClosed  <code>instance-attribute</code>","text":"<pre><code>isClosed: bool\n</code></pre> <p>Whether the card is closed</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Card.isDueCompleted","title":"isDueCompleted  <code>instance-attribute</code>","text":"<pre><code>isDueCompleted: bool\n</code></pre> <p>Whether the due date is completed</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Card.listChangedAt","title":"listChangedAt  <code>instance-attribute</code>","text":"<pre><code>listChangedAt: str\n</code></pre> <p>When the card was last moved between lists</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Card.listId","title":"listId  <code>instance-attribute</code>","text":"<pre><code>listId: str\n</code></pre> <p>ID of the list the card belongs to</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Card.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the card</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Card.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the card within the list</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Card.prevListId","title":"prevListId  <code>instance-attribute</code>","text":"<pre><code>prevListId: str\n</code></pre> <p>ID of the previous list the card was in (available when in archive or trash)</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Card.stopwatch","title":"stopwatch  <code>instance-attribute</code>","text":"<pre><code>stopwatch: Stopwatch | None\n</code></pre> <p>Stopwatch data for time tracking</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Card.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['project', 'story']\n</code></pre> <p>Type of the card</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Card.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the card was last updated</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CardLabel","title":"CardLabel","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0card_labels </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_duplicateCard <code></code>\u00a0cardLabels </li> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0cardLabels </li> <li> <code></code>\u00a0Included_getCard <code></code>\u00a0cardLabels </li> <li> <code></code>\u00a0Included_getCards <code></code>\u00a0cardLabels </li> <li> <code></code>\u00a0Included_getList <code></code>\u00a0cardLabels </li> <li> <code></code>\u00a0Response_createCardLabel <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteCardLabel <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Card Label <code></code>\u00a0CardLabel </li> </ul> ATTRIBUTE DESCRIPTION <code>cardId</code> <p>ID of the card the label is associated with</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the card-label association was created</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the card-label association</p> <p> TYPE: <code>str</code> </p> <code>labelId</code> <p>ID of the label associated with the card</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the card-label association was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CardLabel.cardId","title":"cardId  <code>instance-attribute</code>","text":"<pre><code>cardId: str\n</code></pre> <p>ID of the card the label is associated with</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CardLabel.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the card-label association was created</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CardLabel.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the card-label association</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CardLabel.labelId","title":"labelId  <code>instance-attribute</code>","text":"<pre><code>labelId: str\n</code></pre> <p>ID of the label associated with the card</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CardLabel.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the card-label association was last updated</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CardMembership","title":"CardMembership","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0card_memberships </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_duplicateCard <code></code>\u00a0cardMemberships </li> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0cardMemberships </li> <li> <code></code>\u00a0Included_getCard <code></code>\u00a0cardMemberships </li> <li> <code></code>\u00a0Included_getCards <code></code>\u00a0cardMemberships </li> <li> <code></code>\u00a0Included_getList <code></code>\u00a0cardMemberships </li> <li> <code></code>\u00a0Response_createCardMembership <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteCardMembership <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Card Membership <code></code>\u00a0CardMembership </li> </ul> ATTRIBUTE DESCRIPTION <code>cardId</code> <p>ID of the card the user is a member of</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the card membership was created</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the card membership</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the card membership was last updated</p> <p> TYPE: <code>str</code> </p> <code>userId</code> <p>ID of the user who is a member of the card</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CardMembership.cardId","title":"cardId  <code>instance-attribute</code>","text":"<pre><code>cardId: str\n</code></pre> <p>ID of the card the user is a member of</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CardMembership.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the card membership was created</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CardMembership.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the card membership</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CardMembership.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the card membership was last updated</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CardMembership.userId","title":"userId  <code>instance-attribute</code>","text":"<pre><code>userId: str\n</code></pre> <p>ID of the user who is a member of the card</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Comment","title":"Comment","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0comments </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Response_createComment <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteComment <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_getComments <code></code>\u00a0items </li> <li> <code></code>\u00a0Response_updateComments <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Comment <code></code>\u00a0Comment </li> </ul> ATTRIBUTE DESCRIPTION <code>cardId</code> <p>ID of the card the comment belongs to</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the comment was created</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the comment</p> <p> TYPE: <code>str</code> </p> <code>text</code> <p>Content of the comment</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the comment was last updated</p> <p> TYPE: <code>str</code> </p> <code>userId</code> <p>ID of the user who created the comment</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Comment.cardId","title":"cardId  <code>instance-attribute</code>","text":"<pre><code>cardId: str\n</code></pre> <p>ID of the card the comment belongs to</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Comment.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the comment was created</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Comment.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the comment</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Comment.text","title":"text  <code>instance-attribute</code>","text":"<pre><code>text: str\n</code></pre> <p>Content of the comment</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Comment.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the comment was last updated</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Comment.userId","title":"userId  <code>instance-attribute</code>","text":"<pre><code>userId: str\n</code></pre> <p>ID of the user who created the comment</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Config","title":"Config","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0config </li> <li> api REST Typing <code></code>\u00a0Response_getConfig <code></code>\u00a0item </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Config <code></code>\u00a0Config </li> </ul> ATTRIBUTE DESCRIPTION <code>activeUsersLimit</code> <p>Maximum number of active users allowed (conditionally added for admins if configured)</p> <p> TYPE: <code>NotRequired[int]</code> </p> <code>oidc</code> <p>OpenID Connect configuration (null if not configured)</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>version</code> <p>Current version of the PLANKA application</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Config.activeUsersLimit","title":"activeUsersLimit  <code>instance-attribute</code>","text":"<pre><code>activeUsersLimit: NotRequired[int]\n</code></pre> <p>Maximum number of active users allowed (conditionally added for admins if configured)</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Config.oidc","title":"oidc  <code>instance-attribute</code>","text":"<pre><code>oidc: dict[str, Any]\n</code></pre> <p>OpenID Connect configuration (null if not configured)</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Config.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str\n</code></pre> <p>Current version of the PLANKA application</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomField","title":"CustomField","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0custom_fields </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_duplicateCard <code></code>\u00a0customFields </li> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0customFields </li> <li> <code></code>\u00a0Included_getCard <code></code>\u00a0customFields </li> <li> <code></code>\u00a0Included_getCards <code></code>\u00a0customFields </li> <li> <code></code>\u00a0Included_getCustomFieldGroup <code></code>\u00a0customFields </li> <li> <code></code>\u00a0Included_getList <code></code>\u00a0customFields </li> <li> <code></code>\u00a0Included_getProject <code></code>\u00a0customFields </li> <li> <code></code>\u00a0Included_getProjects <code></code>\u00a0customFields </li> <li> <code></code>\u00a0Response_createCustomFieldInBaseGroup <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_createCustomFieldInGroup <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteCustomField <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateCustomField <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Custom Field <code></code>\u00a0CustomField </li> </ul> ATTRIBUTE DESCRIPTION <code>baseCustomFieldGroupId</code> <p>ID of the base custom field group the custom field belongs to</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the custom field was created</p> <p> TYPE: <code>str</code> </p> <code>customFieldGroupId</code> <p>ID of the custom field group the custom field belongs to</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the custom field</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the custom field</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the custom field within the group</p> <p> TYPE: <code>int</code> </p> <code>showOnFrontOfCard</code> <p>Whether to show the field on the front of cards</p> <p> TYPE: <code>bool</code> </p> <code>updatedAt</code> <p>When the custom field was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomField.baseCustomFieldGroupId","title":"baseCustomFieldGroupId  <code>instance-attribute</code>","text":"<pre><code>baseCustomFieldGroupId: str\n</code></pre> <p>ID of the base custom field group the custom field belongs to</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomField.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the custom field was created</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomField.customFieldGroupId","title":"customFieldGroupId  <code>instance-attribute</code>","text":"<pre><code>customFieldGroupId: str\n</code></pre> <p>ID of the custom field group the custom field belongs to</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomField.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the custom field</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomField.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the custom field</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomField.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the custom field within the group</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomField.showOnFrontOfCard","title":"showOnFrontOfCard  <code>instance-attribute</code>","text":"<pre><code>showOnFrontOfCard: bool\n</code></pre> <p>Whether to show the field on the front of cards</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomField.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the custom field was last updated</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomFieldGroup","title":"CustomFieldGroup","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <ul> <li> <code></code>\u00a0Included_duplicateCard <code></code>\u00a0customFieldGroups </li> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0customFieldGroups </li> <li> <code></code>\u00a0Included_getCard <code></code>\u00a0customFieldGroups </li> <li> <code></code>\u00a0Included_getCards <code></code>\u00a0customFieldGroups </li> <li> <code></code>\u00a0Included_getList <code></code>\u00a0customFieldGroups </li> <li> <code></code>\u00a0Response_createBoardCustomFieldGroup <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_createCardCustomFieldGroup <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteCustomFieldGroup <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_getCustomFieldGroup <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateCustomFieldGroup <code></code>\u00a0item </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Custom Field Group <code></code>\u00a0CustomFieldGroup </li> </ul> ATTRIBUTE DESCRIPTION <code>baseCustomFieldGroupId</code> <p>ID of the base custom field group used as a template</p> <p> TYPE: <code>str</code> </p> <code>boardId</code> <p>ID of the board the custom field group belongs to</p> <p> TYPE: <code>str</code> </p> <code>cardId</code> <p>ID of the card the custom field group belongs to</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the custom field group was created</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the custom field group</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the custom field group</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the custom field group within the board/card</p> <p> TYPE: <code>int</code> </p> <code>updatedAt</code> <p>When the custom field group was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomFieldGroup.baseCustomFieldGroupId","title":"baseCustomFieldGroupId  <code>instance-attribute</code>","text":"<pre><code>baseCustomFieldGroupId: str\n</code></pre> <p>ID of the base custom field group used as a template</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomFieldGroup.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: str\n</code></pre> <p>ID of the board the custom field group belongs to</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomFieldGroup.cardId","title":"cardId  <code>instance-attribute</code>","text":"<pre><code>cardId: str\n</code></pre> <p>ID of the card the custom field group belongs to</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomFieldGroup.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the custom field group was created</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomFieldGroup.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the custom field group</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomFieldGroup.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the custom field group</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomFieldGroup.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the custom field group within the board/card</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomFieldGroup.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the custom field group was last updated</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomFieldValue","title":"CustomFieldValue","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <ul> <li> <code></code>\u00a0Included_duplicateCard <code></code>\u00a0customFieldValues </li> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0customFieldValues </li> <li> <code></code>\u00a0Included_getCard <code></code>\u00a0customFieldValues </li> <li> <code></code>\u00a0Included_getCards <code></code>\u00a0customFieldValues </li> <li> <code></code>\u00a0Included_getCustomFieldGroup <code></code>\u00a0customFieldValues </li> <li> <code></code>\u00a0Included_getList <code></code>\u00a0customFieldValues </li> <li> <code></code>\u00a0Response_deleteCustomFieldValue <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateCustomFieldValue <code></code>\u00a0item </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Custom Field Value <code></code>\u00a0CustomFieldValue </li> </ul> ATTRIBUTE DESCRIPTION <code>cardId</code> <p>ID of the card the value belongs to</p> <p> TYPE: <code>str</code> </p> <code>content</code> <p>Content/value of the custom field</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the custom field value was created</p> <p> TYPE: <code>str</code> </p> <code>customFieldGroupId</code> <p>ID of the custom field group the value belongs to</p> <p> TYPE: <code>str</code> </p> <code>customFieldId</code> <p>ID of the custom field the value belongs to</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the custom field value</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the custom field value was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomFieldValue.cardId","title":"cardId  <code>instance-attribute</code>","text":"<pre><code>cardId: str\n</code></pre> <p>ID of the card the value belongs to</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomFieldValue.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: str\n</code></pre> <p>Content/value of the custom field</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomFieldValue.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the custom field value was created</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomFieldValue.customFieldGroupId","title":"customFieldGroupId  <code>instance-attribute</code>","text":"<pre><code>customFieldGroupId: str\n</code></pre> <p>ID of the custom field group the value belongs to</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomFieldValue.customFieldId","title":"customFieldId  <code>instance-attribute</code>","text":"<pre><code>customFieldId: str\n</code></pre> <p>ID of the custom field the value belongs to</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomFieldValue.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the custom field value</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.CustomFieldValue.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the custom field value was last updated</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Label","title":"Label","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0labels </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0labels </li> <li> <code></code>\u00a0Response_createLabel <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteLabel <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateLabel <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Label <code></code>\u00a0Label </li> </ul> ATTRIBUTE DESCRIPTION <code>boardId</code> <p>ID of the board the label belongs to</p> <p> TYPE: <code>str</code> </p> <code>color</code> <p>Color of the label</p> <p> TYPE: <code>Literal['muddy-grey', 'autumn-leafs', 'morning-sky', 'antique-blue', 'egg-yellow', 'desert-sand', 'dark-granite', 'fresh-salad', 'lagoon-blue', 'midnight-blue', 'light-orange', 'pumpkin-orange', 'light-concrete', 'sunny-grass', 'navy-blue', 'lilac-eyes', 'apricot-red', 'orange-peel', 'silver-glint', 'bright-moss', 'deep-ocean', 'summer-sky', 'berry-red', 'light-cocoa', 'grey-stone', 'tank-green', 'coral-green', 'sugar-plum', 'pink-tulip', 'shady-rust', 'wet-rock', 'wet-moss', 'turquoise-sea', 'lavender-fields', 'piggy-red', 'light-mud', 'gun-metal', 'modern-green', 'french-coast', 'sweet-lilac', 'red-burgundy', 'pirate-gold']</code> </p> <code>createdAt</code> <p>When the label was created</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the label</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the label</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the label within the board</p> <p> TYPE: <code>int</code> </p> <code>updatedAt</code> <p>When the label was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Label.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: str\n</code></pre> <p>ID of the board the label belongs to</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Label.color","title":"color  <code>instance-attribute</code>","text":"<pre><code>color: Literal['muddy-grey', 'autumn-leafs', 'morning-sky', 'antique-blue', 'egg-yellow', 'desert-sand', 'dark-granite', 'fresh-salad', 'lagoon-blue', 'midnight-blue', 'light-orange', 'pumpkin-orange', 'light-concrete', 'sunny-grass', 'navy-blue', 'lilac-eyes', 'apricot-red', 'orange-peel', 'silver-glint', 'bright-moss', 'deep-ocean', 'summer-sky', 'berry-red', 'light-cocoa', 'grey-stone', 'tank-green', 'coral-green', 'sugar-plum', 'pink-tulip', 'shady-rust', 'wet-rock', 'wet-moss', 'turquoise-sea', 'lavender-fields', 'piggy-red', 'light-mud', 'gun-metal', 'modern-green', 'french-coast', 'sweet-lilac', 'red-burgundy', 'pirate-gold']\n</code></pre> <p>Color of the label</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Label.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the label was created</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Label.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the label</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Label.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the label</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Label.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the label within the board</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Label.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the label was last updated</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.List","title":"List","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0lists </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0lists </li> <li> <code></code>\u00a0Response_clearList <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_createList <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteList <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_getList <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_moveListCards <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_sortList <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateList <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models List <code></code>\u00a0List </li> </ul> ATTRIBUTE DESCRIPTION <code>boardId</code> <p>ID of the board the list belongs to</p> <p> TYPE: <code>str</code> </p> <code>color</code> <p>Color for the list</p> <p> TYPE: <code>Literal['berry-red', 'pumpkin-orange', 'lagoon-blue', 'pink-tulip', 'light-mud', 'orange-peel', 'bright-moss', 'antique-blue', 'dark-granite', 'turquoise-sea']</code> </p> <code>createdAt</code> <p>When the list was created</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the list</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the list</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the list within the board</p> <p> TYPE: <code>int</code> </p> <code>type</code> <p>Type/status of the list</p> <p> TYPE: <code>Literal['active', 'closed', 'archive', 'trash']</code> </p> <code>updatedAt</code> <p>When the list was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.List.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: str\n</code></pre> <p>ID of the board the list belongs to</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.List.color","title":"color  <code>instance-attribute</code>","text":"<pre><code>color: Literal['berry-red', 'pumpkin-orange', 'lagoon-blue', 'pink-tulip', 'light-mud', 'orange-peel', 'bright-moss', 'antique-blue', 'dark-granite', 'turquoise-sea']\n</code></pre> <p>Color for the list</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.List.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the list was created</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.List.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the list</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.List.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the list</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.List.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the list within the board</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.List.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['active', 'closed', 'archive', 'trash']\n</code></pre> <p>Type/status of the list</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.List.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the list was last updated</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Notification","title":"Notification","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api REST Typing <ul> <li> <code></code>\u00a0Included_readCardNotifications <code></code>\u00a0notifications </li> <li> <code></code>\u00a0Response_getNotification <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_getNotifications <code></code>\u00a0items </li> <li> <code></code>\u00a0Response_readAllNotifications <code></code>\u00a0items </li> <li> <code></code>\u00a0Response_updateNotification <code></code>\u00a0item </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Notification <code></code>\u00a0Notification </li> </ul> ATTRIBUTE DESCRIPTION <code>actionId</code> <p>ID of the action associated with the notification</p> <p> TYPE: <code>str</code> </p> <code>boardId</code> <p>ID of the board associated with the notification (denormalized)</p> <p> TYPE: <code>str</code> </p> <code>cardId</code> <p>ID of the card associated with the notification</p> <p> TYPE: <code>str</code> </p> <code>commentId</code> <p>ID of the comment associated with the notification</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the notification was created</p> <p> TYPE: <code>str</code> </p> <code>creatorUserId</code> <p>ID of the user who created the notification</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>Notification specific data (varies by type)</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>id</code> <p>Unique identifier for the notification</p> <p> TYPE: <code>str</code> </p> <code>isRead</code> <p>Whether the notification has been read</p> <p> TYPE: <code>bool</code> </p> <code>type</code> <p>Type of the notification</p> <p> TYPE: <code>Literal['moveCard', 'commentCard', 'addMemberToCard', 'mentionInComment']</code> </p> <code>updatedAt</code> <p>When the notification was last updated</p> <p> TYPE: <code>str</code> </p> <code>userId</code> <p>ID of the user who receives the notification</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Notification.actionId","title":"actionId  <code>instance-attribute</code>","text":"<pre><code>actionId: str\n</code></pre> <p>ID of the action associated with the notification</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Notification.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: str\n</code></pre> <p>ID of the board associated with the notification (denormalized)</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Notification.cardId","title":"cardId  <code>instance-attribute</code>","text":"<pre><code>cardId: str\n</code></pre> <p>ID of the card associated with the notification</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Notification.commentId","title":"commentId  <code>instance-attribute</code>","text":"<pre><code>commentId: str\n</code></pre> <p>ID of the comment associated with the notification</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Notification.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the notification was created</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Notification.creatorUserId","title":"creatorUserId  <code>instance-attribute</code>","text":"<pre><code>creatorUserId: str\n</code></pre> <p>ID of the user who created the notification</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Notification.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: dict[str, Any]\n</code></pre> <p>Notification specific data (varies by type)</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Notification.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the notification</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Notification.isRead","title":"isRead  <code>instance-attribute</code>","text":"<pre><code>isRead: bool\n</code></pre> <p>Whether the notification has been read</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Notification.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['moveCard', 'commentCard', 'addMemberToCard', 'mentionInComment']\n</code></pre> <p>Type of the notification</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Notification.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the notification was last updated</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Notification.userId","title":"userId  <code>instance-attribute</code>","text":"<pre><code>userId: str\n</code></pre> <p>ID of the user who receives the notification</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.NotificationService","title":"NotificationService","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0notification_services </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_getProject <code></code>\u00a0notificationServices </li> <li> <code></code>\u00a0Included_getProjects <code></code>\u00a0notificationServices </li> <li> <code></code>\u00a0Included_getUser <code></code>\u00a0notificationServices </li> <li> <code></code>\u00a0Response_createBoardNotificationService <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_createUserNotificationService <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteNotificationService <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_testNotificationService <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateNotificationService <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Notification Service <code></code>\u00a0NotificationService </li> </ul> ATTRIBUTE DESCRIPTION <code>boardId</code> <p>ID of the board the service is associated with</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the notification service was created</p> <p> TYPE: <code>str</code> </p> <code>format</code> <p>Format for notification messages</p> <p> TYPE: <code>Literal['text', 'markdown', 'html']</code> </p> <code>id</code> <p>Unique identifier for the notification service</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the notification service was last updated</p> <p> TYPE: <code>str</code> </p> <code>url</code> <p>URL endpoint for notifications</p> <p> TYPE: <code>str</code> </p> <code>userId</code> <p>ID of the user the service is associated with</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.NotificationService.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: str\n</code></pre> <p>ID of the board the service is associated with</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.NotificationService.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the notification service was created</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.NotificationService.format","title":"format  <code>instance-attribute</code>","text":"<pre><code>format: Literal['text', 'markdown', 'html']\n</code></pre> <p>Format for notification messages</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.NotificationService.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the notification service</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.NotificationService.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the notification service was last updated</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.NotificationService.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre> <p>URL endpoint for notifications</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.NotificationService.userId","title":"userId  <code>instance-attribute</code>","text":"<pre><code>userId: str\n</code></pre> <p>ID of the user the service is associated with</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Project","title":"Project","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0projects </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0projects </li> <li> <code></code>\u00a0Response_createProject <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteProject <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateProject <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 <ul> <li> models Project <code></code>\u00a0Project </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Item_getProject </li> <li> <code></code>\u00a0Items_getProjects </li> </ul> </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>backgroundGradient</code> <p>Gradient background for the project</p> <p> TYPE: <code>Literal['old-lime', 'ocean-dive', 'tzepesch-style', 'jungle-mesh', 'strawberry-dust', 'purple-rose', 'sun-scream', 'warm-rust', 'sky-change', 'green-eyes', 'blue-xchange', 'blood-orange', 'sour-peel', 'green-ninja', 'algae-green', 'coral-reef', 'steel-grey', 'heat-waves', 'velvet-lounge', 'purple-rain', 'blue-steel', 'blueish-curve', 'prism-light', 'green-mist', 'red-curtain']</code> </p> <code>backgroundImageId</code> <p>ID of the background image used as background</p> <p> TYPE: <code>str</code> </p> <code>backgroundType</code> <p>Type of background for the project</p> <p> TYPE: <code>Literal['gradient', 'image']</code> </p> <code>createdAt</code> <p>When the project was created</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>Detailed description of the project</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the project</p> <p> TYPE: <code>str</code> </p> <code>isHidden</code> <p>Whether the project is hidden</p> <p> TYPE: <code>bool</code> </p> <code>name</code> <p>Name/title of the project</p> <p> TYPE: <code>str</code> </p> <code>ownerProjectManagerId</code> <p>ID of the project manager who owns the project</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the project was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Project.backgroundGradient","title":"backgroundGradient  <code>instance-attribute</code>","text":"<pre><code>backgroundGradient: Literal['old-lime', 'ocean-dive', 'tzepesch-style', 'jungle-mesh', 'strawberry-dust', 'purple-rose', 'sun-scream', 'warm-rust', 'sky-change', 'green-eyes', 'blue-xchange', 'blood-orange', 'sour-peel', 'green-ninja', 'algae-green', 'coral-reef', 'steel-grey', 'heat-waves', 'velvet-lounge', 'purple-rain', 'blue-steel', 'blueish-curve', 'prism-light', 'green-mist', 'red-curtain']\n</code></pre> <p>Gradient background for the project</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Project.backgroundImageId","title":"backgroundImageId  <code>instance-attribute</code>","text":"<pre><code>backgroundImageId: str\n</code></pre> <p>ID of the background image used as background</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Project.backgroundType","title":"backgroundType  <code>instance-attribute</code>","text":"<pre><code>backgroundType: Literal['gradient', 'image']\n</code></pre> <p>Type of background for the project</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Project.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the project was created</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Project.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str\n</code></pre> <p>Detailed description of the project</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Project.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the project</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Project.isHidden","title":"isHidden  <code>instance-attribute</code>","text":"<pre><code>isHidden: bool\n</code></pre> <p>Whether the project is hidden</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Project.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the project</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Project.ownerProjectManagerId","title":"ownerProjectManagerId  <code>instance-attribute</code>","text":"<pre><code>ownerProjectManagerId: str\n</code></pre> <p>ID of the project manager who owns the project</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Project.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the project was last updated</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.ProjectManager","title":"ProjectManager","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0project_managers </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_createProject <code></code>\u00a0projectManagers </li> <li> <code></code>\u00a0Included_getProject <code></code>\u00a0projectManagers </li> <li> <code></code>\u00a0Included_getProjects <code></code>\u00a0projectManagers </li> <li> <code></code>\u00a0Response_createProjectManager <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteProjectManager <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Project Manager <code></code>\u00a0ProjectManager </li> </ul> ATTRIBUTE DESCRIPTION <code>createdAt</code> <p>When the project manager was created</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the project manager</p> <p> TYPE: <code>str</code> </p> <code>projectId</code> <p>ID of the project the manager is associated with</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the project manager was last updated</p> <p> TYPE: <code>str</code> </p> <code>userId</code> <p>ID of the user who is assigned as project manager</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.ProjectManager.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the project manager was created</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.ProjectManager.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the project manager</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.ProjectManager.projectId","title":"projectId  <code>instance-attribute</code>","text":"<pre><code>projectId: str\n</code></pre> <p>ID of the project the manager is associated with</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.ProjectManager.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the project manager was last updated</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.ProjectManager.userId","title":"userId  <code>instance-attribute</code>","text":"<pre><code>userId: str\n</code></pre> <p>ID of the user who is assigned as project manager</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Stopwatch","title":"Stopwatch","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 api <ul> <li> REST Typing <ul> <li> <code></code>\u00a0Card <code></code>\u00a0stopwatch </li> <li> <code></code>\u00a0Included_getBoard_all <code></code>\u00a0stopwatch </li> <li> <code></code>\u00a0Included_getList_all <code></code>\u00a0stopwatch </li> <li> <code></code>\u00a0Item_getCard <code></code>\u00a0stopwatch </li> <li> <code></code>\u00a0Items_getCards <code></code>\u00a0stopwatch </li> <li> <code></code>\u00a0Request_updateCard <code></code>\u00a0stopwatch </li> </ul> </li> <li> Schemas <code></code>\u00a0Card <code></code>\u00a0stopwatch </li> </ul> </li> </ul> ATTRIBUTE DESCRIPTION <code>startedAt</code> <p>The time that a running stopwatch was started</p> <p> TYPE: <code>str | None</code> </p> <code>total</code> <p>The number of seconds that the stopwatch has been running</p> <p> TYPE: <code>int</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Stopwatch.startedAt","title":"startedAt  <code>instance-attribute</code>","text":"<pre><code>startedAt: str | None\n</code></pre> <p>The time that a running stopwatch was started</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Stopwatch.total","title":"total  <code>instance-attribute</code>","text":"<pre><code>total: int\n</code></pre> <p>The number of seconds that the stopwatch has been running</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Task","title":"Task","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0tasks </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_duplicateCard <code></code>\u00a0tasks </li> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0tasks </li> <li> <code></code>\u00a0Included_getCard <code></code>\u00a0tasks </li> <li> <code></code>\u00a0Included_getCards <code></code>\u00a0tasks </li> <li> <code></code>\u00a0Included_getList <code></code>\u00a0tasks </li> <li> <code></code>\u00a0Included_getTaskList <code></code>\u00a0tasks </li> <li> <code></code>\u00a0Response_createTask <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteTask <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateTask <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Task <code></code>\u00a0Task </li> </ul> ATTRIBUTE DESCRIPTION <code>assigneeUserId</code> <p>ID of the user assigned to the task</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the task was created</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>Unique identifier for the task</p> <p> TYPE: <code>str</code> </p> <code>isCompleted</code> <p>Whether the task is completed</p> <p> TYPE: <code>bool</code> </p> <code>linkedCardId</code> <p>ID of the card linked to the task</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the task</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the task within the task list</p> <p> TYPE: <code>int</code> </p> <code>taskListId</code> <p>ID of the task list the task belongs to</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the task was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Task.assigneeUserId","title":"assigneeUserId  <code>instance-attribute</code>","text":"<pre><code>assigneeUserId: str\n</code></pre> <p>ID of the user assigned to the task</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Task.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the task was created</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Task.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the task</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Task.isCompleted","title":"isCompleted  <code>instance-attribute</code>","text":"<pre><code>isCompleted: bool\n</code></pre> <p>Whether the task is completed</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Task.linkedCardId","title":"linkedCardId  <code>instance-attribute</code>","text":"<pre><code>linkedCardId: str\n</code></pre> <p>ID of the card linked to the task</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Task.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the task</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Task.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the task within the task list</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Task.taskListId","title":"taskListId  <code>instance-attribute</code>","text":"<pre><code>taskListId: str\n</code></pre> <p>ID of the task list the task belongs to</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Task.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the task was last updated</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.TaskList","title":"TaskList","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0task_lists </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_duplicateCard <code></code>\u00a0taskLists </li> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0taskLists </li> <li> <code></code>\u00a0Included_getCard <code></code>\u00a0taskLists </li> <li> <code></code>\u00a0Included_getCards <code></code>\u00a0taskLists </li> <li> <code></code>\u00a0Included_getList <code></code>\u00a0taskLists </li> <li> <code></code>\u00a0Response_createTaskList <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteTaskList <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_getTaskList <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateTaskList <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Task List <code></code>\u00a0TaskList </li> </ul> ATTRIBUTE DESCRIPTION <code>cardId</code> <p>ID of the card the task list belongs to</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the task list was created</p> <p> TYPE: <code>str</code> </p> <code>hideCompletedTasks</code> <p>Whether to hide completed tasks</p> <p> TYPE: <code>bool</code> </p> <code>id</code> <p>Unique identifier for the task list</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the task list</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the task list within the card</p> <p> TYPE: <code>int</code> </p> <code>showOnFrontOfCard</code> <p>Whether to show the task list on the front of the card</p> <p> TYPE: <code>bool</code> </p> <code>updatedAt</code> <p>When the task list was last updated</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.TaskList.cardId","title":"cardId  <code>instance-attribute</code>","text":"<pre><code>cardId: str\n</code></pre> <p>ID of the card the task list belongs to</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.TaskList.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the task list was created</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.TaskList.hideCompletedTasks","title":"hideCompletedTasks  <code>instance-attribute</code>","text":"<pre><code>hideCompletedTasks: bool\n</code></pre> <p>Whether to hide completed tasks</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.TaskList.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the task list</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.TaskList.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the task list</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.TaskList.position","title":"position  <code>instance-attribute</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the task list within the card</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.TaskList.showOnFrontOfCard","title":"showOnFrontOfCard  <code>instance-attribute</code>","text":"<pre><code>showOnFrontOfCard: bool\n</code></pre> <p>Whether to show the task list on the front of the card</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.TaskList.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the task list was last updated</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User","title":"User","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0users </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Included_getBoard <code></code>\u00a0users </li> <li> <code></code>\u00a0Included_getBoardActions <code></code>\u00a0users </li> <li> <code></code>\u00a0Included_getCard <code></code>\u00a0users </li> <li> <code></code>\u00a0Included_getCardActions <code></code>\u00a0users </li> <li> <code></code>\u00a0Included_getCards <code></code>\u00a0users </li> <li> <code></code>\u00a0Included_getComments <code></code>\u00a0users </li> <li> <code></code>\u00a0Included_getList <code></code>\u00a0users </li> <li> <code></code>\u00a0Included_getNotification <code></code>\u00a0users </li> <li> <code></code>\u00a0Included_getNotifications <code></code>\u00a0users </li> <li> <code></code>\u00a0Included_getProject <code></code>\u00a0users </li> <li> <code></code>\u00a0Included_getProjects <code></code>\u00a0users </li> <li> <code></code>\u00a0Response_createUser <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteUser <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_getUser <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_getUsers <code></code>\u00a0items </li> <li> <code></code>\u00a0Response_updateUser <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateUserAvatar <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateUserEmail <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateUserPassword <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_updateUserUsername <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models User <code></code>\u00a0User </li> </ul> ATTRIBUTE DESCRIPTION <code>apiKeyPrefix</code> <p>The prefix for the user's API key if one is active</p> <p> TYPE: <code>str | None</code> </p> <code>avatar</code> <p>Avatar information for the user with generated URLs</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>createdAt</code> <p>When the user was created</p> <p> TYPE: <code>str</code> </p> <code>defaultEditorMode</code> <p>Default markdown editor mode (personal field)</p> <p> TYPE: <code>NotRequired[Literal['wysiwyg', 'markup']]</code> </p> <code>defaultHomeView</code> <p>Default view mode for the home page (personal field)</p> <p> TYPE: <code>NotRequired[Literal['gridProjects', 'groupedProjects']]</code> </p> <code>defaultProjectsOrder</code> <p>Default sort order for projects display (personal field)</p> <p> TYPE: <code>NotRequired[Literal['byDefault', 'alphabetically', 'byCreationTime']]</code> </p> <code>email</code> <p>Email address for login and notifications (private field)</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>enableFavoritesByDefault</code> <p>Whether favorites are enabled by default (personal field)</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>gravatarUrl</code> <p>Gravatar URL for the user (conditionally added if configured)</p> <p> TYPE: <code>NotRequired[str]</code> </p> <code>id</code> <p>Unique identifier for the user</p> <p> TYPE: <code>str</code> </p> <code>isDeactivated</code> <p>Whether the user account is deactivated and cannot log in</p> <p> TYPE: <code>bool</code> </p> <code>isDefaultAdmin</code> <p>Whether the user is the default admin (visible only to current user or admin)</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>isSsoUser</code> <p>Whether the user is SSO user (private field)</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>language</code> <p>Preferred language for user interface and notifications (personal field)</p> <p> TYPE: <code>NotRequired[Literal['ar-YE', 'bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-GB', 'en-US', 'es-ES', 'et-EE', 'fa-IR', 'fi-FI', 'fr-FR', 'hu-HU', 'id-ID', 'it-IT', 'ja-JP', 'ko-KR', 'nl-NL', 'pl-PL', 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sk-SK', 'sr-Cyrl-RS', 'sr-Latn-RS', 'sv-SE', 'tr-TR', 'uk-UA', 'uz-UZ', 'zh-CN', 'zh-TW']]</code> </p> <code>lockedFieldNames</code> <p>List of fields locked from editing (visible only to current user or admin)</p> <p> TYPE: <code>NotRequired[list[Literal['email', 'password', 'name']]]</code> </p> <code>name</code> <p>Full display name of the user</p> <p> TYPE: <code>str</code> </p> <code>organization</code> <p>Organization or company name</p> <p> TYPE: <code>str</code> </p> <code>phone</code> <p>Contact phone number</p> <p> TYPE: <code>str</code> </p> <code>role</code> <p>User role defining access permissions</p> <p> TYPE: <code>Literal['admin', 'projectOwner', 'boardUser']</code> </p> <code>subscribeToCardWhenCommenting</code> <p>Whether the user subscribes to cards when commenting (personal field)</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>subscribeToOwnCards</code> <p>Whether the user subscribes to their own cards (personal field)</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>termsType</code> <p>Type of terms applicable to the user based on role</p> <p> TYPE: <code>Literal['general', 'extended']</code> </p> <code>turnOffRecentCardHighlighting</code> <p>Whether recent card highlighting is disabled (personal field)</p> <p> TYPE: <code>NotRequired[bool]</code> </p> <code>updatedAt</code> <p>When the user was last updated</p> <p> TYPE: <code>str</code> </p> <code>username</code> <p>Unique username for user identification</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.apiKeyPrefix","title":"apiKeyPrefix  <code>instance-attribute</code>","text":"<pre><code>apiKeyPrefix: str | None\n</code></pre> <p>The prefix for the user's API key if one is active</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.avatar","title":"avatar  <code>instance-attribute</code>","text":"<pre><code>avatar: dict[str, Any]\n</code></pre> <p>Avatar information for the user with generated URLs</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the user was created</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.defaultEditorMode","title":"defaultEditorMode  <code>instance-attribute</code>","text":"<pre><code>defaultEditorMode: NotRequired[Literal['wysiwyg', 'markup']]\n</code></pre> <p>Default markdown editor mode (personal field)</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.defaultHomeView","title":"defaultHomeView  <code>instance-attribute</code>","text":"<pre><code>defaultHomeView: NotRequired[Literal['gridProjects', 'groupedProjects']]\n</code></pre> <p>Default view mode for the home page (personal field)</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.defaultProjectsOrder","title":"defaultProjectsOrder  <code>instance-attribute</code>","text":"<pre><code>defaultProjectsOrder: NotRequired[Literal['byDefault', 'alphabetically', 'byCreationTime']]\n</code></pre> <p>Default sort order for projects display (personal field)</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.email","title":"email  <code>instance-attribute</code>","text":"<pre><code>email: NotRequired[str]\n</code></pre> <p>Email address for login and notifications (private field)</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.enableFavoritesByDefault","title":"enableFavoritesByDefault  <code>instance-attribute</code>","text":"<pre><code>enableFavoritesByDefault: NotRequired[bool]\n</code></pre> <p>Whether favorites are enabled by default (personal field)</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.gravatarUrl","title":"gravatarUrl  <code>instance-attribute</code>","text":"<pre><code>gravatarUrl: NotRequired[str]\n</code></pre> <p>Gravatar URL for the user (conditionally added if configured)</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the user</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.isDeactivated","title":"isDeactivated  <code>instance-attribute</code>","text":"<pre><code>isDeactivated: bool\n</code></pre> <p>Whether the user account is deactivated and cannot log in</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.isDefaultAdmin","title":"isDefaultAdmin  <code>instance-attribute</code>","text":"<pre><code>isDefaultAdmin: NotRequired[bool]\n</code></pre> <p>Whether the user is the default admin (visible only to current user or admin)</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.isSsoUser","title":"isSsoUser  <code>instance-attribute</code>","text":"<pre><code>isSsoUser: NotRequired[bool]\n</code></pre> <p>Whether the user is SSO user (private field)</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.language","title":"language  <code>instance-attribute</code>","text":"<pre><code>language: NotRequired[Literal['ar-YE', 'bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-GB', 'en-US', 'es-ES', 'et-EE', 'fa-IR', 'fi-FI', 'fr-FR', 'hu-HU', 'id-ID', 'it-IT', 'ja-JP', 'ko-KR', 'nl-NL', 'pl-PL', 'pt-BR', 'pt-PT', 'ro-RO', 'ru-RU', 'sk-SK', 'sr-Cyrl-RS', 'sr-Latn-RS', 'sv-SE', 'tr-TR', 'uk-UA', 'uz-UZ', 'zh-CN', 'zh-TW']]\n</code></pre> <p>Preferred language for user interface and notifications (personal field)</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.lockedFieldNames","title":"lockedFieldNames  <code>instance-attribute</code>","text":"<pre><code>lockedFieldNames: NotRequired[list[Literal['email', 'password', 'name']]]\n</code></pre> <p>List of fields locked from editing (visible only to current user or admin)</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Full display name of the user</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.organization","title":"organization  <code>instance-attribute</code>","text":"<pre><code>organization: str\n</code></pre> <p>Organization or company name</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.phone","title":"phone  <code>instance-attribute</code>","text":"<pre><code>phone: str\n</code></pre> <p>Contact phone number</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.role","title":"role  <code>instance-attribute</code>","text":"<pre><code>role: Literal['admin', 'projectOwner', 'boardUser']\n</code></pre> <p>User role defining access permissions</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.subscribeToCardWhenCommenting","title":"subscribeToCardWhenCommenting  <code>instance-attribute</code>","text":"<pre><code>subscribeToCardWhenCommenting: NotRequired[bool]\n</code></pre> <p>Whether the user subscribes to cards when commenting (personal field)</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.subscribeToOwnCards","title":"subscribeToOwnCards  <code>instance-attribute</code>","text":"<pre><code>subscribeToOwnCards: NotRequired[bool]\n</code></pre> <p>Whether the user subscribes to their own cards (personal field)</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.termsType","title":"termsType  <code>instance-attribute</code>","text":"<pre><code>termsType: Literal['general', 'extended']\n</code></pre> <p>Type of terms applicable to the user based on role</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.turnOffRecentCardHighlighting","title":"turnOffRecentCardHighlighting  <code>instance-attribute</code>","text":"<pre><code>turnOffRecentCardHighlighting: NotRequired[bool]\n</code></pre> <p>Whether recent card highlighting is disabled (personal field)</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the user was last updated</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.User.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username: str\n</code></pre> <p>Unique username for user identification</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Webhook","title":"Webhook","text":"<p>               Bases: <code>TypedDict</code></p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0webhooks </li> <li> api REST Typing <ul> <li> <code></code>\u00a0Response_createWebhook <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_deleteWebhook <code></code>\u00a0item </li> <li> <code></code>\u00a0Response_getWebhooks <code></code>\u00a0items </li> <li> <code></code>\u00a0Response_updateWebhook <code></code>\u00a0item </li> </ul> </li> </ul> </li> </ul> Subclassed by: <ul> <li> Plankapy v2 models Webhook <code></code>\u00a0Webhook </li> </ul> ATTRIBUTE DESCRIPTION <code>accessToken</code> <p>Access token for webhook authentication</p> <p> TYPE: <code>str</code> </p> <code>boardId</code> <p>The board that the webhook is associated with</p> <p> TYPE: <code>str</code> </p> <code>createdAt</code> <p>When the webhook was created</p> <p> TYPE: <code>str</code> </p> <code>events</code> <p>List of events that trigger the webhook</p> <p> TYPE: <code>list[WebhookEvent]</code> </p> <code>excludedEvents</code> <p>List of events excluded from the webhook</p> <p> TYPE: <code>list[WebhookEvent]</code> </p> <code>id</code> <p>Unique identifier for the webhook</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name/title of the webhook</p> <p> TYPE: <code>str</code> </p> <code>updatedAt</code> <p>When the webhook was last updated</p> <p> TYPE: <code>str</code> </p> <code>url</code> <p>URL endpoint for the webhook</p> <p> TYPE: <code>str</code> </p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Webhook.accessToken","title":"accessToken  <code>instance-attribute</code>","text":"<pre><code>accessToken: str\n</code></pre> <p>Access token for webhook authentication</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Webhook.boardId","title":"boardId  <code>instance-attribute</code>","text":"<pre><code>boardId: str\n</code></pre> <p>The board that the webhook is associated with</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Webhook.createdAt","title":"createdAt  <code>instance-attribute</code>","text":"<pre><code>createdAt: str\n</code></pre> <p>When the webhook was created</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Webhook.events","title":"events  <code>instance-attribute</code>","text":"<pre><code>events: list[WebhookEvent]\n</code></pre> <p>List of events that trigger the webhook</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Webhook.excludedEvents","title":"excludedEvents  <code>instance-attribute</code>","text":"<pre><code>excludedEvents: list[WebhookEvent]\n</code></pre> <p>List of events excluded from the webhook</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Webhook.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for the webhook</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Webhook.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the webhook</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Webhook.updatedAt","title":"updatedAt  <code>instance-attribute</code>","text":"<pre><code>updatedAt: str\n</code></pre> <p>When the webhook was last updated</p>"},{"location":"v2/api/schemas/#plankapy.v2.api.schemas.Webhook.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre> <p>URL endpoint for the webhook</p>"},{"location":"v2/models/_planka-model/","title":"Planka Base Model","text":"CLASS DESCRIPTION <code>PlankaModel</code> <p>Base Planka object interface</p>"},{"location":"v2/models/_planka-model/#plankapy.v2.models._base.PlankaModel","title":"PlankaModel","text":"<pre><code>PlankaModel(schema: Schema, session: Planka)\n</code></pre> <p>Base Planka object interface</p> Subclassed by: <ul> <li> Plankapy v2 models <ul> <li> Action <code></code>\u00a0Action </li> <li> Attachment <code></code>\u00a0Attachment </li> <li> Background Image <code></code>\u00a0BackgroundImage </li> <li> Base Custom Field Group <code></code>\u00a0BaseCustomFieldGroup </li> <li> Board <code></code>\u00a0Board </li> <li> Board Membership <code></code>\u00a0BoardMembership </li> <li> Card <code></code>\u00a0Card </li> <li> Card Label <code></code>\u00a0CardLabel </li> <li> Card Membership <code></code>\u00a0CardMembership </li> <li> Comment <code></code>\u00a0Comment </li> <li> Config <code></code>\u00a0Config </li> <li> Custom Field <code></code>\u00a0CustomField </li> <li> Custom Field Group <code></code>\u00a0CustomFieldGroup </li> <li> Custom Field Value <code></code>\u00a0CustomFieldValue </li> <li> Label <code></code>\u00a0Label </li> <li> List <code></code>\u00a0List </li> <li> Notification <code></code>\u00a0Notification </li> <li> Notification Service <code></code>\u00a0NotificationService </li> <li> Project <code></code>\u00a0Project </li> <li> Project Manager <code></code>\u00a0ProjectManager </li> <li> Task <code></code>\u00a0Task </li> <li> Task List <code></code>\u00a0TaskList </li> <li> User <code></code>\u00a0User </li> <li> Webhook <code></code>\u00a0Webhook </li> </ul> </li> </ul> Used by: <ul> <li> Plankapy v2 models <ul> <li> Action <code></code>\u00a0Action <code></code>\u00a0diff </li> <li> Attachment <code></code>\u00a0Attachment <code></code>\u00a0diff </li> <li> Background Image <code></code>\u00a0BackgroundImage <code></code>\u00a0diff </li> <li> Base Custom Field Group <code></code>\u00a0BaseCustomFieldGroup <code></code>\u00a0diff </li> <li> Board <code></code>\u00a0Board <code></code>\u00a0diff </li> <li> Board Membership <code></code>\u00a0BoardMembership <code></code>\u00a0diff </li> <li> Card <code></code>\u00a0Card <code></code>\u00a0diff </li> <li> Card Label <code></code>\u00a0CardLabel <code></code>\u00a0diff </li> <li> Card Membership <code></code>\u00a0CardMembership <code></code>\u00a0diff </li> <li> Comment <code></code>\u00a0Comment <code></code>\u00a0diff </li> <li> Config <code></code>\u00a0Config <code></code>\u00a0diff </li> <li> Custom Field <code></code>\u00a0CustomField <code></code>\u00a0diff </li> <li> Custom Field Group <code></code>\u00a0CustomFieldGroup <code></code>\u00a0diff </li> <li> Custom Field Value <code></code>\u00a0CustomFieldValue <code></code>\u00a0diff </li> <li> Label <code></code>\u00a0Label <code></code>\u00a0diff </li> <li> List <code></code>\u00a0List <code></code>\u00a0diff </li> <li> Notification <code></code>\u00a0Notification <code></code>\u00a0diff </li> <li> Notification Service <code></code>\u00a0NotificationService <code></code>\u00a0diff </li> <li> Planka Base Model <code></code>\u00a0PlankaModel <code></code>\u00a0diff </li> <li> Project <code></code>\u00a0Project <code></code>\u00a0diff </li> <li> Project Manager <code></code>\u00a0ProjectManager <code></code>\u00a0diff </li> <li> Task <code></code>\u00a0Task <code></code>\u00a0diff </li> <li> Task List <code></code>\u00a0TaskList <code></code>\u00a0diff </li> <li> User <code></code>\u00a0User <code></code>\u00a0diff </li> <li> Webhook <code></code>\u00a0Webhook <code></code>\u00a0diff </li> </ul> </li> </ul> METHOD DESCRIPTION <code>__eq__</code> <code>__getitem__</code> <code>__hash__</code> <code>__repr__</code> <code>__setitem__</code> <code>__str__</code> <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> <code>json</code> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>client</code> <p> </p> <code>current_id</code> <p> </p> <code>current_role</code> <p> </p> <code>endpoints</code> <p> </p> <code>id</code> <p> TYPE: <code>str</code> </p> <code>schema</code> <p> TYPE: <code>Schema</code> </p> <code>session</code> <p> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/_planka-model/#plankapy.v2.models._base.PlankaModel.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/_planka-model/#plankapy.v2.models._base.PlankaModel.client","title":"client  <code>instance-attribute</code>","text":"<pre><code>client = client\n</code></pre>"},{"location":"v2/models/_planka-model/#plankapy.v2.models._base.PlankaModel.current_id","title":"current_id  <code>instance-attribute</code>","text":"<pre><code>current_id = current_id\n</code></pre>"},{"location":"v2/models/_planka-model/#plankapy.v2.models._base.PlankaModel.current_role","title":"current_role  <code>instance-attribute</code>","text":"<pre><code>current_role = current_role\n</code></pre>"},{"location":"v2/models/_planka-model/#plankapy.v2.models._base.PlankaModel.endpoints","title":"endpoints  <code>instance-attribute</code>","text":"<pre><code>endpoints = endpoints\n</code></pre>"},{"location":"v2/models/_planka-model/#plankapy.v2.models._base.PlankaModel.id","title":"id  <code>property</code>","text":"<pre><code>id: str\n</code></pre>"},{"location":"v2/models/_planka-model/#plankapy.v2.models._base.PlankaModel.schema","title":"schema  <code>property</code> <code>writable</code>","text":"<pre><code>schema: Schema\n</code></pre>"},{"location":"v2/models/_planka-model/#plankapy.v2.models._base.PlankaModel.session","title":"session  <code>instance-attribute</code>","text":"<pre><code>session = session\n</code></pre>"},{"location":"v2/models/_planka-model/#plankapy.v2.models._base.PlankaModel.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    if isinstance(other, PlankaModel):\n        try:\n            return (\n                self.id == other.id \n                and self.__class__ == other.__class__ # type: ignore\n            )\n        except AttributeError: # handle no id case (Config)\n            return False\n    else:\n        return super().__eq__(other)\n</code></pre>"},{"location":"v2/models/_planka-model/#plankapy.v2.models._base.PlankaModel.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str) -&gt; Any\n</code></pre> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __getitem__(self, key: str) -&gt; Any:\n    # Allow direct access to model schema cache\n    return self.schema[key]\n</code></pre>"},{"location":"v2/models/_planka-model/#plankapy.v2.models._base.PlankaModel.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __hash__(self) -&gt; int:\n    if 'id' not in self.schema:\n        raise AttributeError(f'{self.__class__.__name__} does not have a hashable id attribute')\n    return int(self.id)\n</code></pre>"},{"location":"v2/models/_planka-model/#plankapy.v2.models._base.PlankaModel.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'{self.__class__.__name__}({self.schema})'          \n</code></pre>"},{"location":"v2/models/_planka-model/#plankapy.v2.models._base.PlankaModel.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(key: Any, val: Any) -&gt; Any\n</code></pre> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __setitem__(self, key: Any, val: Any) -&gt; Any:\n    # Don't allow writes to the cached values\n    raise TypeError(\n        f'Model attributes are read only. '\n        'To update use associated property'\n    )\n</code></pre>"},{"location":"v2/models/_planka-model/#plankapy.v2.models._base.PlankaModel.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__class__.__formatter__(self)\n</code></pre>"},{"location":"v2/models/_planka-model/#plankapy.v2.models._base.PlankaModel.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/_planka-model/#plankapy.v2.models._base.PlankaModel.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/_planka-model/#plankapy.v2.models._base.PlankaModel.json","title":"json","text":"<pre><code>json(**kwargs: Any) -&gt; str\n</code></pre> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def json(self, **kwargs: Any) -&gt; str:\n    return json.dumps(self.schema, **kwargs)\n</code></pre>"},{"location":"v2/models/action/","title":"Action","text":"CLASS DESCRIPTION <code>Action</code> <p>Python interface for Planka Actions</p>"},{"location":"v2/models/action/#plankapy.v2.models.action.Action","title":"Action","text":"<pre><code>Action(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[Action]</code></p> <p>Python interface for Planka Actions</p> Returned by: <ul> <li> Plankapy v2 models <ul> <li> Card <code></code>\u00a0Card <code></code>\u00a0actions </li> <li> Notification <code></code>\u00a0Notification <code></code>\u00a0action </li> </ul> </li> </ul> METHOD DESCRIPTION <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>board</code> <p>The Board where the Action occurred</p> <p> TYPE: <code>Board</code> </p> <code>card</code> <p>The Card where the Action occurred</p> <p> TYPE: <code>Card</code> </p> <code>created_at</code> <p>When the Action was created</p> <p> TYPE: <code>datetime</code> </p> <code>data</code> <p>The specific data associated with the Action (type dependant)</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>type</code> <p>The type of the Action</p> <p> </p> <code>updated_at</code> <p>When the Action was last updated</p> <p> TYPE: <code>datetime</code> </p> <code>user</code> <p>The User who performed the Action (Raise LookupError if User is not found in Board)</p> <p> TYPE: <code>User</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/action/#plankapy.v2.models.action.Action.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/action/#plankapy.v2.models.action.Action.board","title":"board  <code>property</code>","text":"<pre><code>board: Board\n</code></pre> <p>The Board where the Action occurred</p>"},{"location":"v2/models/action/#plankapy.v2.models.action.Action.card","title":"card  <code>property</code>","text":"<pre><code>card: Card\n</code></pre> <p>The Card where the Action occurred</p>"},{"location":"v2/models/action/#plankapy.v2.models.action.Action.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>When the Action was created</p>"},{"location":"v2/models/action/#plankapy.v2.models.action.Action.data","title":"data  <code>property</code>","text":"<pre><code>data: dict[str, Any]\n</code></pre> <p>The specific data associated with the Action (type dependant)</p>"},{"location":"v2/models/action/#plankapy.v2.models.action.Action.type","title":"type  <code>property</code>","text":"<pre><code>type\n</code></pre> <p>The type of the Action</p>"},{"location":"v2/models/action/#plankapy.v2.models.action.Action.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>When the Action was last updated</p>"},{"location":"v2/models/action/#plankapy.v2.models.action.Action.user","title":"user  <code>property</code>","text":"<pre><code>user: User\n</code></pre> <p>The User who performed the Action (Raise LookupError if User is not found in Board)</p>"},{"location":"v2/models/action/#plankapy.v2.models.action.Action.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/action/#plankapy.v2.models.action.Action.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/attachment/","title":"Attachment","text":"CLASS DESCRIPTION <code>Attachment</code> <p>Python interface for Planka Attachments</p>"},{"location":"v2/models/attachment/#plankapy.v2.models.attachment.Attachment","title":"Attachment","text":"<pre><code>Attachment(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[Attachment]</code></p> <p>Python interface for Planka Attachments</p> Returned by: <ul> <li> Plankapy v2 models <ul> <li> Board <code></code>\u00a0Board <code></code>\u00a0attachments </li> <li> Card <code></code>\u00a0Card <ul> <li> <code></code>\u00a0attachments </li> <li> <code></code>\u00a0cover </li> <li> <code></code>\u00a0add_attachment </li> </ul> </li> <li> List <code></code>\u00a0List <code></code>\u00a0attachments </li> </ul> </li> </ul> METHOD DESCRIPTION <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>delete</code> <p>Delete the Attachment</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> <code>download</code> <p>Get a byte Iterator for stream downloading</p> <code>sync</code> <p>Pull the latest state of the Attachment from the Planka Server</p> <code>update</code> <p>Update the Attachment with the provided values</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>card</code> <p>The Card the Attachment belongs to</p> <p> TYPE: <code>Card</code> </p> <code>created_at</code> <p>When the Attachment was created</p> <p> TYPE: <code>datetime</code> </p> <code>creator</code> <p>The User created the Attachment (Raises LookupError if User is not found in Board)</p> <p> TYPE: <code>User</code> </p> <code>data</code> <p>The specific data associated with the action (type dependant)</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>name</code> <p>The name of the Attachment</p> <p> TYPE: <code>str</code> </p> <code>type</code> <p>The type of the action</p> <p> </p> <code>updated_at</code> <p>When the Attachment was last updated</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/attachment/#plankapy.v2.models.attachment.Attachment.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/attachment/#plankapy.v2.models.attachment.Attachment.card","title":"card  <code>property</code>","text":"<pre><code>card: Card\n</code></pre> <p>The Card the Attachment belongs to</p>"},{"location":"v2/models/attachment/#plankapy.v2.models.attachment.Attachment.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>When the Attachment was created</p>"},{"location":"v2/models/attachment/#plankapy.v2.models.attachment.Attachment.creator","title":"creator  <code>property</code>","text":"<pre><code>creator: User\n</code></pre> <p>The User created the Attachment (Raises LookupError if User is not found in Board)</p>"},{"location":"v2/models/attachment/#plankapy.v2.models.attachment.Attachment.data","title":"data  <code>property</code>","text":"<pre><code>data: dict[str, Any]\n</code></pre> <p>The specific data associated with the action (type dependant)</p>"},{"location":"v2/models/attachment/#plankapy.v2.models.attachment.Attachment.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the Attachment</p>"},{"location":"v2/models/attachment/#plankapy.v2.models.attachment.Attachment.type","title":"type  <code>property</code>","text":"<pre><code>type\n</code></pre> <p>The type of the action</p>"},{"location":"v2/models/attachment/#plankapy.v2.models.attachment.Attachment.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>When the Attachment was last updated</p>"},{"location":"v2/models/attachment/#plankapy.v2.models.attachment.Attachment.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/attachment/#plankapy.v2.models.attachment.Attachment.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the Attachment</p> Source code in <code>src/plankapy/v2/models/attachment.py</code> <pre><code>def delete(self):\n    \"\"\"Delete the Attachment\"\"\"\n    return self.endpoints.deleteAttachment(self.id)\n</code></pre>"},{"location":"v2/models/attachment/#plankapy.v2.models.attachment.Attachment.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/attachment/#plankapy.v2.models.attachment.Attachment.download","title":"download","text":"<pre><code>download() -&gt; Iterator[bytes]\n</code></pre> <p>Get a byte Iterator for stream downloading</p> Source code in <code>src/plankapy/v2/models/attachment.py</code> <pre><code>def download(self) -&gt; Iterator[bytes]:\n    \"\"\"Get a byte Iterator for stream downloading\"\"\"\n    return self.client.get(self.schema['data']['url']).iter_bytes()\n</code></pre>"},{"location":"v2/models/attachment/#plankapy.v2.models.attachment.Attachment.sync","title":"sync","text":"<pre><code>sync() -&gt; None\n</code></pre> <p>Pull the latest state of the Attachment from the Planka Server</p> Source code in <code>src/plankapy/v2/models/attachment.py</code> <pre><code>def sync(self) -&gt; None:\n    \"\"\"Pull the latest state of the Attachment from the Planka Server\"\"\"\n    # No endpoint for attachments, need to get it through the associated Card\n    _new = [a for a in self.card.attachments if a.id == self.id]\n    if not _new:\n        self.schema = _new.pop().schema\n</code></pre>"},{"location":"v2/models/attachment/#plankapy.v2.models.attachment.Attachment.update","title":"update","text":"<pre><code>update(**kwargs: Unpack[Request_updateAttachment]) -&gt; None\n</code></pre> <p>Update the Attachment with the provided values</p> Source code in <code>src/plankapy/v2/models/attachment.py</code> <pre><code>def update(self, **kwargs: Unpack[paths.Request_updateAttachment]) -&gt; None:\n    \"\"\"Update the Attachment with the provided values\"\"\"\n    self.schema = self.endpoints.updateAttachment(self.id, **kwargs)['item']\n</code></pre>"},{"location":"v2/models/background-image/","title":"Background Image","text":"CLASS DESCRIPTION <code>BackgroundImage</code> <p>Python interface for Planka Background Images</p>"},{"location":"v2/models/background-image/#plankapy.v2.models.background_image.BackgroundImage","title":"BackgroundImage","text":"<pre><code>BackgroundImage(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[BackgroundImage]</code></p> <p>Python interface for Planka Background Images</p> Returned by: <ul> <li> Plankapy v2 models Project <code></code>\u00a0Project <ul> <li> <code></code>\u00a0background_image </li> <li> <code></code>\u00a0background_images </li> <li> <code></code>\u00a0update_background_image </li> </ul> </li> </ul> Used by: <ul> <li> Plankapy v2 models Project <code></code>\u00a0Project <code></code>\u00a0update_background_image </li> </ul> METHOD DESCRIPTION <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>delete</code> <p>Delete the BackgroundImage</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> <code>download</code> <p>Get bytes for the full image</p> <code>download_thumbnails</code> <p>Get byte iterators for all thumbnails</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>created_at</code> <p>When the BackgroundImage was created</p> <p> TYPE: <code>datetime</code> </p> <code>project</code> <p>The Project the BackgroundImage belongs to</p> <p> TYPE: <code>Project</code> </p> <code>size</code> <p>The size of the BackgroundImage in bytes</p> <p> TYPE: <code>int</code> </p> <code>thumbnails</code> <p>URLs for different thumbnail sizes of the background image</p> <p> TYPE: <code>dict[str, str]</code> </p> <code>updated_at</code> <p>When the BackgroundImage was last updated</p> <p> TYPE: <code>datetime</code> </p> <code>url</code> <p>The URL to access the BackgroundImage</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/background-image/#plankapy.v2.models.background_image.BackgroundImage.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/background-image/#plankapy.v2.models.background_image.BackgroundImage.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>When the BackgroundImage was created</p>"},{"location":"v2/models/background-image/#plankapy.v2.models.background_image.BackgroundImage.project","title":"project  <code>property</code>","text":"<pre><code>project: Project\n</code></pre> <p>The Project the BackgroundImage belongs to</p>"},{"location":"v2/models/background-image/#plankapy.v2.models.background_image.BackgroundImage.size","title":"size  <code>property</code>","text":"<pre><code>size: int\n</code></pre> <p>The size of the BackgroundImage in bytes</p>"},{"location":"v2/models/background-image/#plankapy.v2.models.background_image.BackgroundImage.thumbnails","title":"thumbnails  <code>property</code>","text":"<pre><code>thumbnails: dict[str, str]\n</code></pre> <p>URLs for different thumbnail sizes of the background image</p>"},{"location":"v2/models/background-image/#plankapy.v2.models.background_image.BackgroundImage.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>When the BackgroundImage was last updated</p>"},{"location":"v2/models/background-image/#plankapy.v2.models.background_image.BackgroundImage.url","title":"url  <code>property</code>","text":"<pre><code>url: str\n</code></pre> <p>The URL to access the BackgroundImage</p>"},{"location":"v2/models/background-image/#plankapy.v2.models.background_image.BackgroundImage.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/background-image/#plankapy.v2.models.background_image.BackgroundImage.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the BackgroundImage</p> Source code in <code>src/plankapy/v2/models/background_image.py</code> <pre><code>def delete(self):\n    \"\"\"Delete the BackgroundImage\"\"\"\n    return self.endpoints.deleteBackgroundImage(self.id)\n</code></pre>"},{"location":"v2/models/background-image/#plankapy.v2.models.background_image.BackgroundImage.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/background-image/#plankapy.v2.models.background_image.BackgroundImage.download","title":"download","text":"<pre><code>download() -&gt; Iterator[bytes]\n</code></pre> <p>Get bytes for the full image</p> RETURNS DESCRIPTION <code>Iterator[bytes]</code> <p>A byte iterator for the full image</p> Source code in <code>src/plankapy/v2/models/background_image.py</code> <pre><code>def download(self) -&gt; Iterator[bytes]:\n    \"\"\"Get bytes for the full image\n\n    Returns:\n        (Iterator[bytes]): A byte iterator for the full image\n    \"\"\"\n    return self.client.get(self.url).iter_bytes()\n</code></pre>"},{"location":"v2/models/background-image/#plankapy.v2.models.background_image.BackgroundImage.download_thumbnails","title":"download_thumbnails","text":"<pre><code>download_thumbnails() -&gt; Generator[tuple[str, Iterator[bytes]]]\n</code></pre> <p>Get byte iterators for all thumbnails</p> YIELDS DESCRIPTION <code>tuple[str, Iterator[bytes]]</code> <p>A tuple containing the size key and the thumbnail byte iterator</p> Source code in <code>src/plankapy/v2/models/background_image.py</code> <pre><code>def download_thumbnails(self) -&gt; Generator[tuple[str, Iterator[bytes]]]:\n    \"\"\"Get byte iterators for all thumbnails\n\n    Yields:\n        (tuple[str, Iterator[bytes]]): A tuple containing the size key and the thumbnail byte iterator\n    \"\"\"\n    for size, url in self.thumbnails.items():\n        yield size, self.client.get(url).iter_bytes()\n</code></pre>"},{"location":"v2/models/base-custom-field-group/","title":"Base Custom Field Group","text":"CLASS DESCRIPTION <code>BaseCustomFieldGroup</code> <p>Python interface for Planka BaseCustomFieldGroups</p>"},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup","title":"BaseCustomFieldGroup","text":"<pre><code>BaseCustomFieldGroup(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[BaseCustomFieldGroup]</code></p> <p>Python interface for Planka BaseCustomFieldGroups</p> Returned by: <ul> <li> Plankapy v2 models <ul> <li> Custom Field <code></code>\u00a0CustomField <code></code>\u00a0base_custom_field_group </li> <li> Custom Field Group <code></code>\u00a0CustomFieldGroup <ul> <li> <code></code>\u00a0base_custom_field_group </li> <li> <code></code>\u00a0make_base_group </li> </ul> </li> <li> Project <code></code>\u00a0Project <ul> <li> <code></code>\u00a0base_custom_field_groups </li> <li> <code></code>\u00a0create_base_custom_field_group </li> </ul> </li> </ul> </li> </ul> Used by: <ul> <li> Plankapy v2 models Board <code></code>\u00a0Board <code></code>\u00a0create_field_group </li> </ul> METHOD DESCRIPTION <code>add_field</code> <p>Add an existing CustomField to the BaseGroup</p> <code>add_fields</code> <p>Add a multiple CustomFields to the field group. Useful for copying from one </p> <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>create_field</code> <p>Create a new CustomField in the BaseCustomFieldGroup</p> <code>create_fields</code> <p>Create multiple fields in the group (position will be arg order)</p> <code>delete</code> <p>Delete the BaseCustomFieldGroup</p> <code>delete_field</code> <p>Delete a CustomField from the Group</p> <code>delete_fields</code> <p>Delete s sequence of fields from the Group</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> <code>sync</code> <p>Sync the BaseCustomFieldGroup with the Planka server</p> <code>update</code> <p>Update the BaseCustomFieldGroup</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>created_at</code> <p>When the base custom field group was created</p> <p> TYPE: <code>datetime</code> </p> <code>custom_fields</code> <p>The CustomFields associated with the BaseCustomFieldGroup</p> <p> TYPE: <code>list[CustomField]</code> </p> <code>name</code> <p>Name/title of the base custom field group</p> <p> TYPE: <code>str</code> </p> <code>project</code> <p>The Project that the BaseCustomFieldGroup is associated with</p> <p> TYPE: <code>Project</code> </p> <code>updated_at</code> <p>When the base custom field group was last updated</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>When the base custom field group was created</p>"},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.custom_fields","title":"custom_fields  <code>property</code>","text":"<pre><code>custom_fields: list[CustomField]\n</code></pre> <p>The CustomFields associated with the BaseCustomFieldGroup</p>"},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the base custom field group</p>"},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.project","title":"project  <code>property</code>","text":"<pre><code>project: Project\n</code></pre> <p>The Project that the BaseCustomFieldGroup is associated with</p>"},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>When the base custom field group was last updated</p>"},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.add_field","title":"add_field","text":"<pre><code>add_field(field: CustomField, *, position: Position = 'top', show_on_card: bool | None = None) -&gt; CustomField\n</code></pre> <p>Add an existing CustomField to the BaseGroup</p> PARAMETER DESCRIPTION <p>The existing CustomField to add</p> <p> TYPE: <code>CustomField</code> </p> <p>The position of the new Field</p> <p> TYPE: <code>Position</code> DEFAULT: <code>'top'</code> </p> <p>Override the input Field's show state</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Note <p>If a CustomField with a matching name already exists in the base group, it  will be returned</p> Source code in <code>src/plankapy/v2/models/base_custom_field_group.py</code> <pre><code>def add_field(self, field: CustomField, \n              *, \n              position: Position='top',\n              show_on_card: bool|None=None) -&gt; CustomField:\n    \"\"\"Add an existing CustomField to the BaseGroup\n\n    Args:\n        field: The existing CustomField to add\n        position: The position of the new Field\n        show_on_card: Override the input Field's show state\n\n    Note:\n        If a CustomField with a matching name already exists in the base group, it \n        will be returned\n    \"\"\"\n\n    if (cf := self.custom_fields[field].dpop()):\n        flds = ('name', 'position', 'showOnFrontOfCard')\n        cf.update(**{k: field[k] for k in flds if cf[k] != field[k]})\n        return cf\n\n    return self.create_field(\n        field.name, \n        position=position, \n        show_on_card=show_on_card or field.show_on_front_of_card\n    )\n</code></pre>"},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.add_field(field)","title":"<code>field</code>","text":""},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.add_field(position)","title":"<code>position</code>","text":""},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.add_field(show_on_card)","title":"<code>show_on_card</code>","text":""},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.add_fields","title":"add_fields","text":"<pre><code>add_fields(fields: Sequence[CustomField], *, position: Position = 'top', show_on_card: bool | None = None) -&gt; list[CustomField]\n</code></pre> <p>Add a multiple CustomFields to the field group. Useful for copying from one  Project to another</p> PARAMETER DESCRIPTION <p>A sequence of fields to add</p> <p> TYPE: <code>Sequence[CustomField]</code> </p> <p>Position override for the fields (Will be applied sequence in order)</p> <p> TYPE: <code>Position</code> DEFAULT: <code>'top'</code> </p> <p>Card display override for fields</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Example <pre><code>&gt;&gt;&gt; p1_bcfg.add_fields(p2_bcfg.custom_fields)\n</code></pre> Source code in <code>src/plankapy/v2/models/base_custom_field_group.py</code> <pre><code>@model_list\ndef add_fields(self, fields: Sequence[CustomField],\n               *,\n               position: Position='top',\n               show_on_card: bool|None=None) -&gt; list[CustomField]:\n    \"\"\"Add a multiple CustomFields to the field group. Useful for copying from one \n    Project to another\n\n    Args:\n        fields: A sequence of fields to add\n        position: Position override for the fields (Will be applied sequence in order)\n        show_on_card: Card display override for fields\n\n    Example:\n        ```python\n        &gt;&gt;&gt; p1_bcfg.add_fields(p2_bcfg.custom_fields)\n        ```\n    \"\"\"\n    return [\n        self.add_field(\n            field, \n            position=position or field.position, \n            show_on_card=show_on_card\n        ) \n        for field in fields\n    ]\n</code></pre>"},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.add_fields(fields)","title":"<code>fields</code>","text":""},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.add_fields(position)","title":"<code>position</code>","text":""},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.add_fields(show_on_card)","title":"<code>show_on_card</code>","text":""},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.create_field","title":"create_field","text":"<pre><code>create_field(name: str, *, position: Position = 'top', show_on_card: bool = False) -&gt; CustomField\n</code></pre> <p>Create a new CustomField in the BaseCustomFieldGroup</p> PARAMETER DESCRIPTION <p>Name/title of the custom field</p> <p> TYPE: <code>str</code> </p> <p>Position of the custom field within the group</p> <p> TYPE: <code>Position</code> DEFAULT: <code>'top'</code> </p> <p>Whether to show the field on the front of cards</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/plankapy/v2/models/base_custom_field_group.py</code> <pre><code>def create_field(self, \n                 name: str, \n                 *,\n                 position: Position='top', \n                 show_on_card: bool=False) -&gt; CustomField:\n    \"\"\"Create a new CustomField in the BaseCustomFieldGroup\n\n    Args:\n        name: Name/title of the custom field\n        position: Position of the custom field within the group\n        show_on_card: Whether to show the field on the front of cards \n    \"\"\"\n    return CustomField(\n        self.endpoints.createCustomFieldInBaseGroup(\n            self.id, \n            name=name,\n            position=get_position(self.custom_fields, position),\n            showOnFrontOfCard=show_on_card,\n            )['item'], \n        self.session\n    )\n</code></pre>"},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.create_field(name)","title":"<code>name</code>","text":""},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.create_field(position)","title":"<code>position</code>","text":""},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.create_field(show_on_card)","title":"<code>show_on_card</code>","text":""},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.create_fields","title":"create_fields","text":"<pre><code>create_fields(*names: str, show_on_card: bool = False) -&gt; list[CustomField]\n</code></pre> <p>Create multiple fields in the group (position will be arg order)</p> PARAMETER DESCRIPTION <p>Varargs of the new field names</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <p>Show the new fields on the front of Cards</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/plankapy/v2/models/base_custom_field_group.py</code> <pre><code>@model_list\ndef create_fields(self, *names: str, show_on_card: bool = False) -&gt; list[CustomField]:\n    \"\"\"Create multiple fields in the group (position will be arg order)\n\n    Args:\n        names: Varargs of the new field names\n        show_on_card: Show the new fields on the front of Cards\n    \"\"\"\n    return [\n        self.create_field(name, position='bottom', show_on_card=show_on_card)\n        for name in names\n    ]\n</code></pre>"},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.create_fields(names)","title":"<code>names</code>","text":""},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.create_fields(show_on_card)","title":"<code>show_on_card</code>","text":""},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the BaseCustomFieldGroup</p> Source code in <code>src/plankapy/v2/models/base_custom_field_group.py</code> <pre><code>def delete(self):\n    \"\"\"Delete the BaseCustomFieldGroup\"\"\"\n    return self.endpoints.deleteBaseCustomFieldGroup(self.id)\n</code></pre>"},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.delete_field","title":"delete_field","text":"<pre><code>delete_field(field: CustomField) -&gt; CustomField | None\n</code></pre> <p>Delete a CustomField from the Group</p> PARAMETER DESCRIPTION <p>The field to delete</p> <p> TYPE: <code>CustomField</code> </p> Note <p>If the field is not a member of the group, None will be returned</p> Source code in <code>src/plankapy/v2/models/base_custom_field_group.py</code> <pre><code>def delete_field(self, field: CustomField) -&gt; CustomField | None:\n    \"\"\"Delete a CustomField from the Group\n\n    Args:\n        field: The field to delete\n\n    Note:\n        If the field is not a member of the group, None will be returned \n    \"\"\"\n    if (f := self.custom_fields[field].dpop()):\n        f.delete()\n        return f\n</code></pre>"},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.delete_field(field)","title":"<code>field</code>","text":""},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.delete_fields","title":"delete_fields","text":"<pre><code>delete_fields(fields: Sequence[CustomField]) -&gt; list[CustomField]\n</code></pre> <p>Delete s sequence of fields from the Group</p> PARAMETER DESCRIPTION <p>The fields to delete</p> <p> TYPE: <code>Sequence[CustomField]</code> </p> Note <p>If the field is not a member of the group, it will not be included in  the returned list</p> Source code in <code>src/plankapy/v2/models/base_custom_field_group.py</code> <pre><code>@model_list\ndef delete_fields(self, fields: Sequence[CustomField]) -&gt; list[CustomField]:\n    \"\"\"Delete s sequence of fields from the Group\n\n    Args:\n        fields: The fields to delete\n\n    Note:\n        If the field is not a member of the group, it will not be included in \n        the returned list\n    \"\"\"\n    return [removed for field in fields if (removed := self.delete_field(field))]\n</code></pre>"},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.delete_fields(fields)","title":"<code>fields</code>","text":""},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.sync","title":"sync","text":"<pre><code>sync()\n</code></pre> <p>Sync the BaseCustomFieldGroup with the Planka server</p> Source code in <code>src/plankapy/v2/models/base_custom_field_group.py</code> <pre><code>def sync(self):\n    \"\"\"Sync the BaseCustomFieldGroup with the Planka server\"\"\"\n    for bcfg in self.project.base_custom_field_groups:\n        if bcfg == self:\n            self.schema = bcfg.schema\n</code></pre>"},{"location":"v2/models/base-custom-field-group/#plankapy.v2.models.base_custom_field_group.BaseCustomFieldGroup.update","title":"update","text":"<pre><code>update(**base_custom_field_group: Unpack[Request_updateBaseCustomFieldGroup])\n</code></pre> <p>Update the BaseCustomFieldGroup</p> Source code in <code>src/plankapy/v2/models/base_custom_field_group.py</code> <pre><code>def update(self, **base_custom_field_group: Unpack[paths.Request_updateBaseCustomFieldGroup]):\n    \"\"\"Update the BaseCustomFieldGroup\"\"\"\n    self.endpoints.updateBaseCustomFieldGroup(self.id, **base_custom_field_group)\n</code></pre>"},{"location":"v2/models/board-membership/","title":"Board Membership","text":"CLASS DESCRIPTION <code>BoardMembership</code> <p>Python interface for Planka BoardMemberships</p>"},{"location":"v2/models/board-membership/#plankapy.v2.models.board_membership.BoardMembership","title":"BoardMembership","text":"<pre><code>BoardMembership(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[BoardMembership]</code></p> <p>Python interface for Planka BoardMemberships</p> Returned by: <ul> <li> Plankapy v2 models <ul> <li> Board <code></code>\u00a0Board <ul> <li> <code></code>\u00a0board_memberships </li> <li> <code></code>\u00a0add_editor </li> <li> <code></code>\u00a0add_editors </li> <li> <code></code>\u00a0add_member </li> <li> <code></code>\u00a0add_members </li> <li> <code></code>\u00a0add_viewer </li> <li> <code></code>\u00a0add_viewers </li> </ul> </li> <li> Project <code></code>\u00a0Project <code></code>\u00a0board_memberships </li> </ul> </li> </ul> METHOD DESCRIPTION <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>delete</code> <p>Delete the BoardMebership</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> <code>sync</code> <p>Sync the BoardMembership with the Planka server</p> <code>update</code> <p>Update the BoardMembership</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>board</code> <p>The Board the BoardMembership is associated with</p> <p> TYPE: <code>Board</code> </p> <code>can_comment</code> <p>Whether the user can comment on cards</p> <p> TYPE: <code>bool</code> </p> <code>created_at</code> <p>When the board membership was created</p> <p> TYPE: <code>datetime</code> </p> <code>project</code> <p>The Project the BoardMembership belongs to</p> <p> TYPE: <code>Project</code> </p> <code>role</code> <p>Role of the user in the board</p> <p> TYPE: <code>BoardRole</code> </p> <code>updated_at</code> <p>When the board membership was last updated</p> <p> TYPE: <code>datetime</code> </p> <code>user</code> <p>The User the BoardMembership is associated with (Raises LookupError if User no longer in the Board)</p> <p> TYPE: <code>User</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/board-membership/#plankapy.v2.models.board_membership.BoardMembership.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/board-membership/#plankapy.v2.models.board_membership.BoardMembership.board","title":"board  <code>property</code>","text":"<pre><code>board: Board\n</code></pre> <p>The Board the BoardMembership is associated with</p>"},{"location":"v2/models/board-membership/#plankapy.v2.models.board_membership.BoardMembership.can_comment","title":"can_comment  <code>property</code> <code>writable</code>","text":"<pre><code>can_comment: bool\n</code></pre> <p>Whether the user can comment on cards</p>"},{"location":"v2/models/board-membership/#plankapy.v2.models.board_membership.BoardMembership.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>When the board membership was created</p>"},{"location":"v2/models/board-membership/#plankapy.v2.models.board_membership.BoardMembership.project","title":"project  <code>property</code>","text":"<pre><code>project: Project\n</code></pre> <p>The Project the BoardMembership belongs to</p>"},{"location":"v2/models/board-membership/#plankapy.v2.models.board_membership.BoardMembership.role","title":"role  <code>property</code> <code>writable</code>","text":"<pre><code>role: BoardRole\n</code></pre> <p>Role of the user in the board</p>"},{"location":"v2/models/board-membership/#plankapy.v2.models.board_membership.BoardMembership.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>When the board membership was last updated</p>"},{"location":"v2/models/board-membership/#plankapy.v2.models.board_membership.BoardMembership.user","title":"user  <code>property</code>","text":"<pre><code>user: User\n</code></pre> <p>The User the BoardMembership is associated with (Raises LookupError if User no longer in the Board)</p>"},{"location":"v2/models/board-membership/#plankapy.v2.models.board_membership.BoardMembership.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/board-membership/#plankapy.v2.models.board_membership.BoardMembership.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the BoardMebership</p> Source code in <code>src/plankapy/v2/models/board_membership.py</code> <pre><code>def delete(self):\n    \"\"\"Delete the BoardMebership\"\"\"\n    return self.endpoints.deleteBoardMembership(self.id)\n</code></pre>"},{"location":"v2/models/board-membership/#plankapy.v2.models.board_membership.BoardMembership.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/board-membership/#plankapy.v2.models.board_membership.BoardMembership.sync","title":"sync","text":"<pre><code>sync()\n</code></pre> <p>Sync the BoardMembership with the Planka server</p> Source code in <code>src/plankapy/v2/models/board_membership.py</code> <pre><code>def sync(self):\n    \"\"\"Sync the BoardMembership with the Planka server\"\"\"\n    _bms = [bm for bm in self.board.board_memberships if bm == self]\n    if _bms:\n        self.schema = _bms.pop().schema\n</code></pre>"},{"location":"v2/models/board-membership/#plankapy.v2.models.board_membership.BoardMembership.update","title":"update","text":"<pre><code>update(**kwargs: Unpack[Request_updateBoardMembership]) -&gt; None\n</code></pre> <p>Update the BoardMembership</p> Source code in <code>src/plankapy/v2/models/board_membership.py</code> <pre><code>def update(self, **kwargs: Unpack[paths.Request_updateBoardMembership]) -&gt; None:\n    \"\"\"Update the BoardMembership\"\"\"\n    self.schema = self.endpoints.updateBoardMembership(self.id, **kwargs)['item']\n</code></pre>"},{"location":"v2/models/board/","title":"Board","text":"CLASS DESCRIPTION <code>Board</code> <p>Python interface for Planka Boards</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board","title":"Board","text":"<pre><code>Board(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[Board]</code></p> <p>Python interface for Planka Boards</p> Returned by: <ul> <li> Plankapy v2 models <ul> <li> Action <code></code>\u00a0Action <code></code>\u00a0board </li> <li> Board Membership <code></code>\u00a0BoardMembership <code></code>\u00a0board </li> <li> Card <code></code>\u00a0Card <code></code>\u00a0board </li> <li> Custom Field Group <code></code>\u00a0CustomFieldGroup <code></code>\u00a0board </li> <li> Label <code></code>\u00a0Label <code></code>\u00a0board </li> <li> List <code></code>\u00a0List <code></code>\u00a0board </li> <li> Notification <code></code>\u00a0Notification <code></code>\u00a0board </li> <li> Notification Service <code></code>\u00a0NotificationService <code></code>\u00a0board </li> <li> Project <code></code>\u00a0Project <ul> <li> <code></code>\u00a0boards </li> <li> <code></code>\u00a0create_board </li> <li> <code></code>\u00a0import_board </li> </ul> </li> </ul> </li> </ul> Used by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <ul> <li> <code></code>\u00a0board_to_csv </li> <li> <code></code>\u00a0board_to_table </li> </ul> </li> <li> models <ul> <li> Label <code></code>\u00a0Label <code></code>\u00a0add_to_board </li> <li> User <code></code>\u00a0User <ul> <li> <code></code>\u00a0add_to_board </li> <li> <code></code>\u00a0remove_from_board </li> </ul> </li> </ul> </li> </ul> </li> </ul> METHOD DESCRIPTION <code>add_editor</code> <p>Add a Board editor</p> <code>add_editors</code> <p>Add Board editors</p> <code>add_member</code> <p>Add a User to the Board</p> <code>add_members</code> <p>Add a Users to the Board</p> <code>add_viewer</code> <p>Add a Board viewer</p> <code>add_viewers</code> <p>Add a Board viewer</p> <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>create_field_group</code> <p>Create a new CustomFieldGroup on the Board</p> <code>create_label</code> <p>Create a new Label on the Board</p> <code>create_list</code> <p>Create a new List on the Board</p> <code>delete</code> <p>Delete the Board</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> <code>filter</code> <p>Apply a card filter to the board (apply the filter to all lists and agregate the cards)</p> <code>remove_label</code> <p>Remove a Label from the Board</p> <code>remove_list</code> <p>Remove a List from the Board</p> <code>remove_user</code> <p>Remove a User from the Board</p> <code>remove_users</code> <p>Remove Users from the Board</p> <code>sync</code> <p>Sync the Board with the Planka Server</p> <code>update</code> <p>Update the Board</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>active_lists</code> <p>Get all active Lists for the Board</p> <p> TYPE: <code>list[List]</code> </p> <code>all_lists</code> <p>Get all Lists associated with the Board (including archive and trash)</p> <p> TYPE: <code>list[List]</code> </p> <code>always_display_card_creator</code> <p>Whether to always display the Card creator</p> <p> TYPE: <code>bool</code> </p> <code>archive_list</code> <p>Get the archive List for the Board (archive List is not a normal List!)</p> <p> TYPE: <code>List</code> </p> <code>archived_cards</code> <p>Get all Cards in the Board archive list</p> <p> TYPE: <code>list[Card]</code> </p> <code>attachments</code> <p>Get all Attachments associated with the Board</p> <p> TYPE: <code>list[Attachment]</code> </p> <code>board_memberships</code> <p>Get all BoardMemberships for the Board</p> <p> TYPE: <code>list[BoardMembership]</code> </p> <code>card_labels</code> <p>Get all CardLabels associated with the Board</p> <p> TYPE: <code>list[CardLabel]</code> </p> <code>card_memberships</code> <p>Get all CardMemberships associated with the Board</p> <p> TYPE: <code>list[CardMembership]</code> </p> <code>cards</code> <p>Get all active Cards on the Board (use archived_cards and trashed_cards for archived/trashed Card lists)</p> <p> TYPE: <code>list[Card]</code> </p> <code>closed_lists</code> <p>Get all closed Lists for the Board</p> <p> TYPE: <code>list[List]</code> </p> <code>created_at</code> <p>When the Board was created</p> <p> TYPE: <code>datetime</code> </p> <code>custom_field_groups</code> <p>Get all CustomFieldGroups associated with the Board</p> <p> TYPE: <code>list[CustomFieldGroup]</code> </p> <code>custom_field_values</code> <p>Get all CustomFieldValues associated with the Board</p> <p> TYPE: <code>list[CustomFieldValue]</code> </p> <code>custom_fields</code> <p>Get all CustomFields associated with the Board</p> <p> TYPE: <code>list[CustomField]</code> </p> <code>default_card_type</code> <p>Default Card type for new Cards</p> <p> TYPE: <code>CardType</code> </p> <code>default_view</code> <p>Default view for the board</p> <p> TYPE: <code>BoardView</code> </p> <code>editors</code> <p>Get all editor Users for the Board</p> <p> TYPE: <code>list[User]</code> </p> <code>expand_task_lists_by_default</code> <p>Whether to expand TaskLists by default</p> <p> TYPE: <code>bool</code> </p> <code>formal_name</code> <p>Get the formal name of the board in the format <code>{Project}-&gt;{Board}</code></p> <p> TYPE: <code>str</code> </p> <code>labels</code> <p>Get all Labels on the Board</p> <p> TYPE: <code>list[Label]</code> </p> <code>limit_card_types_to_default_one</code> <p>Whether to limit Card types to default one</p> <p> TYPE: <code>bool</code> </p> <code>lists</code> <p>Get all active/closed lists in the board (this is the one you most likely want)</p> <p> TYPE: <code>list[List]</code> </p> <code>name</code> <p>Name/title of the Board</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the Board within the Project</p> <p> TYPE: <code>int</code> </p> <code>project</code> <p>TheProject the Board belongs to</p> <p> TYPE: <code>Project</code> </p> <code>projects</code> <p>Get all Projects that the Board is associated with (use <code>Board.Project</code> instead, this is always one item)</p> <p> TYPE: <code>list[Project]</code> </p> <code>subscribed</code> <p>Whether the current user is subscribed to the Board</p> <p> TYPE: <code>bool</code> </p> <code>subscribed_cards</code> <p>Get all Cards on the Board that the current User is subscribed to</p> <p> TYPE: <code>list[Card]</code> </p> <code>task_lists</code> <p>Get all TaskLists associated with the Board</p> <p> TYPE: <code>list[TaskList]</code> </p> <code>tasks</code> <p>Get all Tasks associated with the Board</p> <p> TYPE: <code>list[Task]</code> </p> <code>trash_list</code> <p>Get the trash List for the Board (trash List is not a normal List!)</p> <p> TYPE: <code>List</code> </p> <code>trashed_cards</code> <p>Get all Cards in the Board trash list</p> <p> TYPE: <code>list[Card]</code> </p> <code>updated_at</code> <p>When the Board was last updated</p> <p> TYPE: <code>datetime</code> </p> <code>users</code> <p>Get all Users on the Board</p> <p> TYPE: <code>list[User]</code> </p> <code>viewers</code> <p>Get all viewer Users for the Board</p> <p> TYPE: <code>list[User]</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.active_lists","title":"active_lists  <code>property</code>","text":"<pre><code>active_lists: list[List]\n</code></pre> <p>Get all active Lists for the Board</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.all_lists","title":"all_lists  <code>property</code>","text":"<pre><code>all_lists: list[List]\n</code></pre> <p>Get all Lists associated with the Board (including archive and trash)</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.always_display_card_creator","title":"always_display_card_creator  <code>property</code> <code>writable</code>","text":"<pre><code>always_display_card_creator: bool\n</code></pre> <p>Whether to always display the Card creator</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.archive_list","title":"archive_list  <code>property</code>","text":"<pre><code>archive_list: List\n</code></pre> <p>Get the archive List for the Board (archive List is not a normal List!)</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.archived_cards","title":"archived_cards  <code>property</code>","text":"<pre><code>archived_cards: list[Card]\n</code></pre> <p>Get all Cards in the Board archive list</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.attachments","title":"attachments  <code>property</code>","text":"<pre><code>attachments: list[Attachment]\n</code></pre> <p>Get all Attachments associated with the Board</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.board_memberships","title":"board_memberships  <code>property</code>","text":"<pre><code>board_memberships: list[BoardMembership]\n</code></pre> <p>Get all BoardMemberships for the Board</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.card_labels","title":"card_labels  <code>property</code>","text":"<pre><code>card_labels: list[CardLabel]\n</code></pre> <p>Get all CardLabels associated with the Board</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.card_memberships","title":"card_memberships  <code>property</code>","text":"<pre><code>card_memberships: list[CardMembership]\n</code></pre> <p>Get all CardMemberships associated with the Board</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.cards","title":"cards  <code>property</code>","text":"<pre><code>cards: list[Card]\n</code></pre> <p>Get all active Cards on the Board (use archived_cards and trashed_cards for archived/trashed Card lists)</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.closed_lists","title":"closed_lists  <code>property</code>","text":"<pre><code>closed_lists: list[List]\n</code></pre> <p>Get all closed Lists for the Board</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>When the Board was created</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.custom_field_groups","title":"custom_field_groups  <code>property</code>","text":"<pre><code>custom_field_groups: list[CustomFieldGroup]\n</code></pre> <p>Get all CustomFieldGroups associated with the Board</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.custom_field_values","title":"custom_field_values  <code>property</code>","text":"<pre><code>custom_field_values: list[CustomFieldValue]\n</code></pre> <p>Get all CustomFieldValues associated with the Board</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.custom_fields","title":"custom_fields  <code>property</code>","text":"<pre><code>custom_fields: list[CustomField]\n</code></pre> <p>Get all CustomFields associated with the Board</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.default_card_type","title":"default_card_type  <code>property</code> <code>writable</code>","text":"<pre><code>default_card_type: CardType\n</code></pre> <p>Default Card type for new Cards</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.default_view","title":"default_view  <code>property</code> <code>writable</code>","text":"<pre><code>default_view: BoardView\n</code></pre> <p>Default view for the board</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.editors","title":"editors  <code>property</code>","text":"<pre><code>editors: list[User]\n</code></pre> <p>Get all editor Users for the Board</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.expand_task_lists_by_default","title":"expand_task_lists_by_default  <code>property</code> <code>writable</code>","text":"<pre><code>expand_task_lists_by_default: bool\n</code></pre> <p>Whether to expand TaskLists by default</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.formal_name","title":"formal_name  <code>property</code>","text":"<pre><code>formal_name: str\n</code></pre> <p>Get the formal name of the board in the format <code>{Project}-&gt;{Board}</code></p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.labels","title":"labels  <code>property</code>","text":"<pre><code>labels: list[Label]\n</code></pre> <p>Get all Labels on the Board</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.limit_card_types_to_default_one","title":"limit_card_types_to_default_one  <code>property</code> <code>writable</code>","text":"<pre><code>limit_card_types_to_default_one: bool\n</code></pre> <p>Whether to limit Card types to default one</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.lists","title":"lists  <code>property</code>","text":"<pre><code>lists: list[List]\n</code></pre> <p>Get all active/closed lists in the board (this is the one you most likely want)</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the Board</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.position","title":"position  <code>property</code> <code>writable</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the Board within the Project</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.project","title":"project  <code>property</code>","text":"<pre><code>project: Project\n</code></pre> <p>TheProject the Board belongs to</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.projects","title":"projects  <code>property</code>","text":"<pre><code>projects: list[Project]\n</code></pre> <p>Get all Projects that the Board is associated with (use <code>Board.Project</code> instead, this is always one item)</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.subscribed","title":"subscribed  <code>property</code>","text":"<pre><code>subscribed: bool\n</code></pre> <p>Whether the current user is subscribed to the Board</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.subscribed_cards","title":"subscribed_cards  <code>property</code>","text":"<pre><code>subscribed_cards: list[Card]\n</code></pre> <p>Get all Cards on the Board that the current User is subscribed to</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.task_lists","title":"task_lists  <code>property</code>","text":"<pre><code>task_lists: list[TaskList]\n</code></pre> <p>Get all TaskLists associated with the Board</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: list[Task]\n</code></pre> <p>Get all Tasks associated with the Board</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.trash_list","title":"trash_list  <code>property</code>","text":"<pre><code>trash_list: List\n</code></pre> <p>Get the trash List for the Board (trash List is not a normal List!)</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.trashed_cards","title":"trashed_cards  <code>property</code>","text":"<pre><code>trashed_cards: list[Card]\n</code></pre> <p>Get all Cards in the Board trash list</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>When the Board was last updated</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.users","title":"users  <code>property</code>","text":"<pre><code>users: list[User]\n</code></pre> <p>Get all Users on the Board</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.viewers","title":"viewers  <code>property</code>","text":"<pre><code>viewers: list[User]\n</code></pre> <p>Get all viewer Users for the Board</p>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.add_editor","title":"add_editor","text":"<pre><code>add_editor(user: User) -&gt; BoardMembership\n</code></pre> <p>Add a Board editor</p> PARAMETER DESCRIPTION <p>The User to add as an editor</p> <p> TYPE: <code>User</code> </p> RETURNS DESCRIPTION <code>BoardMembership</code> <p>BoardMembership</p> Source code in <code>src/plankapy/v2/models/board.py</code> <pre><code>def add_editor(self, user: User) -&gt; BoardMembership:\n    \"\"\"Add a Board editor\n\n    Args:\n        user (User): The User to add as an editor\n\n    Returns:\n        BoardMembership\n    \"\"\"\n    return self.add_member(user, role='editor', can_comment=True)\n</code></pre>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.add_editor(user)","title":"<code>user</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.add_editors","title":"add_editors","text":"<pre><code>add_editors(users: Sequence[User]) -&gt; list[BoardMembership]\n</code></pre> <p>Add Board editors</p> PARAMETER DESCRIPTION <p>The Users to add as editors</p> <p> TYPE: <code>Sequence[User]</code> </p> RETURNS DESCRIPTION <code>list[BoardMembership]</code> <p>list[BoardMembership]</p> Source code in <code>src/plankapy/v2/models/board.py</code> <pre><code>@model_list\ndef add_editors(self, users: Sequence[User]) -&gt; list[BoardMembership]:\n    \"\"\"Add Board editors\n\n    Args:\n        users (Sequence[User]): The Users to add as editors\n\n    Returns:\n        list[BoardMembership]\n    \"\"\"\n    return [self.add_editor(user) for user in users]\n</code></pre>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.add_editors(users)","title":"<code>users</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.add_member","title":"add_member","text":"<pre><code>add_member(user: User, *, role: BoardRole = 'viewer', can_comment: bool = False) -&gt; BoardMembership\n</code></pre> <p>Add a User to the Board</p> PARAMETER DESCRIPTION <p>The User to add</p> <p> TYPE: <code>User</code> </p> <p>The Role to assign to the user (default: <code>viewer</code>)</p> <p> TYPE: <code>Literal['viewer', 'editor']</code> DEFAULT: <code>'viewer'</code> </p> <p>If role is <code>viewer</code> set commenting status (default: <code>False</code>)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/plankapy/v2/models/board.py</code> <pre><code>def add_member(self, user: User, \n               *,\n               role: BoardRole='viewer',\n               can_comment: bool=False) -&gt; BoardMembership:\n    \"\"\"Add a User to the Board\n\n    Args:\n        user (User): The User to add\n        role (Literal['viewer', 'editor']): The Role to assign to the user (default: `viewer`)\n        can_comment (bool): If role is `viewer` set commenting status (default: `False`)\n    \"\"\"\n    # Create a new membership\n    if user not in self.users:\n        BoardMembership(\n            self.endpoints.createBoardMembership(\n                self.id, \n                userId=user.id, \n                role=role, \n                canComment=can_comment)['item'], \n            self.session\n        )\n\n    # Get existing membership and update role different\n    membership = [bm for bm in self.board_memberships if bm.user == user].pop()\n    if membership.role != role:\n        membership.role = role\n    if membership.can_comment != can_comment:\n        membership.can_comment = can_comment\n    return membership\n</code></pre>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.add_member(user)","title":"<code>user</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.add_member(role)","title":"<code>role</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.add_member(can_comment)","title":"<code>can_comment</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.add_members","title":"add_members","text":"<pre><code>add_members(users: Sequence[User], *, role: BoardRole = 'viewer', can_comment: bool = False) -&gt; list[BoardMembership]\n</code></pre> <p>Add a Users to the Board</p> PARAMETER DESCRIPTION <p>The Users to add</p> <p> TYPE: <code>Sequence[User]</code> </p> <p>The Role to assign to the user (default: <code>viewer</code>)</p> <p> TYPE: <code>Literal['viewer', 'editor']</code> DEFAULT: <code>'viewer'</code> </p> <p>If role is <code>viewer</code> set commenting status (default: <code>False</code>)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>list[BoardMembership]</code> <p>list[BoardMembership]</p> Source code in <code>src/plankapy/v2/models/board.py</code> <pre><code>@model_list\ndef add_members(self, users: Sequence[User], \n                *,\n                role: BoardRole='viewer',\n                can_comment: bool=False) -&gt; list[BoardMembership]:\n    \"\"\"Add a Users to the Board\n\n    Args:\n        users (Sequence[User]): The Users to add\n        role (Literal['viewer', 'editor']): The Role to assign to the user (default: `viewer`)\n        can_comment (bool): If role is `viewer` set commenting status (default: `False`)\n\n    Returns:\n        list[BoardMembership]\n    \"\"\"\n    return [\n        self.add_member(\n            user,\n            role=role,\n            can_comment=can_comment,\n        )\n        for user in users\n    ]\n</code></pre>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.add_members(users)","title":"<code>users</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.add_members(role)","title":"<code>role</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.add_members(can_comment)","title":"<code>can_comment</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.add_viewer","title":"add_viewer","text":"<pre><code>add_viewer(user: User, *, can_comment: bool = False) -&gt; BoardMembership\n</code></pre> <p>Add a Board viewer</p> PARAMETER DESCRIPTION <p>The User to add as a viewer</p> <p> TYPE: <code>User</code> </p> <p>Whether the viewer User can comment on cards</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/plankapy/v2/models/board.py</code> <pre><code>def add_viewer(self, user: User, *, can_comment: bool=False) -&gt; BoardMembership:\n    \"\"\"Add a Board viewer\n\n    Args:\n        user (User): The User to add as a viewer\n        can_comment (bool): Whether the viewer User can comment on cards\n    \"\"\"\n    return self.add_member(user, role='viewer', can_comment=can_comment)\n</code></pre>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.add_viewer(user)","title":"<code>user</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.add_viewer(can_comment)","title":"<code>can_comment</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.add_viewers","title":"add_viewers","text":"<pre><code>add_viewers(users: Sequence[User], *, can_comment: bool = False) -&gt; list[BoardMembership]\n</code></pre> <p>Add a Board viewer</p> PARAMETER DESCRIPTION <p>The Users to add as viewers</p> <p> TYPE: <code>Sequence[User]</code> </p> <p>Whether the viewer Users can comment on cards</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/plankapy/v2/models/board.py</code> <pre><code>@model_list\ndef add_viewers(self, users: Sequence[User], *, can_comment: bool=False) -&gt; list[BoardMembership]:\n    \"\"\"Add a Board viewer\n\n    Args:\n        users (Sequence[User]): The Users to add as viewers\n        can_comment (bool): Whether the viewer Users can comment on cards\n    \"\"\"\n    return [self.add_viewer(user, can_comment=can_comment) for user in users]\n</code></pre>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.add_viewers(users)","title":"<code>users</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.add_viewers(can_comment)","title":"<code>can_comment</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.create_field_group","title":"create_field_group","text":"<pre><code>create_field_group(name: str | None = None, *, position: Position = 'top', base_group: BaseCustomFieldGroup | None = None) -&gt; CustomFieldGroup\n</code></pre> <p>Create a new CustomFieldGroup on the Board</p> PARAMETER DESCRIPTION <p>The name of the Custom Field Group</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <p>The position of the field group within the board</p> <p> TYPE: <code>Position</code> DEFAULT: <code>'top'</code> </p> <p>An optional BaseCustomFieldGroup to use as a template</p> <p> TYPE: <code>BaseCustomFieldGroup | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/plankapy/v2/models/board.py</code> <pre><code>def create_field_group(self, \n                       name: str|None=None, \n                       *, \n                       position: Position= 'top', \n                       base_group: BaseCustomFieldGroup|None=None) -&gt; CustomFieldGroup:\n    \"\"\"Create a new CustomFieldGroup on the Board\n\n    Args:\n        name: The name of the Custom Field Group\n        position: The position of the field group within the board\n        base_group: An optional BaseCustomFieldGroup to use as a template\n    \"\"\"\n    args: paths.Request_createBoardCustomFieldGroup = {\n        'name': name,\n        'position': get_position(self.custom_field_groups, position)\n    }\n    if base_group:\n        args['baseCustomFieldGroupId'] = base_group.id\n        args['name'] = args['name'] or base_group.name\n    return CustomFieldGroup(\n        self.endpoints.createBoardCustomFieldGroup(self.id, **args)['item'],\n        self.session\n    )\n</code></pre>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.create_field_group(name)","title":"<code>name</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.create_field_group(position)","title":"<code>position</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.create_field_group(base_group)","title":"<code>base_group</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.create_label","title":"create_label","text":"<pre><code>create_label(*, name: str, position: Position = 'top', color: LabelColor | Literal['random'] = 'random') -&gt; Label\n</code></pre> <p>Create a new Label on the Board</p> PARAMETER DESCRIPTION <p>The name of the Label</p> <p> TYPE: <code>str</code> </p> <p>The position of the label in the label list</p> <p> </p> <p>An optional color for the label (a random unused color by default)</p> <p> TYPE: <code>LabelColor | Literal['random']</code> DEFAULT: <code>'random'</code> </p> Source code in <code>src/plankapy/v2/models/board.py</code> <pre><code>def create_label(self, \n                 *,\n                 name: str,\n                 position: Position='top',\n                 color: LabelColor|Literal['random']='random') -&gt; Label:\n    \"\"\"Create a new Label on the Board\n\n    Args:\n        name: The name of the Label\n        positon: The position of the label in the label list\n        color: An optional color for the label (a random unused color by default)\n    \"\"\"\n    l = Label(\n        self.endpoints.createLabel(\n            self.id, \n            name=name,\n            position=get_position(self.labels, position),\n            color=color if color != 'random' else choice(LabelColors))['item'], \n            self.session\n        )\n    return l\n</code></pre>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.create_label(name)","title":"<code>name</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.create_label(positon)","title":"<code>positon</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.create_label(color)","title":"<code>color</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.create_list","title":"create_list","text":"<pre><code>create_list(*, name: str, type: Literal['active', 'closed'] = 'active', position: Position = 'top', color: ListColor | Literal['random'] | None = None) -&gt; List\n</code></pre> <p>Create a new List on the Board</p> PARAMETER DESCRIPTION <p>Name/title of the List</p> <p> TYPE: <code>str</code> </p> <p>Type/status of the List</p> <p> TYPE: <code>Literal['active', 'closed']</code> DEFAULT: <code>'active'</code> </p> <p>Position of the List within the Board</p> <p> TYPE: <code>Position</code> DEFAULT: <code>'top'</code> </p> <p>An optional color to set the list to (<code>random</code> to randomize)</p> <p> TYPE: <code>ListColor | Literal['random'] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/plankapy/v2/models/board.py</code> <pre><code>def create_list(self, \n                *, \n                name: str,\n                type: Literal['active', 'closed']='active',\n                position: Position = 'top',\n                color: ListColor|Literal['random']|None=None) -&gt; List:\n    \"\"\"Create a new List on the Board\n\n    Args:\n        name: Name/title of the List\n        type: Type/status of the List\n        position: Position of the List within the Board\n        color: An optional color to set the list to (`random` to randomize)\n    \"\"\"\n    l = List(\n        self.endpoints.createList(\n            self.id, \n            name=name,\n            type=type,\n            position=get_position(self.active_lists + self.closed_lists, position))['item'], \n        self.session\n    )\n    if color:\n        l.color = color\n    return l\n</code></pre>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.create_list(name)","title":"<code>name</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.create_list(type)","title":"<code>type</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.create_list(position)","title":"<code>position</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.create_list(color)","title":"<code>color</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the Board</p> Source code in <code>src/plankapy/v2/models/board.py</code> <pre><code>def delete(self):\n    \"\"\"Delete the Board\"\"\"\n    return self.endpoints.deleteBoard(self.id)\n</code></pre>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.filter","title":"filter","text":"<pre><code>filter(*, search: str | None = None, users: User | Sequence[User] | None = None, labels: Label | Sequence[Label] | None = None, card_before: Card | None = None, changed_before: datetime | None = None) -&gt; list[Card]\n</code></pre> <p>Apply a card filter to the board (apply the filter to all lists and agregate the cards)</p> PARAMETER DESCRIPTION <p>A search term to apply to the cards</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <p>A list of Users to filter the cards by</p> <p> TYPE: <code>User | Sequence[User] | None</code> DEFAULT: <code>None</code> </p> <p>A list of Labels to filter the cards by</p> <p> TYPE: <code>Label | Sequence[Label] | None</code> DEFAULT: <code>None</code> </p> <p>Limit filter to only cards before this card</p> <p> TYPE: <code>Card | None</code> DEFAULT: <code>None</code> </p> <p>A time filter that filters on <code>list_changed_at</code></p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/plankapy/v2/models/board.py</code> <pre><code>@model_list\ndef filter(self, \n           *,\n           search: str|None=None,\n           users: User|Sequence[User]|None=None,\n           labels: Label|Sequence[Label]|None=None,\n           card_before: Card|None=None,\n           changed_before: datetime|None=None) -&gt; list[Card]:\n    \"\"\"Apply a card filter to the board (apply the filter to all lists and agregate the cards)\n\n    Args:\n        search: A search term to apply to the cards\n        users: A list of Users to filter the cards by\n        labels: A list of Labels to filter the cards by\n        card_before: Limit filter to only cards before this card\n        changed_before: A time filter that filters on `list_changed_at`\n    \"\"\"\n    return [\n        card\n        for l in self.lists\n        for card in l.filter(\n            search=search, \n            users=users, \n            labels=labels, \n            card_before=card_before, \n            changed_before=changed_before\n        ) \n    ]\n</code></pre>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.filter(search)","title":"<code>search</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.filter(users)","title":"<code>users</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.filter(labels)","title":"<code>labels</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.filter(card_before)","title":"<code>card_before</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.filter(changed_before)","title":"<code>changed_before</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.remove_label","title":"remove_label","text":"<pre><code>remove_label(label: Label) -&gt; None\n</code></pre> <p>Remove a Label from the Board</p> PARAMETER DESCRIPTION <p>The Label to remove (must be associated with the board)</p> <p> TYPE: <code>Label</code> </p> Source code in <code>src/plankapy/v2/models/board.py</code> <pre><code>def remove_label(self, label: Label) -&gt; None:\n    \"\"\"Remove a Label from the Board\n\n    Args:\n        label (Label): The Label to remove (must be associated with the board)\n    \"\"\"\n    if label in self.labels:\n        label.delete()\n</code></pre>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.remove_label(label)","title":"<code>label</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.remove_list","title":"remove_list","text":"<pre><code>remove_list(list: List) -&gt; None\n</code></pre> <p>Remove a List from the Board</p> PARAMETER DESCRIPTION <p>The list to remove (must be associated with the Board and not <code>trash</code> or <code>archive</code>)</p> <p> TYPE: <code>List</code> </p> Source code in <code>src/plankapy/v2/models/board.py</code> <pre><code>def remove_list(self, list: List) -&gt; None:\n    \"\"\"Remove a List from the Board\n\n    Args:\n        list (List): The list to remove (must be associated with the Board and not `trash` or `archive`)\n    \"\"\"\n    if list in self.active_lists:\n        list.delete()\n</code></pre>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.remove_list(list)","title":"<code>list</code>","text":""},{"location":"v2/models/board/#plankapy.v2.models.board.Board.remove_user","title":"remove_user","text":"<pre><code>remove_user(user: User) -&gt; User | None\n</code></pre> <p>Remove a User from the Board</p> Note <p>If the User is not a member, no change will be made and None will be returned</p> Source code in <code>src/plankapy/v2/models/board.py</code> <pre><code>def remove_user(self, user: User) -&gt; User | None:\n    \"\"\"Remove a User from the Board\n\n    Note:\n        If the User is not a member, no change will be made and None will be returned\n    \"\"\"\n    if (membership := self.board_memberships[{'userId': user.id}].dpop()):\n        membership.delete()\n        return user\n</code></pre>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.remove_users","title":"remove_users","text":"<pre><code>remove_users(users: Sequence[User]) -&gt; list[User]\n</code></pre> <p>Remove Users from the Board</p> Note <p>If a User is not a member, no change will be made and they will  be excluded from the returned user list</p> Source code in <code>src/plankapy/v2/models/board.py</code> <pre><code>@model_list\ndef remove_users(self, users: Sequence[User]) -&gt; list[User]:\n    \"\"\"Remove Users from the Board\n\n    Note:\n        If a User is not a member, no change will be made and they will \n        be excluded from the returned user list\n    \"\"\"\n    return [removed for u in users if (removed := self.remove_user(u))]\n</code></pre>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.sync","title":"sync","text":"<pre><code>sync() -&gt; None\n</code></pre> <p>Sync the Board with the Planka Server</p> Source code in <code>src/plankapy/v2/models/board.py</code> <pre><code>def sync(self) -&gt; None:\n    \"\"\"Sync the Board with the Planka Server\"\"\"\n    self.schema = self.endpoints.getBoard(self.id)['item']\n</code></pre>"},{"location":"v2/models/board/#plankapy.v2.models.board.Board.update","title":"update","text":"<pre><code>update(**board: Unpack[Request_updateBoard]) -&gt; None\n</code></pre> <p>Update the Board</p> Source code in <code>src/plankapy/v2/models/board.py</code> <pre><code>def update(self, **board: Unpack[paths.Request_updateBoard]) -&gt; None:\n    \"\"\"Update the Board\"\"\"\n    self.schema = self.endpoints.updateBoard(self.id, **board)['item']\n</code></pre>"},{"location":"v2/models/card-label/","title":"Card Label","text":"CLASS DESCRIPTION <code>CardLabel</code> <p>Python interface for Planka CardLabels</p>"},{"location":"v2/models/card-label/#plankapy.v2.models.card_label.CardLabel","title":"CardLabel","text":"<pre><code>CardLabel(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[CardLabel]</code></p> <p>Python interface for Planka CardLabels</p> Returned by: <ul> <li> Plankapy v2 models <ul> <li> Board <code></code>\u00a0Board <code></code>\u00a0card_labels </li> <li> Card <code></code>\u00a0Card <ul> <li> <code></code>\u00a0card_labels </li> <li> <code></code>\u00a0add_label </li> <li> <code></code>\u00a0add_labels </li> </ul> </li> <li> List <code></code>\u00a0List <code></code>\u00a0card_labels </li> </ul> </li> </ul> METHOD DESCRIPTION <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>delete</code> <p>Delete the CardLabel</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>card</code> <p>The Card the Label is associated with</p> <p> TYPE: <code>Card</code> </p> <code>created_at</code> <p>When the card-label association was created</p> <p> TYPE: <code>datetime</code> </p> <code>label</code> <p>The Label associated with the card</p> <p> TYPE: <code>Label</code> </p> <code>updated_at</code> <p>When the card-label association was last updated</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/card-label/#plankapy.v2.models.card_label.CardLabel.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/card-label/#plankapy.v2.models.card_label.CardLabel.card","title":"card  <code>property</code>","text":"<pre><code>card: Card\n</code></pre> <p>The Card the Label is associated with</p>"},{"location":"v2/models/card-label/#plankapy.v2.models.card_label.CardLabel.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>When the card-label association was created</p>"},{"location":"v2/models/card-label/#plankapy.v2.models.card_label.CardLabel.label","title":"label  <code>property</code>","text":"<pre><code>label: Label\n</code></pre> <p>The Label associated with the card</p>"},{"location":"v2/models/card-label/#plankapy.v2.models.card_label.CardLabel.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>When the card-label association was last updated</p>"},{"location":"v2/models/card-label/#plankapy.v2.models.card_label.CardLabel.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/card-label/#plankapy.v2.models.card_label.CardLabel.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the CardLabel</p> Source code in <code>src/plankapy/v2/models/card_label.py</code> <pre><code>def delete(self):\n    \"\"\"Delete the CardLabel\"\"\"\n    return self.endpoints.deleteCardLabel(cardId=self.schema['cardId'], labelId=self.schema['labelId'])\n</code></pre>"},{"location":"v2/models/card-label/#plankapy.v2.models.card_label.CardLabel.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/card-membership/","title":"Card Membership","text":"CLASS DESCRIPTION <code>CardMembership</code> <p>Python interface for Planka CardMemberships</p>"},{"location":"v2/models/card-membership/#plankapy.v2.models.card_membership.CardMembership","title":"CardMembership","text":"<pre><code>CardMembership(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[CardMembership]</code></p> <p>Python interface for Planka CardMemberships</p> Returned by: <ul> <li> Plankapy v2 models <ul> <li> Board <code></code>\u00a0Board <code></code>\u00a0card_memberships </li> <li> Card <code></code>\u00a0Card <ul> <li> <code></code>\u00a0card_memberships </li> <li> <code></code>\u00a0add_member </li> <li> <code></code>\u00a0add_members </li> </ul> </li> <li> List <code></code>\u00a0List <code></code>\u00a0card_memberships </li> </ul> </li> </ul> METHOD DESCRIPTION <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>delete</code> <p>Delete the CardMembership</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>card</code> <p>The Card the User is a member of</p> <p> TYPE: <code>Card</code> </p> <code>created_at</code> <p>When the card membership was created</p> <p> TYPE: <code>datetime</code> </p> <code>updated_at</code> <p>When the card membership was last updated</p> <p> TYPE: <code>datetime</code> </p> <code>user</code> <p>The User who is a member of the Card (Raise LookupError if the User is no longer on the Board)</p> <p> TYPE: <code>User</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/card-membership/#plankapy.v2.models.card_membership.CardMembership.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/card-membership/#plankapy.v2.models.card_membership.CardMembership.card","title":"card  <code>property</code>","text":"<pre><code>card: Card\n</code></pre> <p>The Card the User is a member of</p>"},{"location":"v2/models/card-membership/#plankapy.v2.models.card_membership.CardMembership.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>When the card membership was created</p>"},{"location":"v2/models/card-membership/#plankapy.v2.models.card_membership.CardMembership.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>When the card membership was last updated</p>"},{"location":"v2/models/card-membership/#plankapy.v2.models.card_membership.CardMembership.user","title":"user  <code>property</code>","text":"<pre><code>user: User\n</code></pre> <p>The User who is a member of the Card (Raise LookupError if the User is no longer on the Board)</p>"},{"location":"v2/models/card-membership/#plankapy.v2.models.card_membership.CardMembership.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/card-membership/#plankapy.v2.models.card_membership.CardMembership.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the CardMembership</p> Source code in <code>src/plankapy/v2/models/card_membership.py</code> <pre><code>def delete(self):\n    \"\"\"Delete the CardMembership\"\"\"\n    return self.endpoints.deleteCardMembership(userId=self.user.id, cardId=self.card.id)\n</code></pre>"},{"location":"v2/models/card-membership/#plankapy.v2.models.card_membership.CardMembership.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/card/","title":"Card","text":"CLASS DESCRIPTION <code>Card</code> <p>Python interface for Planka Cards</p> <code>Stopwatch</code> <p>Python interface for Planka Stopwatches</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card","title":"Card","text":"<pre><code>Card(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[Card]</code></p> <p>Python interface for Planka Cards</p> Returned by: <ul> <li> Plankapy v2 models <ul> <li> Action <code></code>\u00a0Action <code></code>\u00a0card </li> <li> Attachment <code></code>\u00a0Attachment <code></code>\u00a0card </li> <li> Board <code></code>\u00a0Board <ul> <li> <code></code>\u00a0archived_cards </li> <li> <code></code>\u00a0cards </li> <li> <code></code>\u00a0subscribed_cards </li> <li> <code></code>\u00a0trashed_cards </li> <li> <code></code>\u00a0filter </li> </ul> </li> <li> Card <code></code>\u00a0Card <ul> <li> <code></code>\u00a0duplicate </li> <li> <code></code>\u00a0move </li> <li> <code></code>\u00a0restore </li> </ul> </li> <li> Card Label <code></code>\u00a0CardLabel <code></code>\u00a0card </li> <li> Card Membership <code></code>\u00a0CardMembership <code></code>\u00a0card </li> <li> Comment <code></code>\u00a0Comment <code></code>\u00a0card </li> <li> Custom Field Group <code></code>\u00a0CustomFieldGroup <code></code>\u00a0card </li> <li> Custom Field Value <code></code>\u00a0CustomFieldValue <code></code>\u00a0card </li> <li> Label <code></code>\u00a0Label <code></code>\u00a0get_cards </li> <li> List <code></code>\u00a0List <ul> <li> <code></code>\u00a0cards </li> <li> <code></code>\u00a0archive_cards </li> <li> <code></code>\u00a0create_card </li> <li> <code></code>\u00a0filter </li> <li> <code></code>\u00a0move_cards </li> <li> <code></code>\u00a0shuffle </li> <li> <code></code>\u00a0sort </li> <li> <code></code>\u00a0sort_cards </li> </ul> </li> <li> Notification <code></code>\u00a0Notification <code></code>\u00a0card </li> <li> Task <code></code>\u00a0Task <code></code>\u00a0card </li> <li> Task List <code></code>\u00a0TaskList <code></code>\u00a0card </li> </ul> </li> </ul> Used by: <ul> <li> Plankapy v2 models <ul> <li> Board <code></code>\u00a0Board <code></code>\u00a0filter </li> <li> Card <code></code>\u00a0Stopwatch </li> <li> Custom Field Group <code></code>\u00a0CustomFieldGroup <code></code>\u00a0add_to_card </li> <li> List <code></code>\u00a0List <ul> <li> <code></code>\u00a0filter </li> <li> <code></code>\u00a0sort </li> </ul> </li> <li> Task List <code></code>\u00a0TaskList <code></code>\u00a0add_task </li> <li> User <code></code>\u00a0User <ul> <li> <code></code>\u00a0add_to_card </li> <li> <code></code>\u00a0remove_from_card </li> </ul> </li> </ul> </li> </ul> METHOD DESCRIPTION <code>add_attachment</code> <p>Add an Attachment to the card</p> <code>add_card_fields</code> <p>Add fields directly to a Card</p> <code>add_label</code> <p>Add a Label to the Card</p> <code>add_labels</code> <p>Add multiple Labels to the Card</p> <code>add_location</code> <p>Add a point location to a card as a FieldGroup</p> <code>add_member</code> <p>Add a User to the Card</p> <code>add_members</code> <p>Add multiple members to a Card</p> <code>add_task_list</code> <p>Add a TaskList to the Card</p> <code>comment</code> <p>Leave a comment as this user and mention any user included in the mentions list</p> <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>create_card_field_group</code> <p>Create a CustomFieldGroup in the Card</p> <code>create_task_list</code> <p>Create a NEW TaskList to the Card</p> <code>delete</code> <p>Delete the Card</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> <code>duplicate</code> <p>Duplicate the card in the current List</p> <code>get_field_values</code> <p>Get a mapping of CustomFields to CustomFieldValues</p> <code>move</code> <p>Move the card to a new list (default to top of new list)</p> <code>read_notifications</code> <p>Read all the current User's Notifications for the Card</p> <code>remove_label</code> <p>Remove the Label from the Card</p> <code>remove_labels</code> <p>Remove the Label from the Card</p> <code>remove_member</code> <p>Remove a User member from the Card</p> <code>remove_members</code> <p>Remove multiple members from a Card</p> <code>restore</code> <p>Restore the Card from arcive/trash to its previous list</p> <code>sync</code> <p>Sync the Card with the Planka server</p> <code>update</code> <p>Update the Card</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>actions</code> <p>Get all Actions associated with the Card</p> <p> TYPE: <code>list[Action]</code> </p> <code>attachments</code> <p>Get all Attachments associated with the Card</p> <p> TYPE: <code>list[Attachment]</code> </p> <code>board</code> <p>The Board the Card belongs to</p> <p> TYPE: <code>Board</code> </p> <code>card_labels</code> <p>Get all CardLabel associations for the Card</p> <p> TYPE: <code>list[CardLabel]</code> </p> <code>card_memberships</code> <p>Get all CardMemberships associated with the Card</p> <p> TYPE: <code>list[CardMembership]</code> </p> <code>comments</code> <p>Get all Comments on the Card</p> <p> TYPE: <code>list[Comment]</code> </p> <code>comments_count</code> <p>Total number of comments on the Card</p> <p> TYPE: <code>int</code> </p> <code>cover</code> <p>The Attachment used as cover (None if no cover)</p> <p> TYPE: <code>Attachment | None</code> </p> <code>created_at</code> <p>When the Card was created</p> <p> TYPE: <code>datetime</code> </p> <code>creator</code> <p>The User who Created the card</p> <p> TYPE: <code>User | None</code> </p> <code>custom_field_groups</code> <p>Get all CustomFieldGroups associated with the Card</p> <p> TYPE: <code>list[CustomFieldGroup]</code> </p> <code>custom_field_values</code> <p>Get all CustomFieldValues associated with the Card</p> <p> TYPE: <code>list[CustomFieldValue]</code> </p> <code>custom_fields</code> <p>Get all CustomFields associated with the Card</p> <p> TYPE: <code>list[CustomField]</code> </p> <code>description</code> <p>Detailed description of the Card</p> <p> TYPE: <code>str</code> </p> <code>due_date</code> <p>Due date for the card</p> <p> TYPE: <code>datetime | None</code> </p> <code>due_date_completed</code> <p>Whether the due date is completed</p> <p> TYPE: <code>bool</code> </p> <code>formal_name</code> <p>Get a formal name for the card <code>{Project}-&gt;{Board}-&gt;{List}-&gt;{Card}</code></p> <p> TYPE: <code>str</code> </p> <code>is_closed</code> <p>Whether the Card is closed</p> <p> TYPE: <code>bool</code> </p> <code>labels</code> <p>Get all Labels associated with the Card</p> <p> TYPE: <code>list[Label]</code> </p> <code>list</code> <p>The List the Card belongs to</p> <p> TYPE: <code>List</code> </p> <code>list_changed_at</code> <p>When the Card was last moved between Lists</p> <p> TYPE: <code>datetime</code> </p> <code>members</code> <p>Get all Users Assigned to the card</p> <p> TYPE: <code>list[User]</code> </p> <code>name</code> <p>Name/title of the Card</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the Card within the List</p> <p> TYPE: <code>int</code> </p> <code>prev_list</code> <p>The previous List the card was in (available when in archive or trash)</p> <p> TYPE: <code>List | None</code> </p> <code>project</code> <p>Get the Project that the card is in</p> <p> TYPE: <code>Project</code> </p> <code>stopwatch</code> <p>Stopwatch for time tracking</p> <p> TYPE: <code>Stopwatch</code> </p> <code>subscribed</code> <p>If the current user is subscribed to the Card</p> <p> TYPE: <code>bool</code> </p> <code>task_lists</code> <p>Get all TaskLists associated with the Card</p> <p> TYPE: <code>list[TaskList]</code> </p> <code>tasks</code> <p>Get all Tasks associated with the card</p> <p> TYPE: <code>list[Task]</code> </p> <code>type</code> <p>Type of the Card</p> <p> </p> <code>updated_at</code> <p>When the Card was last updated</p> <p> TYPE: <code>datetime</code> </p> <code>url</code> <p>The URL to the card</p> <p> TYPE: <code>str</code> </p> <code>users</code> <p>Get all Users associated with the Card (including Creator)</p> <p> TYPE: <code>list[User]</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.actions","title":"actions  <code>property</code>","text":"<pre><code>actions: list[Action]\n</code></pre> <p>Get all Actions associated with the Card</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.attachments","title":"attachments  <code>property</code>","text":"<pre><code>attachments: list[Attachment]\n</code></pre> <p>Get all Attachments associated with the Card</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.board","title":"board  <code>property</code>","text":"<pre><code>board: Board\n</code></pre> <p>The Board the Card belongs to</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.card_labels","title":"card_labels  <code>property</code>","text":"<pre><code>card_labels: list[CardLabel]\n</code></pre> <p>Get all CardLabel associations for the Card</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.card_memberships","title":"card_memberships  <code>property</code>","text":"<pre><code>card_memberships: list[CardMembership]\n</code></pre> <p>Get all CardMemberships associated with the Card</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.comments","title":"comments  <code>property</code>","text":"<pre><code>comments: list[Comment]\n</code></pre> <p>Get all Comments on the Card</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.comments_count","title":"comments_count  <code>property</code>","text":"<pre><code>comments_count: int\n</code></pre> <p>Total number of comments on the Card</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.cover","title":"cover  <code>property</code> <code>writable</code>","text":"<pre><code>cover: Attachment | None\n</code></pre> <p>The Attachment used as cover (None if no cover)</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>When the Card was created</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.creator","title":"creator  <code>property</code>","text":"<pre><code>creator: User | None\n</code></pre> <p>The User who Created the card</p> Note <p>If the creator is no longer on the Board, only Admins and Project Owners  can see them. Otherwise, None will be returned</p> <p>If the User has been deleted, Admins and Project Owners will get a Server error</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.custom_field_groups","title":"custom_field_groups  <code>property</code>","text":"<pre><code>custom_field_groups: list[CustomFieldGroup]\n</code></pre> <p>Get all CustomFieldGroups associated with the Card</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.custom_field_values","title":"custom_field_values  <code>property</code>","text":"<pre><code>custom_field_values: list[CustomFieldValue]\n</code></pre> <p>Get all CustomFieldValues associated with the Card</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.custom_fields","title":"custom_fields  <code>property</code>","text":"<pre><code>custom_fields: list[CustomField]\n</code></pre> <p>Get all CustomFields associated with the Card</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.description","title":"description  <code>property</code> <code>writable</code>","text":"<pre><code>description: str\n</code></pre> <p>Detailed description of the Card</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.due_date","title":"due_date  <code>property</code> <code>writable</code>","text":"<pre><code>due_date: datetime | None\n</code></pre> <p>Due date for the card</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.due_date_completed","title":"due_date_completed  <code>property</code> <code>writable</code>","text":"<pre><code>due_date_completed: bool\n</code></pre> <p>Whether the due date is completed</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.formal_name","title":"formal_name  <code>property</code>","text":"<pre><code>formal_name: str\n</code></pre> <p>Get a formal name for the card <code>{Project}-&gt;{Board}-&gt;{List}-&gt;{Card}</code></p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.is_closed","title":"is_closed  <code>property</code>","text":"<pre><code>is_closed: bool\n</code></pre> <p>Whether the Card is closed</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.labels","title":"labels  <code>property</code>","text":"<pre><code>labels: list[Label]\n</code></pre> <p>Get all Labels associated with the Card</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.list","title":"list  <code>property</code> <code>writable</code>","text":"<pre><code>list: List\n</code></pre> <p>The List the Card belongs to</p> Returned by: <ul> <li> Plankapy v2 models Card <code></code>\u00a0Card <ul> <li> <code></code>\u00a0actions </li> <li> <code></code>\u00a0attachments </li> <li> <code></code>\u00a0card_labels </li> <li> <code></code>\u00a0card_memberships </li> <li> <code></code>\u00a0comments </li> <li> <code></code>\u00a0custom_field_groups </li> <li> <code></code>\u00a0custom_field_values </li> <li> <code></code>\u00a0custom_fields </li> <li> <code></code>\u00a0labels </li> <li> <code></code>\u00a0members </li> <li> <code></code>\u00a0task_lists </li> <li> <code></code>\u00a0tasks </li> <li> <code></code>\u00a0users </li> <li> <code></code>\u00a0add_labels </li> <li> <code></code>\u00a0add_members </li> <li> <code></code>\u00a0read_notifications </li> <li> <code></code>\u00a0remove_labels </li> <li> <code></code>\u00a0remove_members </li> </ul> </li> </ul>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.list_changed_at","title":"list_changed_at  <code>property</code>","text":"<pre><code>list_changed_at: datetime\n</code></pre> <p>When the Card was last moved between Lists</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.members","title":"members  <code>property</code>","text":"<pre><code>members: list[User]\n</code></pre> <p>Get all Users Assigned to the card</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the Card</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.position","title":"position  <code>property</code> <code>writable</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the Card within the List</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.prev_list","title":"prev_list  <code>property</code>","text":"<pre><code>prev_list: List | None\n</code></pre> <p>The previous List the card was in (available when in archive or trash)</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.project","title":"project  <code>property</code>","text":"<pre><code>project: Project\n</code></pre> <p>Get the Project that the card is in</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.stopwatch","title":"stopwatch  <code>property</code>","text":"<pre><code>stopwatch: Stopwatch\n</code></pre> <p>Stopwatch for time tracking</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.subscribed","title":"subscribed  <code>property</code> <code>writable</code>","text":"<pre><code>subscribed: bool\n</code></pre> <p>If the current user is subscribed to the Card</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.task_lists","title":"task_lists  <code>property</code>","text":"<pre><code>task_lists: list[TaskList]\n</code></pre> <p>Get all TaskLists associated with the Card</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: list[Task]\n</code></pre> <p>Get all Tasks associated with the card</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.type","title":"type  <code>property</code> <code>writable</code>","text":"<pre><code>type\n</code></pre> <p>Type of the Card</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>When the Card was last updated</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.url","title":"url  <code>property</code>","text":"<pre><code>url: str\n</code></pre> <p>The URL to the card</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.users","title":"users  <code>property</code>","text":"<pre><code>users: list[User]\n</code></pre> <p>Get all Users associated with the Card (including Creator)</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_attachment","title":"add_attachment","text":"<pre><code>add_attachment(attachment: str | bytes, *, cover: bool = False, download_url: bool = False, name: str | None = None) -&gt; Attachment\n</code></pre> <p>Add an Attachment to the card</p> PARAMETER DESCRIPTION <p>The URL or raw bytes of the attachment</p> <p> TYPE: <code>str | bytes</code> </p> <p>Set the new attachment as the cover of the card</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>If a link is used, download the file from the link and attach it (default: <code>False</code>)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>The optional name of the attachment (default is <code>hash() + mimetypes.guess_type(attachment)</code>)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Attachment</code> <p>Attachment</p> RAISES DESCRIPTION <code>HTTPStatusError</code> <p>If the url cannot be downloaded</p> <code>OSError</code> <p>If a local file cannot be opened and read</p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>def add_attachment(self, attachment: str | bytes, \n                   *, \n                   cover: bool=False, \n                   download_url: bool=False,\n                   name: str | None=None) -&gt; Attachment:\n    \"\"\"Add an Attachment to the card\n\n    Args:\n        attachment (str | bytes): The URL or raw bytes of the attachment\n        cover (bool): Set the new attachment as the cover of the card\n        download_url (bool): If a link is used, download the file from the link and attach it (default: `False`)\n        name (str | None): The optional name of the attachment (default is `hash() + mimetypes.guess_type(attachment)`)\n\n    Returns:\n        Attachment\n\n    Raises:\n        HTTPStatusError: If the url cannot be downloaded\n        OSError: If a local file cannot be opened and read\n    \"\"\"\n    # Force a PermissionError early if the user isn't a board editor\n    if self.session.current_id not in [e.id for e in self.board.editors]:\n        self.endpoints.createAttachment(self.id, type='link', url='nourl', name='NO_PERMISSION')\n\n    # Deferred import of mimetypes that is only used here\n    # This function takes so long anyways so the import delay \n    # isn't noticable\n    import mimetypes\n\n    # Handle filepath or URL\n    mime_type = None\n    extension = '.bin'\n    if isinstance(attachment, str):\n\n        # Guess URL file type\n        if attachment.startswith('http'):\n            mime_type, *_ = mimetypes.guess_type(attachment)\n            mime_type = mime_type or 'application/octet-stream'\n            extension = mimetypes.guess_extension(mime_type) or '.bin'\n\n            # Download the file if requested\n            if download_url:\n                try:\n                    req = self.client.get(attachment)\n                    attachment = req.raise_for_status().read()\n                except HTTPStatusError as status_error:\n                    status_error.add_note(f'Unable to download attachment from {attachment}')\n                    raise\n\n            # Attach a link otherwise\n            else:\n                return Attachment(\n                    self.endpoints.createAttachment(\n                        self.id, \n                        type='link', \n                        url=attachment, \n                        name=name or f'{name or hash(attachment)}{extension}')['item'], \n                    self.session\n                )\n\n        # Guess local file type\n        # And read Bytes\n        else:\n            mime_type, *_ = mimetypes.guess_file_type(attachment)\n            mime_type = mime_type or 'application/octet-stream'\n            attachment = open(attachment, 'rb').read()\n\n    mime_type = mime_type or 'application/octet-stream'\n    extension = mimetypes.guess_extension(mime_type) or '.bin'\n    name = f'{name or hash(attachment)}'\n    if not name.endswith(extension):\n        name = f'{name}{extension}'        \n    a = Attachment(\n        self.endpoints.createAttachment(\n            self.id, \n            name=name,\n            type='file',\n            file=bytes(attachment),\n            requestId=str(abs(hash(datetime.now().isoformat()))),\n            mime_type=mime_type,\n        )['item'], \n        self.session\n    )\n    if cover:\n        self.cover = a\n    return a\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_attachment(attachment)","title":"<code>attachment</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_attachment(cover)","title":"<code>cover</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_attachment(download_url)","title":"<code>download_url</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_attachment(name)","title":"<code>name</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_card_fields","title":"add_card_fields","text":"<pre><code>add_card_fields(*fields: str, group: str = 'Fields', position: Position = 'top') -&gt; CustomFieldGroup\n</code></pre> <p>Add fields directly to a Card</p> PARAMETER DESCRIPTION <p>Varargs of the Fieldnames to add to the Card</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <p>An optional FieldGroup name to add the fields to (default: <code>Fields</code>)</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Fields'</code> </p> <p>The position to add the Card field group at (default: <code>top</code>)</p> <p> TYPE: <code>Position</code> DEFAULT: <code>'top'</code> </p> RETURNS DESCRIPTION <code>CustomFieldGroup</code> <p>CustomFieldGroup</p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>def add_card_fields(self, *fields: str,\n                    group: str='Fields', \n                    position: Position='top') -&gt; CustomFieldGroup:\n    \"\"\"Add fields directly to a Card\n\n    Args:\n        *fields: Varargs of the Fieldnames to add to the Card\n        group: An optional FieldGroup name to add the fields to (default: `Fields`)\n        position: The position to add the Card field group at (default: `top`)\n\n    Returns:\n        CustomFieldGroup\n    \"\"\"\n    # Get an existing group if name matches\n    cfg = (\n        self.custom_field_groups[{'name': group}].dpop() \n        or self.create_card_field_group(group, position)\n    )\n    # Add any fields that don't already exist in the Group\n    cfg.add_fields(*(set(fields) ^ set(cfg.custom_fields.extract('name'))))\n    return cfg\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_card_fields(*fields)","title":"<code>*fields</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_card_fields(group)","title":"<code>group</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_card_fields(position)","title":"<code>position</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_label","title":"add_label","text":"<pre><code>add_label(label: Label, *, add_to_board: bool = False) -&gt; CardLabel\n</code></pre> <p>Add a Label to the Card</p> PARAMETER DESCRIPTION <p>The Label to add to the card</p> <p> TYPE: <code>Label</code> </p> <p>If the Label is not in the board, add it (default: <code>False</code>)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>CardLabel</code> <p>The CardLabel relationship</p> <p> TYPE: <code>CardLabel</code> </p> Note <p>When using <code>add_to_board</code> The label position will default to the top of the label list</p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>def add_label(self, label: Label, \n              *, \n              add_to_board: bool=False) -&gt; CardLabel:\n    \"\"\"Add a Label to the Card\n\n    Args:\n        label (Label): The Label to add to the card\n        add_to_board (bool): If the Label is not in the board, add it (default: `False`)\n\n    Returns:\n        CardLabel: The CardLabel relationship\n\n    Note:\n        When using `add_to_board` The label position will default to the top of the label list\n    \"\"\"\n    # Check if label is already on card\n    for card_label in self.card_labels:\n        if label.id == card_label.schema['labelId']:\n            return card_label\n\n    # Handle adding Label if it doesn't exist\n    if label not in self.board.labels and add_to_board:\n        label = label.add_to_board(self.board)\n\n    # Create new CardLabel relationship\n    return CardLabel(self.endpoints.createCardLabel(self.id, labelId=label.id)['item'], self.session)\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_label(label)","title":"<code>label</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_label(add_to_board)","title":"<code>add_to_board</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_labels","title":"add_labels","text":"<pre><code>add_labels(labels: Sequence[Label], *, add_to_board: bool = False) -&gt; list[CardLabel]\n</code></pre> <p>Add multiple Labels to the Card</p> PARAMETER DESCRIPTION <p>The Labels to add (must be associated with the card.board)</p> <p> TYPE: <code>Sequence[Label]</code> </p> <p>If a Label is not in the board, add it (default: <code>False</code>)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>list[CardLabel]</code> <p>list[CardLabel]: The added CardLabel relations</p> Note <p>Any labels that are not on the Card's Board will be skipped</p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>@model_list\ndef add_labels(self, labels: Sequence[Label], \n               *,\n               add_to_board: bool=False) -&gt; list[CardLabel]:\n    \"\"\"Add multiple Labels to the Card\n\n    Args:\n        labels (Sequence[Label]): The Labels to add (must be associated with the card.board)\n        add_to_board (bool): If a Label is not in the board, add it (default: `False`)\n\n    Returns:\n        list[CardLabel]: The added CardLabel relations\n\n    Note:\n        Any labels that are not on the Card's Board will be skipped\n    \"\"\"\n    return [\n        self.add_label(\n            label, \n            add_to_board=add_to_board\n        )\n        for label in labels\n    ]\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_labels(labels)","title":"<code>labels</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_labels(add_to_board)","title":"<code>add_to_board</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_location","title":"add_location","text":"<pre><code>add_location(lat: float, lon: float, name: str, position: Position | int) -&gt; CustomFieldGroup\n</code></pre> <p>Add a point location to a card as a FieldGroup</p> PARAMETER DESCRIPTION <p>Latitude of the location</p> <p> TYPE: <code>float</code> </p> <p>Longitude of the location</p> <p> TYPE: <code>float</code> </p> <p>Name of the location (FieldGroup name)</p> <p> TYPE: <code>str</code> </p> <p>Position of the FieldGroup within the Card (default: <code>top</code>)</p> <p> TYPE: <code>Position | int</code> </p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>def add_location(self, lat: float, lon: float, name: str, position: Position | int) -&gt; CustomFieldGroup:\n    \"\"\"Add a point location to a card as a FieldGroup\n\n    Args:\n        lat (float): Latitude of the location\n        lon (float): Longitude of the location\n        name (str): Name of the location (FieldGroup name)\n        position (Position | int): Position of the FieldGroup within the Card (default: `top`)\n    \"\"\"\n    loc_group = self.add_card_fields('latitude', 'longitude', group=name, position=position)\n    for field in loc_group.custom_field_values:\n        if field.custom_field.name == 'latitude':\n            field.content = str(lat)\n        elif field.custom_field.name == 'longitude':\n            field.content = str(lon)\n    return loc_group\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_location(lat)","title":"<code>lat</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_location(lon)","title":"<code>lon</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_location(name)","title":"<code>name</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_location(position)","title":"<code>position</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_member","title":"add_member","text":"<pre><code>add_member(user: User, *, add_to_board: bool = False, role: BoardRole = 'viewer', can_comment: bool = False) -&gt; CardMembership\n</code></pre> <p>Add a User to the Card</p> PARAMETER DESCRIPTION <p>The User to add to the Card</p> <p> TYPE: <code>User</code> </p> <p>Add the User to the Board if they are not already a member</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>If User is added to board, set role (default: <code>viewer</code>)</p> <p> TYPE: <code>BoardRole</code> DEFAULT: <code>'viewer'</code> </p> <p>If User is added as a <code>viewer</code>, set commenting status (default: <code>False</code>)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Note <p>Default options for adding to Board abide by least privilege so role and comment must be set</p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>def add_member(self, user: User, \n               *, \n               add_to_board: bool=False, \n               role: BoardRole='viewer', \n               can_comment: bool=False) -&gt; CardMembership:\n    \"\"\"Add a User to the Card\n\n    Args:\n        user (User): The User to add to the Card\n        add_to_board (bool): Add the User to the Board if they are not already a member\n        role (BoardRole): If User is added to board, set role (default: `viewer`)\n        can_comment (bool): If User is added as a `viewer`, set commenting status (default: `False`)\n\n    Note:\n        Default options for adding to Board abide by least privilege so role and comment must be set \n    \"\"\"\n    # User is already a member\n    for membership in self.card_memberships:\n        if membership.user == user:\n            return membership\n\n    # Add the user to the board\n    if user not in self.board.users and add_to_board:\n        self.board.add_member(user, role=role, can_comment=can_comment if role == 'viewer' else True)\n\n    return CardMembership(self.endpoints.createCardMembership(self.id, userId=user.id)['item'], self.session)\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_member(user)","title":"<code>user</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_member(add_to_board)","title":"<code>add_to_board</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_member(role)","title":"<code>role</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_member(can_comment)","title":"<code>can_comment</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_members","title":"add_members","text":"<pre><code>add_members(users: Sequence[User], *, add_to_board: bool = False, role: BoardRole = 'viewer', can_comment: bool = False) -&gt; list[CardMembership]\n</code></pre> <p>Add multiple members to a Card</p> PARAMETER DESCRIPTION <p>The Users to add to the Card</p> <p> TYPE: <code>Sequence[User]</code> </p> <p>Add the User to the Board if they are not already a member</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>If User is added to board, set role (default: <code>viewer</code>)</p> <p> TYPE: <code>Literal['viewer', 'editor']</code> DEFAULT: <code>'viewer'</code> </p> <p>If User is added as a <code>viewer</code>, set commenting status (default: <code>False</code>)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Note <p>Default options for adding to Board abide by least privilege so role and comment must be set</p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>@model_list\ndef add_members(self, users: Sequence[User], \n                *, \n                add_to_board: bool=False, \n                role: BoardRole='viewer', \n                can_comment: bool=False) -&gt; list[CardMembership]:\n    \"\"\"Add multiple members to a Card\n\n    Args:\n        users (Sequence[User]): The Users to add to the Card\n        add_to_board (bool): Add the User to the Board if they are not already a member\n        role (Literal['viewer', 'editor']): If User is added to board, set role (default: `viewer`)\n        can_comment (bool): If User is added as a `viewer`, set commenting status (default: `False`)\n\n    Note:\n        Default options for adding to Board abide by least privilege so role and comment must be set\n\n    \"\"\"\n    return [\n        self.add_member(\n            user, \n            add_to_board=add_to_board, \n            role=role, \n            can_comment=can_comment,\n        )\n        for user in users\n    ]\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_members(users)","title":"<code>users</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_members(add_to_board)","title":"<code>add_to_board</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_members(role)","title":"<code>role</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_members(can_comment)","title":"<code>can_comment</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_task_list","title":"add_task_list","text":"<pre><code>add_task_list(task_list: TaskList, *, name: str | None = None, position: Position | int = 'top', show_on_card: bool | None = None, hide_completed: bool | None = None) -&gt; TaskList\n</code></pre> <p>Add a TaskList to the Card</p> PARAMETER DESCRIPTION <p>The TaskList to add</p> <p> TYPE: <code>TaskList</code> </p> <p>Name override, None will use input name (default: <code>None</code>)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <p>The position of the TaskList in the Card (default: <code>top</code>)</p> <p> TYPE: <code>Position | int</code> </p> <p>bool | None): Show On Card override, None will use input show (default: <code>None</code>)</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> <p>bool | None): Hide Completed override , None will use input hide (default: <code>None</code>)</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>TaskList</code> <p>The TaskList</p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>def add_task_list(self, task_list: TaskList, \n                  *, \n                  name: str | None=None,\n                  position: Position | int='top',\n                  show_on_card: bool | None=None,\n                  hide_completed: bool | None=None) -&gt; TaskList:\n    \"\"\"Add a TaskList to the Card\n\n    Args:\n        task_list (TaskList): The TaskList to add\n        name (str | None): Name override, None will use input name (default: `None`)\n        postion (Position | int): The position of the TaskList in the Card (default: `top`)\n        show_on_card: bool | None): Show On Card override, None will use input show (default: `None`)\n        hide_completed: bool | None): Hide Completed override , None will use input hide (default: `None`)\n\n    Returns:\n        The TaskList \n    \"\"\"\n    return self.create_task_list(\n        name=name or task_list.name,\n        position=get_position(self.task_lists, position),\n        show_on_card=show_on_card or task_list.show_on_front_of_card,\n        hide_completed=hide_completed or task_list.hide_completed_tasks, \n    )\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_task_list(task_list)","title":"<code>task_list</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_task_list(name)","title":"<code>name</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_task_list(postion)","title":"<code>postion</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_task_list(show_on_card)","title":"<code>show_on_card</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.add_task_list(hide_completed)","title":"<code>hide_completed</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.comment","title":"comment","text":"<pre><code>comment(comment: str, *, mentions: Sequence[User] | None = None) -&gt; Comment\n</code></pre> <p>Leave a comment as this user and mention any user included in the mentions list</p> PARAMETER DESCRIPTION <p>The text body of the comment (<code>@[name|username|email]</code> will mention)</p> <p> </p> <p>A sequence of Users that will be mentioned after the body</p> <p> TYPE: <code>Sequence[User] | None</code> DEFAULT: <code>None</code> </p> Note <p>If a user is explicitly mentioned in the comment, they will be removed from the  suffix mention. e.g.  <pre><code>&gt;&gt;&gt; card.comment(\n...     'Fix this @user1, then send to @user2', \n...     mentions=[user1, user2, user3]\n... )\n'''Fix this @user1, then send to @user2\n@user3'''\n</code></pre></p> Example <pre><code>    &gt;&gt;&gt; card.comment('Need Fix', mentions=card2.users)\n    # Comment from current user On Card:\n    Need Fix\n    @user1\n    @user2\n</code></pre> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>def comment(self, comment: str, *, mentions: Sequence[User]|None=None) -&gt; Comment:\n    \"\"\"Leave a comment as this user and mention any user included in the mentions list\n\n    Args:\n        text: The text body of the comment (`@[name|username|email]` will mention)\n        mentions: A sequence of Users that will be mentioned after the body\n\n    Note:\n        If a user is explicitly mentioned in the comment, they will be removed from the \n        suffix mention. e.g. \n        ```python\n        &gt;&gt;&gt; card.comment(\n        ...     'Fix this @user1, then send to @user2', \n        ...     mentions=[user1, user2, user3]\n        ... )\n        '''Fix this @user1, then send to @user2\n        @user3'''\n        ```\n\n    Example:\n        ```python\n            &gt;&gt;&gt; card.comment('Need Fix', mentions=card2.users)\n            # Comment from current user On Card:\n            Need Fix\n            @user1\n            @user2\n        ```\n    \"\"\"\n    # Store inline mentions to prevent additional mention in postfix\n    _mentioned: list[User] = []\n    if '@' in comment:\n        for u in self.board.users:\n            # Replace raw @ mentions with markdown formatted mentions\n            # Allow mentioning by name, username, or email\n            if f'@{u.email}' in comment:\n                comment = comment.replace(f'@{u.email}', f'@[{u.email}]({u.id})')\n                _mentioned.append(u)\n            elif f'@{u.name}' in comment:\n                comment = comment.replace(f'@{u.name}', f'@[{u.name}]({u.id})')\n                _mentioned.append(u)\n            elif f'@{u.username}' in comment:\n                comment = comment.replace(f'@{u.username}', f'@[{u.username}]({u.id})')\n                _mentioned.append(u)\n\n    # Add additional postfix mentions\n    if mentions:\n        mentions = [m for m in mentions if m not in _mentioned]\n        comment = '\\n'.join([comment, *[f\"@[{u.name}]({u.id})\" for u in mentions or []]])\n    return Comment(self.endpoints.createComment(self.id, text=comment)['item'], self.session)\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.comment(text)","title":"<code>text</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.comment(mentions)","title":"<code>mentions</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.create_card_field_group","title":"create_card_field_group","text":"<pre><code>create_card_field_group(name: str, position: Position = 'top') -&gt; CustomFieldGroup\n</code></pre> <p>Create a CustomFieldGroup in the Card</p> PARAMETER DESCRIPTION <p>The name of the group</p> <p> TYPE: <code>str</code> </p> <p>The position of the new group</p> <p> TYPE: <code>Position</code> DEFAULT: <code>'top'</code> </p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>def create_card_field_group(self, name: str, position: Position='top') -&gt; CustomFieldGroup:\n    \"\"\"Create a CustomFieldGroup in the Card\n\n    Args:\n        name: The name of the group\n        position: The position of the new group\n    \"\"\"\n    return CustomFieldGroup(\n            self.endpoints.createCardCustomFieldGroup(\n                self.id, \n                name=name, \n                position=get_position(self.custom_field_groups, position))['item'], \n            self.session\n        )\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.create_card_field_group(name)","title":"<code>name</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.create_card_field_group(position)","title":"<code>position</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.create_task_list","title":"create_task_list","text":"<pre><code>create_task_list(*, name: str, position: Position | int = 'top', show_on_card: bool = False, hide_completed: bool = False) -&gt; TaskList\n</code></pre> <p>Create a NEW TaskList to the Card</p> PARAMETER DESCRIPTION <p>Name for the TaskList</p> <p> </p> <p>The position of the TaskList in the Card (default: <code>top</code>)</p> <p> TYPE: <code>Position | int</code> </p> <p>bool: Show TaskList on the front of the card (default: <code>False</code>)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>bool: Hide completed tasks (default: <code>False</code>)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>TaskList</code> <p>The TaskList</p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>def create_task_list(self, \n                  *, \n                  name: str,\n                  position: Position | int='top',\n                  show_on_card: bool=False,\n                  hide_completed: bool=False) -&gt; TaskList:\n    \"\"\"Create a NEW TaskList to the Card\n\n    Args:\n        name str: Name for the TaskList\n        postion (Position | int): The position of the TaskList in the Card (default: `top`)\n        show_on_card: bool: Show TaskList on the front of the card (default: `False`)\n        hide_completed: bool: Hide completed tasks (default: `False`)\n\n    Returns:\n        The TaskList \n    \"\"\"\n    return TaskList(\n        self.endpoints.createTaskList(\n            self.id, \n            position=get_position(self.task_lists, position), \n            name=name, \n            showOnFrontOfCard=show_on_card, \n            hideCompletedTasks=hide_completed,\n        )['item'], \n        self.session\n    )\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.create_task_list(name str)","title":"<code>name str</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.create_task_list(postion)","title":"<code>postion</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.create_task_list(show_on_card)","title":"<code>show_on_card</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.create_task_list(hide_completed)","title":"<code>hide_completed</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the Card</p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>def delete(self):\n    \"\"\"Delete the Card\"\"\"\n    return self.endpoints.deleteCard(self.id)\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.duplicate","title":"duplicate","text":"<pre><code>duplicate(position: Position = 'top', *, name: str | None = None) -&gt; Card\n</code></pre> <p>Duplicate the card in the current List</p> PARAMETER DESCRIPTION <p>The position to place the new Card in (default: <code>top</code>)</p> <p> TYPE: <code>Position</code> DEFAULT: <code>'top'</code> </p> <p>An optional name to give the new Card (default <code>{name} (copy)</code>)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>def duplicate(self, position: Position = 'top', *, name: str|None=None) -&gt; Card:\n    \"\"\"Duplicate the card in the current List\n\n    Args:\n        position (Position): The position to place the new Card in (default: `top`)\n        name (str|None): An optional name to give the new Card (default `{name} (copy)`)\n    \"\"\"\n    position = get_position(self.list.cards, position)\n    return Card(\n        self.endpoints.duplicateCard(\n            self.id, \n            position=position, \n            name=name or f'{self.name} (copy)'\n        )['item'], \n        self.session\n    )\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.duplicate(position)","title":"<code>position</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.duplicate(name)","title":"<code>name</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.get_field_values","title":"get_field_values","text":"<pre><code>get_field_values(*, with_groups: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Get a mapping of CustomFields to CustomFieldValues</p> PARAMETER DESCRIPTION <p>If set to <code>True</code>,  return a nested dict with <code>{group: {field: value, ...}, ...}</code>, otherwise <code>{field: value ...}</code> (default: <code>False</code>)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>def get_field_values(self, *, with_groups: bool=False) -&gt; dict[str, Any]:\n    \"\"\"Get a mapping of CustomFields to CustomFieldValues\n\n    Args:\n        with_groups (bool): If set to `True`, \n            return a nested dict with `{group: {field: value, ...}, ...}`, otherwise `{field: value ...}` (default: `False`)\n    \"\"\"\n    if with_groups:\n        return {\n            cfg.name: {cfv.custom_field.name: cfv.content for cfv in cfg.custom_field_values}\n            for cfg in self.custom_field_groups\n        }\n    else:\n        return {\n            cfv.custom_field.name: cfv.content\n            for cfv in self.custom_field_values\n        }\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.get_field_values(with_groups)","title":"<code>with_groups</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.move","title":"move","text":"<pre><code>move(list: List, position: Position = 'top') -&gt; Card\n</code></pre> <p>Move the card to a new list (default to top of new list)</p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>def move(self, list: List, position: Position = 'top') -&gt; Card:\n    \"\"\"Move the card to a new list (default to top of new list)\"\"\"\n    self.update(\n        listId=list.id, \n        boardId=list.board.id, \n        position=get_position(list.cards, position),\n    )\n    return self\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.read_notifications","title":"read_notifications","text":"<pre><code>read_notifications() -&gt; list[Notification]\n</code></pre> <p>Read all the current User's Notifications for the Card</p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>@model_list\ndef read_notifications(self) -&gt; list[Notification]:\n    \"\"\"Read all the current User's Notifications for the Card\"\"\"\n    return [Notification(n, self.session) for n in self.endpoints.readCardNotifications(self.id)['included']['notifications']]\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.remove_label","title":"remove_label","text":"<pre><code>remove_label(label: Label) -&gt; Label | None\n</code></pre> <p>Remove the Label from the Card</p> PARAMETER DESCRIPTION <p>The label to remove (must be associated with the Card)</p> <p> TYPE: <code>Label</code> </p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>def remove_label(self, label: Label) -&gt; Label | None:\n    \"\"\"Remove the Label from the Card\n\n    Args:\n        label (Label): The label to remove (must be associated with the Card)\n    \"\"\"\n    for card_label in self.card_labels:\n        if card_label.label == label:\n            card_label.delete()\n            return label\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.remove_label(label)","title":"<code>label</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.remove_labels","title":"remove_labels","text":"<pre><code>remove_labels(labels: Sequence[Label]) -&gt; list[Label]\n</code></pre> <p>Remove the Label from the Card</p> PARAMETER DESCRIPTION <p>The labels to remove (must be associated with the Card)</p> <p> TYPE: <code>Sequence[Label]</code> </p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>@model_list\ndef remove_labels(self, labels: Sequence[Label]) -&gt; list[Label]:\n    \"\"\"Remove the Label from the Card\n\n    Args:\n        labels (Sequence[Label]): The labels to remove (must be associated with the Card)\n    \"\"\"\n    return [removed for label in labels if (removed := self.remove_label(label))]\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.remove_labels(labels)","title":"<code>labels</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.remove_member","title":"remove_member","text":"<pre><code>remove_member(user: User) -&gt; User | None\n</code></pre> <p>Remove a User member from the Card</p> PARAMETER DESCRIPTION <p>The User to remove</p> <p> TYPE: <code>User</code> </p> RETURNS DESCRIPTION <code>User | None</code> <p>The removed User or None if tha User was not a member</p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>def remove_member(self, user: User) -&gt; User | None:\n    \"\"\"Remove a User member from the Card\n\n    Args:\n        user (User): The User to remove\n\n    Returns:\n        (User | None): The removed User or None if tha User was not a member\n    \"\"\"\n    for cm in self.card_memberships:\n        if cm.user == user:\n            cm.delete()\n            return user\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.remove_member(user)","title":"<code>user</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.remove_members","title":"remove_members","text":"<pre><code>remove_members(users: Sequence[User]) -&gt; list[User]\n</code></pre> <p>Remove multiple members from a Card</p> PARAMETER DESCRIPTION <p>The Users to remove from the Card</p> <p> TYPE: <code>Sequence[User]</code> </p> RETURNS DESCRIPTION <code>list[User]</code> <p>list[User]: The Users that were removed from the card</p> Note <p>If a User in the <code>users</code> sequence is not a member of the card,  They will be excluded from this list</p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>@model_list\ndef remove_members(self, users: Sequence[User]) -&gt; list[User]:\n    \"\"\"Remove multiple members from a Card\n\n    Args:\n        users (Sequence[User]): The Users to remove from the Card\n\n    Returns:\n        list[User]: The Users that were removed from the card\n\n    Note:\n        If a User in the `users` sequence is not a member of the card, \n        They will be excluded from this list\n    \"\"\"\n    return [\n        user\n        for user in users\n        if self.remove_member(user) is not None\n    ]\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.remove_members(users)","title":"<code>users</code>","text":""},{"location":"v2/models/card/#plankapy.v2.models.card.Card.restore","title":"restore","text":"<pre><code>restore(position: Position = 'top') -&gt; Card\n</code></pre> <p>Restore the Card from arcive/trash to its previous list</p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>def restore(self, position: Position='top') -&gt; Card:\n    \"\"\"Restore the Card from arcive/trash to its previous list\"\"\"\n    if self.prev_list is not None:\n        self.move(self.prev_list, position)\n    return self\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.sync","title":"sync","text":"<pre><code>sync()\n</code></pre> <p>Sync the Card with the Planka server</p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>def sync(self):\n    \"\"\"Sync the Card with the Planka server\"\"\"\n    self.schema = self.endpoints.getCard(self.id)['item']\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Card.update","title":"update","text":"<pre><code>update(**kwargs: Unpack[Request_updateCard])\n</code></pre> <p>Update the Card</p> Note <p>dueDate can be set using ISO 8601 string or datetime object</p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>def update(self, **kwargs: Unpack[paths.Request_updateCard]):\n    \"\"\"Update the Card\n\n    Note:\n        dueDate can be set using ISO 8601 string or datetime object\n    \"\"\"\n    # Convert the dueDate to a iso string if a datetime is passed\n    if 'dueDate' in kwargs:\n        kwargs['dueDate'] = str(kwargs['dueDate'])\n    self.schema = self.endpoints.updateCard(self.id, **kwargs)['item']\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Stopwatch","title":"Stopwatch","text":"<pre><code>Stopwatch(card: Card)\n</code></pre> <p>Python interface for Planka Stopwatches</p> Returned by: <ul> <li> Plankapy v2 models Card <code></code>\u00a0Card <code></code>\u00a0stopwatch </li> </ul> METHOD DESCRIPTION <code>start</code> <p>Start the stopwatch and return the current datetime (None if the stopwatch is started)</p> <code>stop</code> <p>Stop a running stopwatch and return the time it was last started</p> <code>update</code> <p>Update the stopwatch</p> ATTRIBUTE DESCRIPTION <code>enabled</code> <p>If the stopwatch is enabled for the card (visible on front)</p> <p> </p> <code>is_running</code> <p>If the stopwatch is currently running</p> <p> TYPE: <code>bool</code> </p> <code>last_started</code> <p>The time a running stopwatch was started (None if the stopwatch is stopped)</p> <p> TYPE: <code>datetime | None</code> </p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>def __init__(self, card: Card) -&gt; None:\n    self.card = card\n    self.tz = card.session.timezone\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Stopwatch.enabled","title":"enabled  <code>property</code> <code>writable</code>","text":"<pre><code>enabled\n</code></pre> <p>If the stopwatch is enabled for the card (visible on front)</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Stopwatch.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>If the stopwatch is currently running</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Stopwatch.last_started","title":"last_started  <code>property</code>","text":"<pre><code>last_started: datetime | None\n</code></pre> <p>The time a running stopwatch was started (None if the stopwatch is stopped)</p>"},{"location":"v2/models/card/#plankapy.v2.models.card.Stopwatch.start","title":"start","text":"<pre><code>start() -&gt; datetime | None\n</code></pre> <p>Start the stopwatch and return the current datetime (None if the stopwatch is started)</p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>def start(self) -&gt; datetime | None:\n    \"\"\"Start the stopwatch and return the current datetime (None if the stopwatch is started)\"\"\"\n    if self.is_running:\n       return None\n    return datetime.now(tz=self.card.session.timezone)\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Stopwatch.stop","title":"stop","text":"<pre><code>stop() -&gt; datetime | None\n</code></pre> <p>Stop a running stopwatch and return the time it was last started</p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>def stop(self) -&gt; datetime | None:\n    \"\"\"Stop a running stopwatch and return the time it was last started\"\"\"\n    started = self.last_started\n    self.update(started_at=None)\n    return started\n</code></pre>"},{"location":"v2/models/card/#plankapy.v2.models.card.Stopwatch.update","title":"update","text":"<pre><code>update(started_at: datetime | str | None = None, total: timedelta | int | None = None) -&gt; None\n</code></pre> <p>Update the stopwatch</p> Source code in <code>src/plankapy/v2/models/card.py</code> <pre><code>def update(self, started_at: datetime | str | None=None, total: timedelta | int | None=None) -&gt; None:\n    \"\"\"Update the stopwatch\"\"\"        \n    current = self.schema\n    if started_at:\n        current['startedAt'] = str(\n            dttoiso(started_at, default_timezone=self.tz) \n            if isinstance(started_at, datetime) \n            else started_at\n        )\n    if total:\n        current['total'] = int(round( # Round seconds\n            total.total_seconds() \n            if isinstance(total, timedelta) \n            else total\n        ))\n    self.card.update(stopwatch=current)\n</code></pre>"},{"location":"v2/models/comment/","title":"Comment","text":"CLASS DESCRIPTION <code>Comment</code> <p>Python interface for Planka Comments</p>"},{"location":"v2/models/comment/#plankapy.v2.models.comment.Comment","title":"Comment","text":"<pre><code>Comment(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[Comment]</code></p> <p>Python interface for Planka Comments</p> Returned by: <ul> <li> Plankapy v2 models <ul> <li> Card <code></code>\u00a0Card <ul> <li> <code></code>\u00a0comments </li> <li> <code></code>\u00a0comment </li> </ul> </li> <li> Notification <code></code>\u00a0Notification <code></code>\u00a0comment </li> </ul> </li> </ul> METHOD DESCRIPTION <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>delete</code> <p>Delete the Comment</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> <code>sync</code> <p>Sync the Comment with the Planka server</p> <code>update</code> <p>Update the Comment (must be the comment Creator or an Admin)</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>card</code> <p>The Card the Comment belongs to</p> <p> TYPE: <code>Card</code> </p> <code>created_at</code> <p>When the comment was created</p> <p> TYPE: <code>datetime</code> </p> <code>text</code> <p>Content of the Comment</p> <p> TYPE: <code>str</code> </p> <code>updated_at</code> <p>When the comment was last updated</p> <p> TYPE: <code>datetime</code> </p> <code>user</code> <p>The User who created the Comment</p> <p> TYPE: <code>User</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/comment/#plankapy.v2.models.comment.Comment.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/comment/#plankapy.v2.models.comment.Comment.card","title":"card  <code>property</code>","text":"<pre><code>card: Card\n</code></pre> <p>The Card the Comment belongs to</p>"},{"location":"v2/models/comment/#plankapy.v2.models.comment.Comment.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>When the comment was created</p>"},{"location":"v2/models/comment/#plankapy.v2.models.comment.Comment.text","title":"text  <code>property</code>","text":"<pre><code>text: str\n</code></pre> <p>Content of the Comment</p>"},{"location":"v2/models/comment/#plankapy.v2.models.comment.Comment.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>When the comment was last updated</p>"},{"location":"v2/models/comment/#plankapy.v2.models.comment.Comment.user","title":"user  <code>property</code>","text":"<pre><code>user: User\n</code></pre> <p>The User who created the Comment</p>"},{"location":"v2/models/comment/#plankapy.v2.models.comment.Comment.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/comment/#plankapy.v2.models.comment.Comment.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the Comment</p> Source code in <code>src/plankapy/v2/models/comment.py</code> <pre><code>def delete(self):\n    \"\"\"Delete the Comment\"\"\"\n    return self.endpoints.deleteComment(self.id)\n</code></pre>"},{"location":"v2/models/comment/#plankapy.v2.models.comment.Comment.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/comment/#plankapy.v2.models.comment.Comment.sync","title":"sync","text":"<pre><code>sync()\n</code></pre> <p>Sync the Comment with the Planka server</p> Source code in <code>src/plankapy/v2/models/comment.py</code> <pre><code>def sync(self):\n    \"\"\"Sync the Comment with the Planka server\"\"\"\n    _cm = [cm for cm in self.card.comments if cm == self]\n    if _cm:\n        self.schema = _cm.pop().schema\n</code></pre>"},{"location":"v2/models/comment/#plankapy.v2.models.comment.Comment.update","title":"update","text":"<pre><code>update(**kwargs: Unpack[Request_updateComments])\n</code></pre> <p>Update the Comment (must be the comment Creator or an Admin)</p> Source code in <code>src/plankapy/v2/models/comment.py</code> <pre><code>def update(self, **kwargs: Unpack[paths.Request_updateComments]):\n    \"\"\"Update the Comment (must be the comment Creator or an Admin)\"\"\"\n    self.endpoints.updateComments(self.id, **kwargs)\n</code></pre>"},{"location":"v2/models/config/","title":"Config","text":"CLASS DESCRIPTION <code>Config</code> <p>Python interface for Planka Config</p>"},{"location":"v2/models/config/#plankapy.v2.models.config.Config","title":"Config","text":"<pre><code>Config(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[Config]</code></p> <p>Python interface for Planka Config</p> Returned by: <ul> <li> Plankapy v2 interface Planka Interface <code></code>\u00a0interface <code></code>\u00a0Planka <code></code>\u00a0config </li> </ul> METHOD DESCRIPTION <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>activeUsersLimit</code> <p>Maximum number of active users allowed (conditionally added for admins if configured)</p> <p> TYPE: <code>int | None</code> </p> <code>oidc</code> <p>OpenID Connect configuration (null if not configured)</p> <p> TYPE: <code>dict[str, Any] | None</code> </p> <code>version</code> <p>Current version of the PLANKA application</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/config/#plankapy.v2.models.config.Config.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/config/#plankapy.v2.models.config.Config.activeUsersLimit","title":"activeUsersLimit  <code>property</code>","text":"<pre><code>activeUsersLimit: int | None\n</code></pre> <p>Maximum number of active users allowed (conditionally added for admins if configured)</p>"},{"location":"v2/models/config/#plankapy.v2.models.config.Config.oidc","title":"oidc  <code>property</code>","text":"<pre><code>oidc: dict[str, Any] | None\n</code></pre> <p>OpenID Connect configuration (null if not configured)</p>"},{"location":"v2/models/config/#plankapy.v2.models.config.Config.version","title":"version  <code>property</code>","text":"<pre><code>version: str\n</code></pre> <p>Current version of the PLANKA application</p>"},{"location":"v2/models/config/#plankapy.v2.models.config.Config.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/config/#plankapy.v2.models.config.Config.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/custom-field-group/","title":"Custom Field Group","text":"CLASS DESCRIPTION <code>CustomFieldGroup</code> <p>Python interface for Planka CustomFieldGroups</p>"},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup","title":"CustomFieldGroup","text":"<pre><code>CustomFieldGroup(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[CustomFieldGroup]</code></p> <p>Python interface for Planka CustomFieldGroups</p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0custom_field_groups </li> <li> models <ul> <li> Board <code></code>\u00a0Board <ul> <li> <code></code>\u00a0custom_field_groups </li> <li> <code></code>\u00a0create_field_group </li> </ul> </li> <li> Card <code></code>\u00a0Card <ul> <li> <code></code>\u00a0custom_field_groups </li> <li> <code></code>\u00a0add_card_fields </li> <li> <code></code>\u00a0add_location </li> <li> <code></code>\u00a0create_card_field_group </li> </ul> </li> <li> Custom Field <code></code>\u00a0CustomField <code></code>\u00a0custom_field_group </li> <li> Custom Field Group <code></code>\u00a0CustomFieldGroup <code></code>\u00a0add_to_card </li> <li> Custom Field Value <code></code>\u00a0CustomFieldValue <code></code>\u00a0custom_field_group </li> <li> List <code></code>\u00a0List <code></code>\u00a0custom_field_groups </li> </ul> </li> </ul> </li> </ul> METHOD DESCRIPTION <code>add_field</code> <p>Add a Field to the CustomFieldGroup</p> <code>add_fields</code> <p>Add fields to the CustomFieldGroup</p> <code>add_to_card</code> <p>Add the CustomFieldGroup to a Card</p> <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>delete</code> <p>Delete the CustomFieldGroup</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> <code>make_base_group</code> <p>Convert a CustomFieldGroup into a BaseCustomFieldGroup for a Project or Board</p> <code>remove_field</code> <p>Remove the field from the CustomFieldGroup</p> <code>sync</code> <p>Sync the CustomFieldGroup with the Planka server</p> <code>update</code> <p>Update the CustomFieldGroup</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>base_custom_field_group</code> <p>The BaseCustomFieldGroup used as a template</p> <p> TYPE: <code>BaseCustomFieldGroup</code> </p> <code>board</code> <p>The Board the CustomFieldGroup belongs to</p> <p> TYPE: <code>Board</code> </p> <code>card</code> <p>The Card the CustomFieldGroup belongs to</p> <p> TYPE: <code>Card</code> </p> <code>created_at</code> <p>When the CustomFieldGroup was created</p> <p> TYPE: <code>datetime</code> </p> <code>name</code> <p>Name/title of the CustomFieldGroup</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the CustomFieldGroup within the Board/Card</p> <p> TYPE: <code>int</code> </p> <code>updated_at</code> <p>When the CustomFieldGroup was last updated</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.base_custom_field_group","title":"base_custom_field_group  <code>property</code>","text":"<pre><code>base_custom_field_group: BaseCustomFieldGroup\n</code></pre> <p>The BaseCustomFieldGroup used as a template</p>"},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.board","title":"board  <code>property</code>","text":"<pre><code>board: Board\n</code></pre> <p>The Board the CustomFieldGroup belongs to</p>"},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.card","title":"card  <code>property</code>","text":"<pre><code>card: Card\n</code></pre> <p>The Card the CustomFieldGroup belongs to</p>"},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>When the CustomFieldGroup was created</p>"},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the CustomFieldGroup</p>"},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.position","title":"position  <code>property</code> <code>writable</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the CustomFieldGroup within the Board/Card</p>"},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>When the CustomFieldGroup was last updated</p>"},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.add_field","title":"add_field","text":"<pre><code>add_field(name: str, *, position: Position = 'top', show_on_card: bool = False) -&gt; CustomField\n</code></pre> <p>Add a Field to the CustomFieldGroup</p> PARAMETER DESCRIPTION <p>The name of the Field to add</p> <p> TYPE: <code>str</code> </p> <p>The position of the field within the group (default: <code>top</code>)</p> <p> TYPE: <code>Position</code> DEFAULT: <code>'top'</code> </p> <p>Show the field on the Card front (default: <code>False</code>)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>CustomField</code> <p>If the Field aleady exists, that Field is returned</p> <p> TYPE: <code>CustomField</code> </p> Source code in <code>src/plankapy/v2/models/custom_field_group.py</code> <pre><code>def add_field(self, name: str,\n              *,\n              position: Position='top',\n              show_on_card: bool=False) -&gt; CustomField:\n    \"\"\"Add a Field to the CustomFieldGroup\n\n    Args:\n        name (str): The name of the Field to add\n        position (Position): The position of the field within the group (default: `top`)\n        show_on_card (bool): Show the field on the Card front (default: `False`)\n\n    Returns:\n        CustomField: If the Field aleady exists, that Field is returned\n    \"\"\"\n    # Return existing field\n    _existing_field = [cf for cf in self.custom_fields if cf.name == name]\n    if _existing_field:\n        return _existing_field.pop()\n\n    return CustomField(\n        self.endpoints.createCustomFieldInGroup(\n            self.id,\n            name=name,\n            position=get_position(self.custom_fields, position),\n            showOnFrontOfCard=show_on_card, \n        )['item'], self.session\n    )\n</code></pre>"},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.add_field(name)","title":"<code>name</code>","text":""},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.add_field(position)","title":"<code>position</code>","text":""},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.add_field(show_on_card)","title":"<code>show_on_card</code>","text":""},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.add_fields","title":"add_fields","text":"<pre><code>add_fields(*names: str, position: Position = 'top', show_on_card: bool = False) -&gt; list[CustomField]\n</code></pre> <p>Add fields to the CustomFieldGroup</p> PARAMETER DESCRIPTION <p>Varargs of the names to add</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <p>The position of the field within the group (default: <code>top</code>)</p> <p> TYPE: <code>Position</code> DEFAULT: <code>'top'</code> </p> <p>Show the field on the Card front (default: <code>False</code>)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>list[CustomField]</code> <p>list[CustomField] : The fields added</p> Note <p>Field positions will be calculated in the order passed</p> Source code in <code>src/plankapy/v2/models/custom_field_group.py</code> <pre><code>def add_fields(self,\n               *names: str,\n               position: Position='top',\n               show_on_card: bool=False) -&gt; list[CustomField]:\n    \"\"\"Add fields to the CustomFieldGroup\n\n    Args:\n        *names (str): Varargs of the names to add\n        position (Position): The position of the field within the group (default: `top`)\n        show_on_card (bool): Show the field on the Card front (default: `False`)\n\n    Returns:\n        list[CustomField] : The fields added\n\n    Note:\n        Field positions will be calculated in the order passed\n    \"\"\"\n    return [\n        self.add_field(name=name, position=position, show_on_card=show_on_card)\n        for name in names\n    ]\n</code></pre>"},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.add_fields(*names)","title":"<code>*names</code>","text":""},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.add_fields(position)","title":"<code>position</code>","text":""},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.add_fields(show_on_card)","title":"<code>show_on_card</code>","text":""},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.add_to_card","title":"add_to_card","text":"<pre><code>add_to_card(card: Card) -&gt; CustomFieldGroup\n</code></pre> <p>Add the CustomFieldGroup to a Card</p> PARAMETER DESCRIPTION <p>The Card to add the CustomFieldGroup to</p> <p> TYPE: <code>Card</code> </p> Source code in <code>src/plankapy/v2/models/custom_field_group.py</code> <pre><code>def add_to_card(self, card: Card) -&gt; CustomFieldGroup:\n    \"\"\"Add the CustomFieldGroup to a Card\n\n    Args:\n        card (Card): The Card to add the CustomFieldGroup to\n    \"\"\"\n    # Replace the Current cardId with the ID of the Card we are adding to\n    _schema = self.schema.copy()\n    _schema['cardId'] = card.id\n    return CustomFieldGroup(self.endpoints.createCardCustomFieldGroup(**_schema)['item'], self.session)\n</code></pre>"},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.add_to_card(card)","title":"<code>card</code>","text":""},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the CustomFieldGroup</p> Source code in <code>src/plankapy/v2/models/custom_field_group.py</code> <pre><code>def delete(self):\n    \"\"\"Delete the CustomFieldGroup\"\"\"\n    return self.endpoints.deleteCustomFieldGroup(self.id)\n</code></pre>"},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.make_base_group","title":"make_base_group","text":"<pre><code>make_base_group(project: Project) -&gt; BaseCustomFieldGroup\n</code></pre> <p>Convert a CustomFieldGroup into a BaseCustomFieldGroup for a Project or Board</p> PARAMETER DESCRIPTION <p>The project to add the BaseCustomFieldGroup to</p> <p> TYPE: <code>Project</code> </p> RETURNS DESCRIPTION <code>BaseCustomFieldGroup</code> <p>The new BaseCustomFieldGroup</p> <p> TYPE: <code>BaseCustomFieldGroup</code> </p> Source code in <code>src/plankapy/v2/models/custom_field_group.py</code> <pre><code>def make_base_group(self, project: Project) -&gt; BaseCustomFieldGroup:\n    \"\"\"Convert a CustomFieldGroup into a BaseCustomFieldGroup for a Project or Board\n\n    Args:\n        project (Project): The project to add the BaseCustomFieldGroup to\n\n    Returns:\n        BaseCustomFieldGroup: The new BaseCustomFieldGroup\n    \"\"\"\n    return BaseCustomFieldGroup(self.endpoints.createBaseCustomFieldGroup(project.id, name=self.name)['item'], self.session)\n</code></pre>"},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.make_base_group(project)","title":"<code>project</code>","text":""},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.remove_field","title":"remove_field","text":"<pre><code>remove_field(field: CustomField) -&gt; None\n</code></pre> <p>Remove the field from the CustomFieldGroup</p> PARAMETER DESCRIPTION <p>The CustomField to remove (must be in this Group)</p> <p> TYPE: <code>CustomField</code> </p> Source code in <code>src/plankapy/v2/models/custom_field_group.py</code> <pre><code>def remove_field(self, field: CustomField) -&gt; None:\n    \"\"\"Remove the field from the CustomFieldGroup\n\n    Args:\n        field (CustomField): The CustomField to remove (must be in this Group)\n    \"\"\"\n    if field in self.custom_fields:\n        field.delete()\n</code></pre>"},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.remove_field(field)","title":"<code>field</code>","text":""},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.sync","title":"sync","text":"<pre><code>sync()\n</code></pre> <p>Sync the CustomFieldGroup with the Planka server</p> Source code in <code>src/plankapy/v2/models/custom_field_group.py</code> <pre><code>def sync(self):\n    \"\"\"Sync the CustomFieldGroup with the Planka server\"\"\"\n    self.schema = self.endpoints.getCustomFieldGroup(self.id)['item']\n</code></pre>"},{"location":"v2/models/custom-field-group/#plankapy.v2.models.custom_field_group.CustomFieldGroup.update","title":"update","text":"<pre><code>update(**kwargs: Unpack[Request_updateCustomFieldGroup])\n</code></pre> <p>Update the CustomFieldGroup</p> Source code in <code>src/plankapy/v2/models/custom_field_group.py</code> <pre><code>def update(self, **kwargs: Unpack[paths.Request_updateCustomFieldGroup]):\n    \"\"\"Update the CustomFieldGroup\"\"\"\n    self.schema = self.endpoints.updateCustomFieldGroup(self.id, **kwargs)['item']\n</code></pre>"},{"location":"v2/models/custom-field-value/","title":"Custom Field Value","text":"CLASS DESCRIPTION <code>CustomFieldValue</code> <p>Python interface for Planka CustomFieldValues</p>"},{"location":"v2/models/custom-field-value/#plankapy.v2.models.custom_field_value.CustomFieldValue","title":"CustomFieldValue","text":"<pre><code>CustomFieldValue(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[CustomFieldValue]</code></p> <p>Python interface for Planka CustomFieldValues</p> Returned by: <ul> <li> Plankapy v2 <ul> <li> Planka Utilities <code></code>\u00a0PlankaSnapshot <code></code>\u00a0custom_field_values </li> <li> models <ul> <li> Board <code></code>\u00a0Board <code></code>\u00a0custom_field_values </li> <li> Card <code></code>\u00a0Card <code></code>\u00a0custom_field_values </li> <li> List <code></code>\u00a0List <code></code>\u00a0custom_field_values </li> </ul> </li> </ul> </li> </ul> METHOD DESCRIPTION <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>delete</code> <p>Delete the CustomFieldValue</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> <code>sync</code> <p>Sync the CustomFieldValue with the Planka server</p> <code>update</code> <p>Update the CustomFieldValue</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>card</code> <p>The Card the CustomFieldValue belongs to</p> <p> TYPE: <code>Card</code> </p> <code>content</code> <p>Content/value of the custom field</p> <p> TYPE: <code>str</code> </p> <code>created_at</code> <p>When the CustomFieldValue was created</p> <p> TYPE: <code>datetime</code> </p> <code>custom_field</code> <p>The CustomField the CustomFieldValue belongs to</p> <p> TYPE: <code>CustomField</code> </p> <code>custom_field_group</code> <p>The CustomFieldGroup the CustomFieldValue belongs to</p> <p> TYPE: <code>CustomFieldGroup</code> </p> <code>updated_at</code> <p>When the CustomFieldValue was last updated</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/custom-field-value/#plankapy.v2.models.custom_field_value.CustomFieldValue.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/custom-field-value/#plankapy.v2.models.custom_field_value.CustomFieldValue.card","title":"card  <code>property</code>","text":"<pre><code>card: Card\n</code></pre> <p>The Card the CustomFieldValue belongs to</p>"},{"location":"v2/models/custom-field-value/#plankapy.v2.models.custom_field_value.CustomFieldValue.content","title":"content  <code>property</code> <code>writable</code>","text":"<pre><code>content: str\n</code></pre> <p>Content/value of the custom field</p>"},{"location":"v2/models/custom-field-value/#plankapy.v2.models.custom_field_value.CustomFieldValue.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>When the CustomFieldValue was created</p>"},{"location":"v2/models/custom-field-value/#plankapy.v2.models.custom_field_value.CustomFieldValue.custom_field","title":"custom_field  <code>property</code>","text":"<pre><code>custom_field: CustomField\n</code></pre> <p>The CustomField the CustomFieldValue belongs to</p>"},{"location":"v2/models/custom-field-value/#plankapy.v2.models.custom_field_value.CustomFieldValue.custom_field_group","title":"custom_field_group  <code>property</code>","text":"<pre><code>custom_field_group: CustomFieldGroup\n</code></pre> <p>The CustomFieldGroup the CustomFieldValue belongs to</p>"},{"location":"v2/models/custom-field-value/#plankapy.v2.models.custom_field_value.CustomFieldValue.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>When the CustomFieldValue was last updated</p>"},{"location":"v2/models/custom-field-value/#plankapy.v2.models.custom_field_value.CustomFieldValue.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/custom-field-value/#plankapy.v2.models.custom_field_value.CustomFieldValue.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the CustomFieldValue</p> Source code in <code>src/plankapy/v2/models/custom_field_value.py</code> <pre><code>def delete(self):\n    \"\"\"Delete the CustomFieldValue\"\"\"\n    self.endpoints.deleteCustomFieldValue(\n        cardId=self.schema['cardId'],\n        customFieldGroupId=self.schema['customFieldGroupId'],\n        customFieldId=self.schema['customFieldId'],\n    )\n</code></pre>"},{"location":"v2/models/custom-field-value/#plankapy.v2.models.custom_field_value.CustomFieldValue.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/custom-field-value/#plankapy.v2.models.custom_field_value.CustomFieldValue.sync","title":"sync","text":"<pre><code>sync()\n</code></pre> <p>Sync the CustomFieldValue with the Planka server</p> Source code in <code>src/plankapy/v2/models/custom_field_value.py</code> <pre><code>def sync(self):\n    \"\"\"Sync the CustomFieldValue with the Planka server\"\"\"\n    _cfvs = [cfv for cfv in self.card.custom_field_values if cfv.id == self.id]\n    if _cfvs:\n        self.schema = _cfvs.pop().schema\n</code></pre>"},{"location":"v2/models/custom-field-value/#plankapy.v2.models.custom_field_value.CustomFieldValue.update","title":"update","text":"<pre><code>update(**kwargs: Unpack[Request_updateCustomFieldValue])\n</code></pre> <p>Update the CustomFieldValue</p> Source code in <code>src/plankapy/v2/models/custom_field_value.py</code> <pre><code>def update(self, **kwargs: Unpack[paths.Request_updateCustomFieldValue]):\n    \"\"\"Update the CustomFieldValue\"\"\"\n    self.schema = self.endpoints.updateCustomFieldValue(\n        cardId=self.schema['cardId'],\n        customFieldGroupId=self.schema['customFieldGroupId'],\n        customFieldId=self.schema['customFieldId'],\n        **kwargs)['item']\n</code></pre>"},{"location":"v2/models/custom-field/","title":"Custom Field","text":"CLASS DESCRIPTION <code>CustomField</code> <p>Python interface for Planka CustomFields</p>"},{"location":"v2/models/custom-field/#plankapy.v2.models.custom_field.CustomField","title":"CustomField","text":"<pre><code>CustomField(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[CustomField]</code></p> <p>Python interface for Planka CustomFields</p> Returned by: <ul> <li> Plankapy v2 models <ul> <li> Base Custom Field Group <code></code>\u00a0BaseCustomFieldGroup <ul> <li> <code></code>\u00a0custom_fields </li> <li> <code></code>\u00a0add_field </li> <li> <code></code>\u00a0add_fields </li> <li> <code></code>\u00a0create_field </li> <li> <code></code>\u00a0create_fields </li> <li> <code></code>\u00a0delete_field </li> <li> <code></code>\u00a0delete_fields </li> </ul> </li> <li> Board <code></code>\u00a0Board <code></code>\u00a0custom_fields </li> <li> Card <code></code>\u00a0Card <code></code>\u00a0custom_fields </li> <li> Custom Field Group <code></code>\u00a0CustomFieldGroup <ul> <li> <code></code>\u00a0add_field </li> <li> <code></code>\u00a0add_fields </li> </ul> </li> <li> Custom Field Value <code></code>\u00a0CustomFieldValue <code></code>\u00a0custom_field </li> <li> List <code></code>\u00a0List <code></code>\u00a0custom_fields </li> <li> Project <code></code>\u00a0Project <code></code>\u00a0custom_fields </li> </ul> </li> </ul> Used by: <ul> <li> Plankapy v2 models <ul> <li> Base Custom Field Group <code></code>\u00a0BaseCustomFieldGroup <ul> <li> <code></code>\u00a0add_field </li> <li> <code></code>\u00a0add_fields </li> <li> <code></code>\u00a0delete_field </li> <li> <code></code>\u00a0delete_fields </li> </ul> </li> <li> Custom Field Group <code></code>\u00a0CustomFieldGroup <code></code>\u00a0remove_field </li> </ul> </li> </ul> METHOD DESCRIPTION <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>delete</code> <p>Delete the CustomField</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> <code>sync</code> <p>Sync the CustomField with the Planka server</p> <code>update</code> <p>Update the CustomField</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>base_custom_field_group</code> <p>The BaseCustomFieldGroup the custom field belongs to</p> <p> TYPE: <code>BaseCustomFieldGroup</code> </p> <code>created_at</code> <p>When the custom field was created</p> <p> TYPE: <code>datetime</code> </p> <code>custom_field_group</code> <p>The CustomFieldGroup the CustomField belongs to</p> <p> TYPE: <code>CustomFieldGroup</code> </p> <code>name</code> <p>Name/title of the custom field</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the CustomField within the CustomFieldGroup</p> <p> TYPE: <code>int</code> </p> <code>show_on_front_of_card</code> <p>Whether to show the CustomField on the front of Cards</p> <p> TYPE: <code>bool</code> </p> <code>updated_at</code> <p>When the custom field was last updated</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/custom-field/#plankapy.v2.models.custom_field.CustomField.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/custom-field/#plankapy.v2.models.custom_field.CustomField.base_custom_field_group","title":"base_custom_field_group  <code>property</code>","text":"<pre><code>base_custom_field_group: BaseCustomFieldGroup\n</code></pre> <p>The BaseCustomFieldGroup the custom field belongs to</p>"},{"location":"v2/models/custom-field/#plankapy.v2.models.custom_field.CustomField.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>When the custom field was created</p>"},{"location":"v2/models/custom-field/#plankapy.v2.models.custom_field.CustomField.custom_field_group","title":"custom_field_group  <code>property</code>","text":"<pre><code>custom_field_group: CustomFieldGroup\n</code></pre> <p>The CustomFieldGroup the CustomField belongs to</p>"},{"location":"v2/models/custom-field/#plankapy.v2.models.custom_field.CustomField.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the custom field</p>"},{"location":"v2/models/custom-field/#plankapy.v2.models.custom_field.CustomField.position","title":"position  <code>property</code> <code>writable</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the CustomField within the CustomFieldGroup</p>"},{"location":"v2/models/custom-field/#plankapy.v2.models.custom_field.CustomField.show_on_front_of_card","title":"show_on_front_of_card  <code>property</code> <code>writable</code>","text":"<pre><code>show_on_front_of_card: bool\n</code></pre> <p>Whether to show the CustomField on the front of Cards</p>"},{"location":"v2/models/custom-field/#plankapy.v2.models.custom_field.CustomField.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>When the custom field was last updated</p>"},{"location":"v2/models/custom-field/#plankapy.v2.models.custom_field.CustomField.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/custom-field/#plankapy.v2.models.custom_field.CustomField.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the CustomField</p> Source code in <code>src/plankapy/v2/models/custom_field.py</code> <pre><code>def delete(self):\n    \"\"\"Delete the CustomField\"\"\"\n    self.endpoints.deleteCustomField(self.id)\n</code></pre>"},{"location":"v2/models/custom-field/#plankapy.v2.models.custom_field.CustomField.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/custom-field/#plankapy.v2.models.custom_field.CustomField.sync","title":"sync","text":"<pre><code>sync()\n</code></pre> <p>Sync the CustomField with the Planka server</p> Source code in <code>src/plankapy/v2/models/custom_field.py</code> <pre><code>def sync(self):\n    \"\"\"Sync the CustomField with the Planka server\"\"\"\n</code></pre>"},{"location":"v2/models/custom-field/#plankapy.v2.models.custom_field.CustomField.update","title":"update","text":"<pre><code>update(**kwargs: Unpack[Request_updateCustomField])\n</code></pre> <p>Update the CustomField</p> Source code in <code>src/plankapy/v2/models/custom_field.py</code> <pre><code>def update(self, **kwargs: Unpack[paths.Request_updateCustomField]):\n    \"\"\"Update the CustomField\"\"\"\n    self.schema = self.endpoints.updateCustomField(self.id, **kwargs)['item']\n</code></pre>"},{"location":"v2/models/label/","title":"Label","text":"CLASS DESCRIPTION <code>Label</code> <p>Python interface for Planka Labels</p>"},{"location":"v2/models/label/#plankapy.v2.models.label.Label","title":"Label","text":"<pre><code>Label(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[Label]</code></p> <p>Python interface for Planka Labels</p> Returned by: <ul> <li> Plankapy v2 models <ul> <li> Board <code></code>\u00a0Board <ul> <li> <code></code>\u00a0labels </li> <li> <code></code>\u00a0create_label </li> </ul> </li> <li> Card <code></code>\u00a0Card <ul> <li> <code></code>\u00a0labels </li> <li> <code></code>\u00a0remove_label </li> <li> <code></code>\u00a0remove_labels </li> </ul> </li> <li> Card Label <code></code>\u00a0CardLabel <code></code>\u00a0label </li> <li> Label <code></code>\u00a0Label <code></code>\u00a0add_to_board </li> </ul> </li> </ul> Used by: <ul> <li> Plankapy v2 models <ul> <li> Board <code></code>\u00a0Board <ul> <li> <code></code>\u00a0filter </li> <li> <code></code>\u00a0remove_label </li> </ul> </li> <li> Card <code></code>\u00a0Card <ul> <li> <code></code>\u00a0add_label </li> <li> <code></code>\u00a0add_labels </li> <li> <code></code>\u00a0remove_label </li> <li> <code></code>\u00a0remove_labels </li> </ul> </li> <li> List <code></code>\u00a0List <code></code>\u00a0filter </li> </ul> </li> </ul> METHOD DESCRIPTION <code>add_to_board</code> <p>Add the Label to a Board or return a matching Label from the Board.</p> <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>delete</code> <p>Delete the Label</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> <code>get_cards</code> <p>All Cards that have this Label in the Board</p> <code>sync</code> <p>Sync the Label with the Planka server</p> <code>update</code> <p>Update the Label</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>board</code> <p>The Board the Label belongs to</p> <p> TYPE: <code>Board</code> </p> <code>color</code> <p>Color of the label</p> <p> TYPE: <code>LabelColor</code> </p> <code>created_at</code> <p>When the label was created</p> <p> TYPE: <code>datetime</code> </p> <code>name</code> <p>Name/title of the Label</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the Label within the Board</p> <p> TYPE: <code>int</code> </p> <code>updated_at</code> <p>When the label was last updated</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/label/#plankapy.v2.models.label.Label.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/label/#plankapy.v2.models.label.Label.board","title":"board  <code>property</code>","text":"<pre><code>board: Board\n</code></pre> <p>The Board the Label belongs to</p>"},{"location":"v2/models/label/#plankapy.v2.models.label.Label.color","title":"color  <code>property</code> <code>writable</code>","text":"<pre><code>color: LabelColor\n</code></pre> <p>Color of the label</p>"},{"location":"v2/models/label/#plankapy.v2.models.label.Label.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>When the label was created</p>"},{"location":"v2/models/label/#plankapy.v2.models.label.Label.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the Label</p>"},{"location":"v2/models/label/#plankapy.v2.models.label.Label.position","title":"position  <code>property</code> <code>writable</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the Label within the Board</p>"},{"location":"v2/models/label/#plankapy.v2.models.label.Label.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>When the label was last updated</p>"},{"location":"v2/models/label/#plankapy.v2.models.label.Label.add_to_board","title":"add_to_board","text":"<pre><code>add_to_board(board: Board, *, position: Position = 'top', color: LabelColor | None = None) -&gt; Label\n</code></pre> <p>Add the Label to a Board or return a matching Label from the Board.</p> PARAMETER DESCRIPTION <p>The Board to add the Label to</p> <p> TYPE: <code>Board</code> </p> <p>The position of the Label within the Board (default: <code>top</code>)</p> <p> TYPE: <code>Position</code> DEFAULT: <code>'top'</code> </p> <p>Optionally change the LabelColor in the new Board</p> <p> TYPE: <code>LabelColor | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Label</code> <p>The new Label or the matching Label (same color and name)</p> <p> TYPE: <code>Label</code> </p> Note <p>Matching is determines by name and color, if a Label matches on the board, but a color  override is set, a new label will be created. If the label is already on the board, the  input label is returned</p> Source code in <code>src/plankapy/v2/models/label.py</code> <pre><code>def add_to_board(self, board: Board, \n                 *, \n                 position: Position='top',\n                 color: LabelColor|None=None) -&gt; Label:\n    \"\"\"Add the Label to a Board or return a matching Label from the Board.\n\n    Args:\n        board (Board): The Board to add the Label to\n        position (Position): The position of the Label within the Board (default: `top`)\n        color (LabelColor | None): Optionally change the LabelColor in the new Board\n\n    Returns:\n        Label: The new Label or the matching Label (same color and name)\n\n    Note:\n        Matching is determines by name and color, if a Label matches on the board, but a color \n        override is set, a new label will be created. If the label is already on the board, the \n        input label is returned\n    \"\"\"\n    # Don't re-add label to same board\n    if board == self.board:\n        return self\n\n    # Don't add the Label if one with matching name and color exists\n    # If a color override is set, allow the creation of a new label\n    for lbl in board.labels:\n        if (lbl.name, lbl.color) == (self.name, self.color) and color == self.color:\n            return lbl\n\n    _schema = self.schema.copy()\n    _schema['boardId'] = board.id\n    _schema['position'] = get_position(board.labels, position)\n\n    # Update color\n    if color is not None:\n        _schema['color'] = color\n    return Label(self.endpoints.createLabel(**_schema)['item'], self.session)\n</code></pre>"},{"location":"v2/models/label/#plankapy.v2.models.label.Label.add_to_board(board)","title":"<code>board</code>","text":""},{"location":"v2/models/label/#plankapy.v2.models.label.Label.add_to_board(position)","title":"<code>position</code>","text":""},{"location":"v2/models/label/#plankapy.v2.models.label.Label.add_to_board(color)","title":"<code>color</code>","text":""},{"location":"v2/models/label/#plankapy.v2.models.label.Label.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/label/#plankapy.v2.models.label.Label.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the Label</p> Source code in <code>src/plankapy/v2/models/label.py</code> <pre><code>def delete(self):\n    \"\"\"Delete the Label\"\"\"\n    return self.endpoints.deleteLabel(self.id)\n</code></pre>"},{"location":"v2/models/label/#plankapy.v2.models.label.Label.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/label/#plankapy.v2.models.label.Label.get_cards","title":"get_cards","text":"<pre><code>get_cards() -&gt; list[Card]\n</code></pre> <p>All Cards that have this Label in the Board</p> Source code in <code>src/plankapy/v2/models/label.py</code> <pre><code>@model_list\ndef get_cards(self) -&gt; list[Card]:\n    \"\"\"All Cards that have this Label in the Board\"\"\"\n    return [\n        cl.card\n        for cl in self.board.card_labels\n        # Avoid initializing another Label\n        if cl.schema['labelId'] == self.schema['id']\n    ]\n</code></pre>"},{"location":"v2/models/label/#plankapy.v2.models.label.Label.sync","title":"sync","text":"<pre><code>sync()\n</code></pre> <p>Sync the Label with the Planka server</p> Source code in <code>src/plankapy/v2/models/label.py</code> <pre><code>def sync(self):\n    \"\"\"Sync the Label with the Planka server\"\"\"\n    _lbls = [l for l in self.board.labels if l == self]\n    if _lbls:\n        self.schema = _lbls.pop().schema\n</code></pre>"},{"location":"v2/models/label/#plankapy.v2.models.label.Label.update","title":"update","text":"<pre><code>update(**kwargs: Unpack[Request_updateLabel])\n</code></pre> <p>Update the Label</p> Source code in <code>src/plankapy/v2/models/label.py</code> <pre><code>def update(self, **kwargs: Unpack[paths.Request_updateLabel]):\n    \"\"\"Update the Label\"\"\"\n    self.schema = self.endpoints.updateLabel(self.id, **kwargs)['item']\n</code></pre>"},{"location":"v2/models/list/","title":"List","text":"CLASS DESCRIPTION <code>List</code> <p>Python interface for Planka Lists</p>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List","title":"List","text":"<pre><code>List(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[List]</code></p> <p>Python interface for Planka Lists</p> Returned by: <ul> <li> Plankapy v2 models <ul> <li> Board <code></code>\u00a0Board <ul> <li> <code></code>\u00a0active_lists </li> <li> <code></code>\u00a0all_lists </li> <li> <code></code>\u00a0archive_list </li> <li> <code></code>\u00a0closed_lists </li> <li> <code></code>\u00a0lists </li> <li> <code></code>\u00a0trash_list </li> <li> <code></code>\u00a0create_list </li> </ul> </li> <li> Card <code></code>\u00a0Card <ul> <li> <code></code>\u00a0list </li> <li> <code></code>\u00a0prev_list </li> </ul> </li> </ul> </li> </ul> Used by: <ul> <li> Plankapy v2 models <ul> <li> Board <code></code>\u00a0Board <code></code>\u00a0remove_list </li> <li> Card <code></code>\u00a0Card <code></code>\u00a0move </li> <li> List <code></code>\u00a0List <code></code>\u00a0move_cards </li> </ul> </li> </ul> METHOD DESCRIPTION <code>archive_cards</code> <p>Move all cards in the List to the Board archive</p> <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>create_card</code> <p>Create a new card in the List</p> <code>delete</code> <p>Delete the List</p> <code>delete_cards</code> <p>Delete all Cards in the List (must be a trash list)</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> <code>filter</code> <p>Apply a filter to the list</p> <code>move_cards</code> <p>Move all Cards in this List to another List</p> <code>shuffle</code> <p>Shuffle the cards in the List (randomize position)</p> <code>sort</code> <p>Sort the list using a sort function</p> <code>sort_cards</code> <p>Sort all cards in the List and return the sorted Cards</p> <code>sync</code> <p>Sync the List with the Planka server</p> <code>update</code> <p>Update the List</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>attachments</code> <p>Attachments associated with the List</p> <p> TYPE: <code>list[Attachment]</code> </p> <code>board</code> <p>The Board the List belongs to</p> <p> TYPE: <code>Board</code> </p> <code>card_labels</code> <p>CardLabels associated with the List</p> <p> TYPE: <code>list[CardLabel]</code> </p> <code>card_memberships</code> <p>CardMemberships associated with the List</p> <p> TYPE: <code>list[CardMembership]</code> </p> <code>cards</code> <p>Cards associated with the List</p> <p> TYPE: <code>list[Card]</code> </p> <code>color</code> <p>Color for the List</p> <p> TYPE: <code>ListColor</code> </p> <code>created_at</code> <p>When the List was created</p> <p> TYPE: <code>datetime</code> </p> <code>custom_field_groups</code> <p>CustomFieldGroups associated with the List</p> <p> TYPE: <code>list[CustomFieldGroup]</code> </p> <code>custom_field_values</code> <p>CustomFieldValues associated with the List</p> <p> TYPE: <code>list[CustomFieldValue]</code> </p> <code>custom_fields</code> <p>CustomFields associated with the List</p> <p> TYPE: <code>list[CustomField]</code> </p> <code>name</code> <p>Name/title of the List</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the List within the Board</p> <p> TYPE: <code>int</code> </p> <code>task_lists</code> <p>TaskLists associated with the List</p> <p> TYPE: <code>list[TaskList]</code> </p> <code>tasks</code> <p>Tasks associated with the List</p> <p> TYPE: <code>list[Task]</code> </p> <code>type</code> <p>Type/status of the list</p> <p> </p> <code>updated_at</code> <p>When the List was last updated</p> <p> TYPE: <code>datetime</code> </p> <code>users</code> <p>Users associated with the List</p> <p> TYPE: <code>list[User]</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.attachments","title":"attachments  <code>property</code>","text":"<pre><code>attachments: list[Attachment]\n</code></pre> <p>Attachments associated with the List</p>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.board","title":"board  <code>property</code>","text":"<pre><code>board: Board\n</code></pre> <p>The Board the List belongs to</p>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.card_labels","title":"card_labels  <code>property</code>","text":"<pre><code>card_labels: list[CardLabel]\n</code></pre> <p>CardLabels associated with the List</p>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.card_memberships","title":"card_memberships  <code>property</code>","text":"<pre><code>card_memberships: list[CardMembership]\n</code></pre> <p>CardMemberships associated with the List</p>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.cards","title":"cards  <code>property</code>","text":"<pre><code>cards: list[Card]\n</code></pre> <p>Cards associated with the List</p>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.color","title":"color  <code>property</code> <code>writable</code>","text":"<pre><code>color: ListColor\n</code></pre> <p>Color for the List</p>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>When the List was created</p>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.custom_field_groups","title":"custom_field_groups  <code>property</code>","text":"<pre><code>custom_field_groups: list[CustomFieldGroup]\n</code></pre> <p>CustomFieldGroups associated with the List</p>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.custom_field_values","title":"custom_field_values  <code>property</code>","text":"<pre><code>custom_field_values: list[CustomFieldValue]\n</code></pre> <p>CustomFieldValues associated with the List</p>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.custom_fields","title":"custom_fields  <code>property</code>","text":"<pre><code>custom_fields: list[CustomField]\n</code></pre> <p>CustomFields associated with the List</p>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the List</p>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.position","title":"position  <code>property</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the List within the Board</p>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.task_lists","title":"task_lists  <code>property</code>","text":"<pre><code>task_lists: list[TaskList]\n</code></pre> <p>TaskLists associated with the List</p>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: list[Task]\n</code></pre> <p>Tasks associated with the List</p>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.type","title":"type  <code>property</code> <code>writable</code>","text":"<pre><code>type\n</code></pre> <p>Type/status of the list</p>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>When the List was last updated</p>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.users","title":"users  <code>property</code>","text":"<pre><code>users: list[User]\n</code></pre> <p>Users associated with the List</p>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.archive_cards","title":"archive_cards","text":"<pre><code>archive_cards() -&gt; list[Card]\n</code></pre> <p>Move all cards in the List to the Board archive</p> Source code in <code>src/plankapy/v2/models/list_.py</code> <pre><code>@model_list\ndef archive_cards(self) -&gt; list[Card]:\n    \"\"\"Move all cards in the List to the Board archive\"\"\"\n    return [\n        Card(c, self.session)\n        for c in self.endpoints.moveListCards(\n            self.id, \n            listId=self.board.archive_list.id\n            )['included']['cards']\n    ]\n</code></pre>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.create_card","title":"create_card","text":"<pre><code>create_card(*, name: str, position: Position = 'bottom', type: CardType = 'project', description: str | None = None, due_date: datetime | None = None, due_date_completed: bool = False, stopwatch_duration: timedelta | None = None, stopwatch_started: datetime | Literal['now'] | None = None) -&gt; Card\n</code></pre> <p>Create a new card in the List</p> PARAMETER DESCRIPTION <p>The name of the Card</p> <p> TYPE: <code>str</code> </p> <p>The position of the card within the List</p> <p> TYPE: <code>Position</code> DEFAULT: <code>'bottom'</code> </p> <p>The type of the card</p> <p> TYPE: <code>CardType</code> DEFAULT: <code>'project'</code> </p> <p>An optional description to include</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <p>A due date for the card</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> <p>If the card has been completed</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>The duration to include with the stopwatch</p> <p> TYPE: <code>timedelta | None</code> DEFAULT: <code>None</code> </p> <p>The start time for the runnung stopwatch (None is paused)</p> <p> TYPE: <code>datetime | Literal['now'] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/plankapy/v2/models/list_.py</code> <pre><code>def create_card(self, \n                *,\n                name: str,\n                position: Position='bottom',\n                type: CardType='project',\n                description: str|None=None,\n                due_date: datetime|None=None,\n                due_date_completed: bool=False,\n                stopwatch_duration: timedelta|None=None,\n                stopwatch_started: datetime|Literal['now']|None=None) -&gt; Card:\n    \"\"\"Create a new card in the List\n\n    Args:\n        name: The name of the Card\n        position: The position of the card within the List\n        type: The type of the card\n        description: An optional description to include\n        due_date: A due date for the card\n        due_date_completed: If the card has been completed\n        stopwatch_duration: The duration to include with the stopwatch\n        stopwatch_started: The start time for the runnung stopwatch (None is paused)\n\n    \"\"\"\n    args: paths.Request_createCard = {\n        'name': name,\n        'position': get_position(self.cards, position),\n        'type': type\n    }\n    # Apply optionals\n    if description:\n        args['description'] = description\n    if due_date:\n        args['dueDate'] = dttoiso(due_date, default_timezone=self.session.timezone)\n    if due_date_completed:\n        args['isDueCompleted'] = True\n\n    if stopwatch_duration or stopwatch_started:\n        args['stopwatch'] = {}\n        if stopwatch_duration:\n            args['stopwatch']['total'] = int(stopwatch_duration.total_seconds())\n        if stopwatch_started:\n            if stopwatch_started == 'now':\n                t = datetime.now(self.session.timezone).isoformat()\n            else:\n                t = dttoiso(stopwatch_started, default_timezone=self.session.timezone)\n            args['stopwatch']['startedAt'] = t\n\n    return Card(\n        self.endpoints.createCard(\\\n            self.id, \n            **args)['item'], \n            self.session\n        )\n</code></pre>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.create_card(name)","title":"<code>name</code>","text":""},{"location":"v2/models/list/#plankapy.v2.models.list_.List.create_card(position)","title":"<code>position</code>","text":""},{"location":"v2/models/list/#plankapy.v2.models.list_.List.create_card(type)","title":"<code>type</code>","text":""},{"location":"v2/models/list/#plankapy.v2.models.list_.List.create_card(description)","title":"<code>description</code>","text":""},{"location":"v2/models/list/#plankapy.v2.models.list_.List.create_card(due_date)","title":"<code>due_date</code>","text":""},{"location":"v2/models/list/#plankapy.v2.models.list_.List.create_card(due_date_completed)","title":"<code>due_date_completed</code>","text":""},{"location":"v2/models/list/#plankapy.v2.models.list_.List.create_card(stopwatch_duration)","title":"<code>stopwatch_duration</code>","text":""},{"location":"v2/models/list/#plankapy.v2.models.list_.List.create_card(stopwatch_started)","title":"<code>stopwatch_started</code>","text":""},{"location":"v2/models/list/#plankapy.v2.models.list_.List.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the List</p> Source code in <code>src/plankapy/v2/models/list_.py</code> <pre><code>def delete(self):\n    \"\"\"Delete the List\"\"\"\n    return self.endpoints.deleteList(self.id)\n</code></pre>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.delete_cards","title":"delete_cards","text":"<pre><code>delete_cards() -&gt; None\n</code></pre> <p>Delete all Cards in the List (must be a trash list)</p> Source code in <code>src/plankapy/v2/models/list_.py</code> <pre><code>def delete_cards(self) -&gt; None:\n    \"\"\"Delete all Cards in the List (must be a trash list)\"\"\"\n    self.endpoints.clearList(self.id)['item']\n</code></pre>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.filter","title":"filter","text":"<pre><code>filter(*, search: str | None = None, users: User | Sequence[User] | None = None, labels: Label | Sequence[Label] | None = None, card_before: Card | None = None, changed_before: datetime | None = None) -&gt; list[Card]\n</code></pre> <p>Apply a filter to the list</p> PARAMETER DESCRIPTION <p>A search term to apply to the cards</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <p>A list of Users to filter the cards by</p> <p> TYPE: <code>User | Sequence[User] | None</code> DEFAULT: <code>None</code> </p> <p>A list of Labels to filter the cards by</p> <p> TYPE: <code>Label | Sequence[Label] | None</code> DEFAULT: <code>None</code> </p> <p>Limit filter to only cards before this card</p> <p> TYPE: <code>Card | None</code> DEFAULT: <code>None</code> </p> <p>A time filter that filters on <code>list_changed_at</code></p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/plankapy/v2/models/list_.py</code> <pre><code>@model_list\ndef filter(self, \n           *,\n           search: str|None=None,\n           users: User|Sequence[User]|None=None,\n           labels: Label|Sequence[Label]|None=None,\n           card_before: Card|None=None,\n           changed_before: datetime|None=None) -&gt; list[Card]:\n    \"\"\"Apply a filter to the list\n\n    Args:\n        search: A search term to apply to the cards\n        users: A list of Users to filter the cards by\n        labels: A list of Labels to filter the cards by\n        card_before: Limit filter to only cards before this card\n        changed_before: A time filter that filters on `list_changed_at`\n    \"\"\"\n\n    kwargs: dict[str, Any] = {}\n    if search:\n        kwargs['search'] = search\n    if users:\n        if isinstance(users, User):\n            users = [users]\n        kwargs['userIds'] = ','.join(u.id for u in users)\n    if labels:\n        if isinstance(labels, Label):\n            labels = [labels]\n        kwargs['labelIds '] = ','.join(l.id for l in labels)\n    if card_before or changed_before:\n        kwargs['before'] = {}\n    if card_before:\n        kwargs['before']['id'] = card_before.id\n    if changed_before:\n        kwargs['before']['listChangedAt'] = dttoiso(changed_before, default_timezone=self.session.timezone)\n\n    return [\n        Card(c, self.session) \n        for c in self.endpoints.getCards(\n            self.id, \n            **kwargs,\n        )['items']\n    ]\n</code></pre>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.filter(search)","title":"<code>search</code>","text":""},{"location":"v2/models/list/#plankapy.v2.models.list_.List.filter(users)","title":"<code>users</code>","text":""},{"location":"v2/models/list/#plankapy.v2.models.list_.List.filter(labels)","title":"<code>labels</code>","text":""},{"location":"v2/models/list/#plankapy.v2.models.list_.List.filter(card_before)","title":"<code>card_before</code>","text":""},{"location":"v2/models/list/#plankapy.v2.models.list_.List.filter(changed_before)","title":"<code>changed_before</code>","text":""},{"location":"v2/models/list/#plankapy.v2.models.list_.List.move_cards","title":"move_cards","text":"<pre><code>move_cards(list: List, position: Position = 'top') -&gt; list[Card]\n</code></pre> <p>Move all Cards in this List to another List</p> Source code in <code>src/plankapy/v2/models/list_.py</code> <pre><code>@model_list\ndef move_cards(self, list: List, position: Position='top') -&gt; list[Card]:\n    \"\"\"Move all Cards in this List to another List\"\"\"\n    cards = self.cards\n    for c in self.cards:\n        c.move(list, position)\n    return cards\n</code></pre>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.shuffle","title":"shuffle","text":"<pre><code>shuffle() -&gt; list[Card]\n</code></pre> <p>Shuffle the cards in the List (randomize position)</p> Source code in <code>src/plankapy/v2/models/list_.py</code> <pre><code>@model_list\ndef shuffle(self) -&gt; list[Card]:\n    \"\"\"Shuffle the cards in the List (randomize position)\"\"\"\n    cards = self.cards\n    shuffle(cards)\n    for pos, card in enumerate(cards, start=1):\n        card.position = pos*POSITION_GAP\n    return cards\n</code></pre>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.sort","title":"sort","text":"<pre><code>sort(key: Callable[[Card], Any] | None = None, reverse: bool = False) -&gt; list[Card]\n</code></pre> <p>Sort the list using a sort function</p> PARAMETER DESCRIPTION <p>The sorting function to use (default is <code>card.name</code>)</p> <p> TYPE: <code>Callable[[Card], Any] | None</code> DEFAULT: <code>None</code> </p> <p>Reverse the sort order</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Note <p>If sorting on fields that may have comparison errors (e.g. <code>due_date</code>)  make sure your sort key properly accounts for that:  <pre><code>&gt;&gt;&gt; lst.sort(lambda c: c.due_date)\nException ... # Can't compare NoneType and datetime\n&gt;&gt;&gt; lst.sort(lambda c: c.due_date or c.created_at+timedelta(days=10000))\n[\n    Card(dueDate='2026-01-20...'),\n    Card(dueDate='2026-01-26...'),\n    ...\n]\n</code></pre></p> Source code in <code>src/plankapy/v2/models/list_.py</code> <pre><code>@model_list\ndef sort(self, key: Callable[[Card], Any]|None=None, reverse: bool=False) -&gt; list[Card]:\n    \"\"\"Sort the list using a sort function\n\n    Args:\n        key: The sorting function to use (default is `card.name`)\n        reverse: Reverse the sort order\n\n    Note:\n        If sorting on fields that may have comparison errors (e.g. `due_date`) \n        make sure your sort key properly accounts for that: \n        ```python\n        &gt;&gt;&gt; lst.sort(lambda c: c.due_date)\n        Exception ... # Can't compare NoneType and datetime\n        &gt;&gt;&gt; lst.sort(lambda c: c.due_date or c.created_at+timedelta(days=10000))\n        [\n            Card(dueDate='2026-01-20...'),\n            Card(dueDate='2026-01-26...'),\n            ...\n        ]\n        ```\n    \"\"\"\n    if key is None:\n        key = lambda c: c.name\n    cards = self.cards\n    cards.sort(key=key, reverse=reverse)\n    for pos, card in enumerate(cards, start=1):\n        card.position = pos*POSITION_GAP\n    return cards\n</code></pre>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.sort(key)","title":"<code>key</code>","text":""},{"location":"v2/models/list/#plankapy.v2.models.list_.List.sort(reverse)","title":"<code>reverse</code>","text":""},{"location":"v2/models/list/#plankapy.v2.models.list_.List.sort_cards","title":"sort_cards","text":"<pre><code>sort_cards(**kwargs: Unpack[Request_sortList]) -&gt; list[Card]\n</code></pre> <p>Sort all cards in the List and return the sorted Cards</p> Source code in <code>src/plankapy/v2/models/list_.py</code> <pre><code>@model_list\ndef sort_cards(self, **kwargs: Unpack[paths.Request_sortList]) -&gt; list[Card]:\n    \"\"\"Sort all cards in the List and return the sorted Cards\"\"\"\n    return [Card(c, self.session) for c in self.endpoints.sortList(self.id, **kwargs)['included']['cards']]\n</code></pre>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.sync","title":"sync","text":"<pre><code>sync()\n</code></pre> <p>Sync the List with the Planka server</p> Source code in <code>src/plankapy/v2/models/list_.py</code> <pre><code>def sync(self):\n    \"\"\"Sync the List with the Planka server\"\"\"\n    self.schema = self.endpoints.getList(self.id)['item']\n</code></pre>"},{"location":"v2/models/list/#plankapy.v2.models.list_.List.update","title":"update","text":"<pre><code>update(**list: Unpack[Request_updateList])\n</code></pre> <p>Update the List</p> Source code in <code>src/plankapy/v2/models/list_.py</code> <pre><code>def update(self, **list: Unpack[paths.Request_updateList]):\n    \"\"\"Update the List\"\"\"\n    self.endpoints.updateList(self.id, **list)\n</code></pre>"},{"location":"v2/models/notification-service/","title":"Notification Service","text":"CLASS DESCRIPTION <code>NotificationService</code> <p>Python interface for Planka NotificationServices</p>"},{"location":"v2/models/notification-service/#plankapy.v2.models.notification_service.NotificationService","title":"NotificationService","text":"<pre><code>NotificationService(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[NotificationService]</code></p> <p>Python interface for Planka NotificationServices</p> Returned by: <ul> <li> Plankapy v2 models <ul> <li> Project <code></code>\u00a0Project <code></code>\u00a0notification_services </li> <li> User <code></code>\u00a0User <ul> <li> <code></code>\u00a0notification_services </li> <li> <code></code>\u00a0add_notification_service </li> <li> <code></code>\u00a0create_notification_service </li> </ul> </li> </ul> </li> </ul> Used by: <ul> <li> Plankapy v2 models User <code></code>\u00a0User <ul> <li> <code></code>\u00a0add_notification_service </li> <li> <code></code>\u00a0delete_notification_service </li> </ul> </li> </ul> METHOD DESCRIPTION <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>delete</code> <p>Delete the NotificationService</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> <code>sync</code> <p>Sync the NotificationService with the Planka server</p> <code>update</code> <p>Update the NotificationService</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>board</code> <p>The Board the NotificationService is associated with</p> <p> TYPE: <code>Board</code> </p> <code>created_at</code> <p>When the NotificationService was created</p> <p> TYPE: <code>datetime</code> </p> <code>format</code> <p>Format for notification messages</p> <p> TYPE: <code>NotificationServiceFormat</code> </p> <code>updated_at</code> <p>When the NotificationService was last updated</p> <p> TYPE: <code>datetime</code> </p> <code>url</code> <p>URL endpoint for Notifications</p> <p> TYPE: <code>str</code> </p> <code>user</code> <p>The User the NotificationService is associated with</p> <p> TYPE: <code>User</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/notification-service/#plankapy.v2.models.notification_service.NotificationService.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/notification-service/#plankapy.v2.models.notification_service.NotificationService.board","title":"board  <code>property</code>","text":"<pre><code>board: Board\n</code></pre> <p>The Board the NotificationService is associated with</p>"},{"location":"v2/models/notification-service/#plankapy.v2.models.notification_service.NotificationService.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>When the NotificationService was created</p>"},{"location":"v2/models/notification-service/#plankapy.v2.models.notification_service.NotificationService.format","title":"format  <code>property</code> <code>writable</code>","text":"<pre><code>format: NotificationServiceFormat\n</code></pre> <p>Format for notification messages</p>"},{"location":"v2/models/notification-service/#plankapy.v2.models.notification_service.NotificationService.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>When the NotificationService was last updated</p>"},{"location":"v2/models/notification-service/#plankapy.v2.models.notification_service.NotificationService.url","title":"url  <code>property</code> <code>writable</code>","text":"<pre><code>url: str\n</code></pre> <p>URL endpoint for Notifications</p>"},{"location":"v2/models/notification-service/#plankapy.v2.models.notification_service.NotificationService.user","title":"user  <code>property</code>","text":"<pre><code>user: User\n</code></pre> <p>The User the NotificationService is associated with</p>"},{"location":"v2/models/notification-service/#plankapy.v2.models.notification_service.NotificationService.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/notification-service/#plankapy.v2.models.notification_service.NotificationService.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the NotificationService</p> Source code in <code>src/plankapy/v2/models/notification_service.py</code> <pre><code>def delete(self):\n    \"\"\"Delete the NotificationService\"\"\"\n    self.endpoints.deleteNotificationService(self.id)\n</code></pre>"},{"location":"v2/models/notification-service/#plankapy.v2.models.notification_service.NotificationService.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/notification-service/#plankapy.v2.models.notification_service.NotificationService.sync","title":"sync","text":"<pre><code>sync()\n</code></pre> <p>Sync the NotificationService with the Planka server</p> Source code in <code>src/plankapy/v2/models/notification_service.py</code> <pre><code>def sync(self):\n    \"\"\"Sync the NotificationService with the Planka server\"\"\"\n    _nss = [ns for ns in self.board.project.notification_services if ns == self]\n    if _nss:\n        self.schema = _nss.pop().schema\n</code></pre>"},{"location":"v2/models/notification-service/#plankapy.v2.models.notification_service.NotificationService.update","title":"update","text":"<pre><code>update(**kwargs: Unpack[Request_updateNotificationService])\n</code></pre> <p>Update the NotificationService</p> Source code in <code>src/plankapy/v2/models/notification_service.py</code> <pre><code>def update(self, **kwargs: Unpack[paths.Request_updateNotificationService]):\n    \"\"\"Update the NotificationService\"\"\"\n    self.schema = self.endpoints.updateNotificationService(self.id, **kwargs)['item']\n</code></pre>"},{"location":"v2/models/notification/","title":"Notification","text":"CLASS DESCRIPTION <code>Notification</code> <p>Python interface for Planka Notifications</p>"},{"location":"v2/models/notification/#plankapy.v2.models.notification.Notification","title":"Notification","text":"<pre><code>Notification(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[Notification]</code></p> <p>Python interface for Planka Notifications</p> Returned by: <ul> <li> Plankapy v2 <ul> <li> models Card <code></code>\u00a0Card <code></code>\u00a0read_notifications </li> <li> interface Planka Interface <code></code>\u00a0interface <code></code>\u00a0Planka <ul> <li> <code></code>\u00a0notifications </li> <li> <code></code>\u00a0unread_notifications </li> <li> <code></code>\u00a0read_notifications </li> </ul> </li> </ul> </li> </ul> METHOD DESCRIPTION <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> <code>sync</code> <p>Sync the Notification with the Planka server</p> <code>update</code> <p>Update the Notification</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>action</code> <p>The Action associated with the Notification</p> <p> TYPE: <code>Action</code> </p> <code>board</code> <p>The Board associated with the Notification (denormalized)</p> <p> TYPE: <code>Board</code> </p> <code>card</code> <p>The Card associated with the Notification</p> <p> TYPE: <code>Card</code> </p> <code>comment</code> <p>The Comment associated with the Notification</p> <p> TYPE: <code>Comment</code> </p> <code>created_at</code> <p>When the Notification was created</p> <p> TYPE: <code>datetime</code> </p> <code>creator</code> <p>The User who created the Notification</p> <p> TYPE: <code>User</code> </p> <code>data</code> <p>Notification specific data (varies by type)</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>is_read</code> <p>Whether the Notification has been read</p> <p> TYPE: <code>bool</code> </p> <code>type</code> <p>Type of the Notification</p> <p> TYPE: <code>NotificationType</code> </p> <code>updated_at</code> <p>When the Notification was last updated</p> <p> TYPE: <code>datetime</code> </p> <code>user</code> <p>The User who receives the Notification</p> <p> TYPE: <code>User</code> </p> <code>users</code> <p>All Users associated with the Notification</p> <p> TYPE: <code>list[User]</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/notification/#plankapy.v2.models.notification.Notification.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/notification/#plankapy.v2.models.notification.Notification.action","title":"action  <code>property</code>","text":"<pre><code>action: Action\n</code></pre> <p>The Action associated with the Notification</p>"},{"location":"v2/models/notification/#plankapy.v2.models.notification.Notification.board","title":"board  <code>property</code>","text":"<pre><code>board: Board\n</code></pre> <p>The Board associated with the Notification (denormalized)</p>"},{"location":"v2/models/notification/#plankapy.v2.models.notification.Notification.card","title":"card  <code>property</code>","text":"<pre><code>card: Card\n</code></pre> <p>The Card associated with the Notification</p>"},{"location":"v2/models/notification/#plankapy.v2.models.notification.Notification.comment","title":"comment  <code>property</code>","text":"<pre><code>comment: Comment\n</code></pre> <p>The Comment associated with the Notification</p>"},{"location":"v2/models/notification/#plankapy.v2.models.notification.Notification.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>When the Notification was created</p>"},{"location":"v2/models/notification/#plankapy.v2.models.notification.Notification.creator","title":"creator  <code>property</code>","text":"<pre><code>creator: User\n</code></pre> <p>The User who created the Notification</p>"},{"location":"v2/models/notification/#plankapy.v2.models.notification.Notification.data","title":"data  <code>property</code>","text":"<pre><code>data: dict[str, Any]\n</code></pre> <p>Notification specific data (varies by type)</p>"},{"location":"v2/models/notification/#plankapy.v2.models.notification.Notification.is_read","title":"is_read  <code>property</code> <code>writable</code>","text":"<pre><code>is_read: bool\n</code></pre> <p>Whether the Notification has been read</p>"},{"location":"v2/models/notification/#plankapy.v2.models.notification.Notification.type","title":"type  <code>property</code>","text":"<pre><code>type: NotificationType\n</code></pre> <p>Type of the Notification</p>"},{"location":"v2/models/notification/#plankapy.v2.models.notification.Notification.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>When the Notification was last updated</p>"},{"location":"v2/models/notification/#plankapy.v2.models.notification.Notification.user","title":"user  <code>property</code>","text":"<pre><code>user: User\n</code></pre> <p>The User who receives the Notification</p>"},{"location":"v2/models/notification/#plankapy.v2.models.notification.Notification.users","title":"users  <code>property</code>","text":"<pre><code>users: list[User]\n</code></pre> <p>All Users associated with the Notification</p>"},{"location":"v2/models/notification/#plankapy.v2.models.notification.Notification.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/notification/#plankapy.v2.models.notification.Notification.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/notification/#plankapy.v2.models.notification.Notification.sync","title":"sync","text":"<pre><code>sync()\n</code></pre> <p>Sync the Notification with the Planka server</p> Source code in <code>src/plankapy/v2/models/notification.py</code> <pre><code>def sync(self):\n    \"\"\"Sync the Notification with the Planka server\"\"\"\n    self.schema = self.endpoints.getNotification(self.id)['item']\n</code></pre>"},{"location":"v2/models/notification/#plankapy.v2.models.notification.Notification.update","title":"update","text":"<pre><code>update(**kwargs: Unpack[Request_updateNotification]) -&gt; None\n</code></pre> <p>Update the Notification</p> Source code in <code>src/plankapy/v2/models/notification.py</code> <pre><code>def update(self, **kwargs: Unpack[paths.Request_updateNotification]) -&gt; None:\n    \"\"\"Update the Notification\"\"\"\n    self.schema = self.endpoints.updateNotification(self.id, **kwargs)['item']\n</code></pre>"},{"location":"v2/models/project-manager/","title":"Project Manager","text":"CLASS DESCRIPTION <code>ProjectManager</code> <p>Python interface for Planka ProjectManagers</p>"},{"location":"v2/models/project-manager/#plankapy.v2.models.project_manager.ProjectManager","title":"ProjectManager","text":"<pre><code>ProjectManager(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[ProjectManager]</code></p> <p>Python interface for Planka ProjectManagers</p> Returned by: <ul> <li> Plankapy v2 models Project <code></code>\u00a0Project <ul> <li> <code></code>\u00a0project_managers </li> <li> <code></code>\u00a0add_project_manager </li> </ul> </li> </ul> Used by: <ul> <li> Plankapy v2 models Project <code></code>\u00a0Project <code></code>\u00a0remove_project_manager </li> </ul> METHOD DESCRIPTION <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> <code>sync</code> <p>Sync the ProjectManager with the Planka server</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>created_at</code> <p>When the ProjectManager was created</p> <p> TYPE: <code>datetime</code> </p> <code>project</code> <p>The Project associated with the ProjectManager</p> <p> TYPE: <code>Project</code> </p> <code>updated_at</code> <p>When the ProjectManager was last updated</p> <p> TYPE: <code>datetime</code> </p> <code>user</code> <p>The User assigned as ProjectManager (Raises LookupError if the User cannot be found)</p> <p> TYPE: <code>User</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/project-manager/#plankapy.v2.models.project_manager.ProjectManager.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/project-manager/#plankapy.v2.models.project_manager.ProjectManager.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>When the ProjectManager was created</p>"},{"location":"v2/models/project-manager/#plankapy.v2.models.project_manager.ProjectManager.project","title":"project  <code>property</code>","text":"<pre><code>project: Project\n</code></pre> <p>The Project associated with the ProjectManager</p>"},{"location":"v2/models/project-manager/#plankapy.v2.models.project_manager.ProjectManager.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>When the ProjectManager was last updated</p>"},{"location":"v2/models/project-manager/#plankapy.v2.models.project_manager.ProjectManager.user","title":"user  <code>property</code>","text":"<pre><code>user: User\n</code></pre> <p>The User assigned as ProjectManager (Raises LookupError if the User cannot be found)</p>"},{"location":"v2/models/project-manager/#plankapy.v2.models.project_manager.ProjectManager.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/project-manager/#plankapy.v2.models.project_manager.ProjectManager.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/project-manager/#plankapy.v2.models.project_manager.ProjectManager.sync","title":"sync","text":"<pre><code>sync()\n</code></pre> <p>Sync the ProjectManager with the Planka server</p> Source code in <code>src/plankapy/v2/models/project_manager.py</code> <pre><code>def sync(self):\n    \"\"\"Sync the ProjectManager with the Planka server\"\"\"\n    pms = self.project.project_managers\n    for pm in pms:\n        if pm.id == self.id:\n            self.schema = pm.schema\n</code></pre>"},{"location":"v2/models/project/","title":"Project","text":"CLASS DESCRIPTION <code>Project</code> <p>Python interface for Planka Projects</p>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project","title":"Project","text":"<pre><code>Project(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[Project]</code></p> <p>Python interface for Planka Projects</p> Returned by: <ul> <li> Plankapy v2 <ul> <li> models <ul> <li> Background Image <code></code>\u00a0BackgroundImage <code></code>\u00a0project </li> <li> Base Custom Field Group <code></code>\u00a0BaseCustomFieldGroup <code></code>\u00a0project </li> <li> Board <code></code>\u00a0Board <ul> <li> <code></code>\u00a0project </li> <li> <code></code>\u00a0projects </li> </ul> </li> <li> Board Membership <code></code>\u00a0BoardMembership <code></code>\u00a0project </li> <li> Card <code></code>\u00a0Card <code></code>\u00a0project </li> <li> Project Manager <code></code>\u00a0ProjectManager <code></code>\u00a0project </li> </ul> </li> <li> interface Planka Interface <code></code>\u00a0interface <code></code>\u00a0Planka <ul> <li> <code></code>\u00a0projects </li> <li> <code></code>\u00a0create_project </li> </ul> </li> </ul> </li> </ul> Used by: <ul> <li> Plankapy v2 models Custom Field Group <code></code>\u00a0CustomFieldGroup <code></code>\u00a0make_base_group </li> </ul> METHOD DESCRIPTION <code>add_project_manager</code> <p>Add a User to the Project as a ProjectManager</p> <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>create_base_custom_field_group</code> <p>Create a BaseCustomFieldGroup in the Project</p> <code>create_board</code> <p>Create a new Board in the Project</p> <code>delete</code> <p>Delete the Project</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> <code>import_board</code> <p>Import a board from a file (currently supports trello imports only)</p> <code>remove_background</code> <p>Reset the Project background to the default grey</p> <code>remove_project_manager</code> <p>Remove a ProjectManager from the Project</p> <code>update</code> <p>Update the Project</p> <code>update_background_image</code> <p>Update the Project Background Image,</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>background_gradient</code> <p>Gradient background for the project</p> <p> TYPE: <code>BackgroundGradient | None</code> </p> <code>background_image</code> <p>The current BackgroundImage of the Project</p> <p> TYPE: <code>BackgroundImage | None</code> </p> <code>background_images</code> <p>Get BackgroundImages associated with the Project</p> <p> TYPE: <code>list[BackgroundImage]</code> </p> <code>background_type</code> <p>Type of background for the project</p> <p> </p> <code>base_custom_field_groups</code> <p>Get BaseCustomFieldGroups associated with the Project</p> <p> TYPE: <code>list[BaseCustomFieldGroup]</code> </p> <code>board_memberships</code> <p>Get BoardMemberships associated with the Project</p> <p> TYPE: <code>list[BoardMembership]</code> </p> <code>boards</code> <p>Get Boards associated with the Project</p> <p> TYPE: <code>list[Board]</code> </p> <code>created_at</code> <p>When the project was created</p> <p> TYPE: <code>datetime</code> </p> <code>custom_fields</code> <p>Get CustomFields associated with the Project</p> <p> TYPE: <code>list[CustomField]</code> </p> <code>description</code> <p>Detailed description of the Project</p> <p> TYPE: <code>str</code> </p> <code>favorite</code> <p>Whether the project is in the current User's favorites</p> <p> TYPE: <code>bool</code> </p> <code>hidden</code> <p>Whether the project is hidden</p> <p> TYPE: <code>bool</code> </p> <code>name</code> <p>Name/title of the Project</p> <p> TYPE: <code>str</code> </p> <code>notification_services</code> <p>Get NotificationServices associated with the Project</p> <p> TYPE: <code>list[NotificationService]</code> </p> <code>owner</code> <p>The User who owns the project (Raises LookupError if the User cannot be found)</p> <p> TYPE: <code>User | None</code> </p> <code>project_managers</code> <p>Get project manager Users associated with the Project</p> <p> TYPE: <code>list[ProjectManager]</code> </p> <code>updated_at</code> <p>When the project was last updated</p> <p> TYPE: <code>datetime</code> </p> <code>users</code> <p>Get Users associated with the Project</p> <p> TYPE: <code>list[User]</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.background_gradient","title":"background_gradient  <code>property</code> <code>writable</code>","text":"<pre><code>background_gradient: BackgroundGradient | None\n</code></pre> <p>Gradient background for the project</p>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.background_image","title":"background_image  <code>property</code> <code>writable</code>","text":"<pre><code>background_image: BackgroundImage | None\n</code></pre> <p>The current BackgroundImage of the Project</p>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.background_images","title":"background_images  <code>property</code>","text":"<pre><code>background_images: list[BackgroundImage]\n</code></pre> <p>Get BackgroundImages associated with the Project</p>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.background_type","title":"background_type  <code>property</code> <code>writable</code>","text":"<pre><code>background_type\n</code></pre> <p>Type of background for the project</p>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.base_custom_field_groups","title":"base_custom_field_groups  <code>property</code>","text":"<pre><code>base_custom_field_groups: list[BaseCustomFieldGroup]\n</code></pre> <p>Get BaseCustomFieldGroups associated with the Project</p>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.board_memberships","title":"board_memberships  <code>property</code>","text":"<pre><code>board_memberships: list[BoardMembership]\n</code></pre> <p>Get BoardMemberships associated with the Project</p>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.boards","title":"boards  <code>property</code>","text":"<pre><code>boards: list[Board]\n</code></pre> <p>Get Boards associated with the Project</p>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>When the project was created</p>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.custom_fields","title":"custom_fields  <code>property</code>","text":"<pre><code>custom_fields: list[CustomField]\n</code></pre> <p>Get CustomFields associated with the Project</p>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.description","title":"description  <code>property</code> <code>writable</code>","text":"<pre><code>description: str\n</code></pre> <p>Detailed description of the Project</p>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.favorite","title":"favorite  <code>property</code> <code>writable</code>","text":"<pre><code>favorite: bool\n</code></pre> <p>Whether the project is in the current User's favorites</p>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.hidden","title":"hidden  <code>property</code> <code>writable</code>","text":"<pre><code>hidden: bool\n</code></pre> <p>Whether the project is hidden</p>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the Project</p>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.notification_services","title":"notification_services  <code>property</code>","text":"<pre><code>notification_services: list[NotificationService]\n</code></pre> <p>Get NotificationServices associated with the Project</p>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.owner","title":"owner  <code>property</code>","text":"<pre><code>owner: User | None\n</code></pre> <p>The User who owns the project (Raises LookupError if the User cannot be found)</p>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.project_managers","title":"project_managers  <code>property</code>","text":"<pre><code>project_managers: list[ProjectManager]\n</code></pre> <p>Get project manager Users associated with the Project</p>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>When the project was last updated</p>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.users","title":"users  <code>property</code>","text":"<pre><code>users: list[User]\n</code></pre> <p>Get Users associated with the Project</p>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.add_project_manager","title":"add_project_manager","text":"<pre><code>add_project_manager(user: User) -&gt; ProjectManager\n</code></pre> <p>Add a User to the Project as a ProjectManager</p> Source code in <code>src/plankapy/v2/models/project.py</code> <pre><code>def add_project_manager(self, user: User) -&gt; ProjectManager:\n    \"\"\"Add a User to the Project as a ProjectManager\"\"\"\n    return ProjectManager(self.endpoints.createProjectManager(self.id, userId=user.id)['item'], self.session)\n</code></pre>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.create_base_custom_field_group","title":"create_base_custom_field_group","text":"<pre><code>create_base_custom_field_group(*, name: str) -&gt; BaseCustomFieldGroup\n</code></pre> <p>Create a BaseCustomFieldGroup in the Project</p> PARAMETER DESCRIPTION <p>The name of the new BaseCustomFieldGroup</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/plankapy/v2/models/project.py</code> <pre><code>def create_base_custom_field_group(self, \n                                   *, \n                                   name: str) -&gt; BaseCustomFieldGroup:\n    \"\"\"Create a BaseCustomFieldGroup in the Project\n\n    Args:\n        name: The name of the new BaseCustomFieldGroup\n    \"\"\"\n    return BaseCustomFieldGroup(\n        self.endpoints.createBaseCustomFieldGroup(\n            self.id, \n            name=name,\n        )['item'], \n        self.session\n    )\n</code></pre>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.create_base_custom_field_group(name)","title":"<code>name</code>","text":""},{"location":"v2/models/project/#plankapy.v2.models.project.Project.create_board","title":"create_board","text":"<pre><code>create_board(*, name: str, position: Position | int = 'top') -&gt; Board\n</code></pre> <p>Create a new Board in the Project</p> PARAMETER DESCRIPTION <p>The name of the Board</p> <p> TYPE: <code>str</code> </p> <p>The position of the board within the project</p> <p> TYPE: <code>Position | int</code> DEFAULT: <code>'top'</code> </p> Source code in <code>src/plankapy/v2/models/project.py</code> <pre><code>def create_board(self, \n                 *, \n                 name: str, \n                 position: Position | int ='top') -&gt; Board:\n    \"\"\"Create a new Board in the Project\n\n    Args:\n        name: The name of the Board\n        position: The position of the board within the project\n    \"\"\"\n    return Board(\n        self.endpoints.createBoard(\n            self.id, \n            name=name, \n            position=get_position(self.boards, position)\n        )['item'], \n        self.session\n    )\n</code></pre>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.create_board(name)","title":"<code>name</code>","text":""},{"location":"v2/models/project/#plankapy.v2.models.project.Project.create_board(position)","title":"<code>position</code>","text":""},{"location":"v2/models/project/#plankapy.v2.models.project.Project.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete the Project</p> Source code in <code>src/plankapy/v2/models/project.py</code> <pre><code>def delete(self) -&gt; None:\n    \"\"\"Delete the Project\"\"\"\n    self.endpoints.deleteProject(self.id)\n</code></pre>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.import_board","title":"import_board","text":"<pre><code>import_board(*, name: str, import_file: bytes, position: Position | int = 'top', import_type: BoardImportType = 'trello', request_id: str | None = None) -&gt; Board\n</code></pre> <p>Import a board from a file (currently supports trello imports only)</p> PARAMETER DESCRIPTION <p>The name of the imported Board</p> <p> TYPE: <code>str</code> </p> <p>The position of the imported Board within the Project</p> <p> TYPE: <code>Position | int</code> DEFAULT: <code>'top'</code> </p> <p>The type of the Bord import (currently <code>trello</code> only)</p> <p> TYPE: <code>BoardImportType</code> DEFAULT: <code>'trello'</code> </p> <p>An optional request ID for tracking upload progress (default: <code>now in iso8601</code>)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/plankapy/v2/models/project.py</code> <pre><code>def import_board(self, \n                 *, \n                 name: str, \n                 import_file: bytes, \n                 position: Position | int='top', \n                 import_type: BoardImportType='trello',\n                 request_id: str|None=None) -&gt; Board:\n    \"\"\"Import a board from a file (currently supports trello imports only)\n\n    Args:\n        name: The name of the imported Board\n        position: The position of the imported Board within the Project\n        import_type: The type of the Bord import (currently `trello` only)\n        request_id: An optional request ID for tracking upload progress (default: `now in iso8601`)\n    \"\"\"\n    return Board(\n        self.endpoints.createBoard(\n            self.id,\n            name=name,\n            position=get_position(self.boards, position),\n            importType=import_type,\n            importFile=import_file,\n            requestId=request_id or datetime.now().isoformat(),\n        )['item'],\n        self.session\n    )\n</code></pre>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.import_board(name)","title":"<code>name</code>","text":""},{"location":"v2/models/project/#plankapy.v2.models.project.Project.import_board(position)","title":"<code>position</code>","text":""},{"location":"v2/models/project/#plankapy.v2.models.project.Project.import_board(import_type)","title":"<code>import_type</code>","text":""},{"location":"v2/models/project/#plankapy.v2.models.project.Project.import_board(request_id)","title":"<code>request_id</code>","text":""},{"location":"v2/models/project/#plankapy.v2.models.project.Project.remove_background","title":"remove_background","text":"<pre><code>remove_background() -&gt; None\n</code></pre> <p>Reset the Project background to the default grey</p> Source code in <code>src/plankapy/v2/models/project.py</code> <pre><code>def remove_background(self) -&gt; None:\n    \"\"\"Reset the Project background to the default grey\"\"\"\n    self.update(backgroundType=None)\n</code></pre>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.remove_project_manager","title":"remove_project_manager","text":"<pre><code>remove_project_manager(project_manager: ProjectManager | User) -&gt; None\n</code></pre> <p>Remove a ProjectManager from the Project</p> Source code in <code>src/plankapy/v2/models/project.py</code> <pre><code>def remove_project_manager(self, project_manager: ProjectManager | User) -&gt; None:\n    \"\"\"Remove a ProjectManager from the Project\"\"\"\n    if isinstance(project_manager, User):\n        # Get the ProjectManager object for the User\n        for pm in self.project_managers:\n            if pm.user == project_manager:\n                project_manager = pm\n                break\n        else:\n            # If User not in managers, do nothing\n            return\n\n    if project_manager.project == self:\n        # Only delete ProjectManager if it is for this Project\n        # Defer deletion to the ProjectManager object\n        project_manager.delete()\n</code></pre>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.update","title":"update","text":"<pre><code>update(**project: Unpack[Request_updateProject]) -&gt; None\n</code></pre> <p>Update the Project</p> Source code in <code>src/plankapy/v2/models/project.py</code> <pre><code>def update(self, **project: Unpack[paths.Request_updateProject]) -&gt; None:\n    \"\"\"Update the Project\"\"\"\n    self.schema = self.endpoints.updateProject(self.id, **project)['item']\n</code></pre>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.update_background_image","title":"update_background_image","text":"<pre><code>update_background_image(background: BackgroundImage | Path | str | bytes | None) -&gt; BackgroundImage | None\n</code></pre> <p>Update the Project Background Image,</p> <p>Only Admins and ProjectManagers can update the Background Image</p> PARAMETER DESCRIPTION <p>Existing Image or filepath/url or raw bytes or None to unset</p> <p> TYPE: <code>BackgroundImage | Path | str | bytes | None</code> </p> RETURNS DESCRIPTION <code>BackgroundImage | None</code> <p>If a backround image was set or created</p> Source code in <code>src/plankapy/v2/models/project.py</code> <pre><code>def update_background_image(self, background: BackgroundImage | Path | str | bytes | None) -&gt; BackgroundImage | None:\n    \"\"\"Update the Project Background Image,\n\n    Only Admins and ProjectManagers can update the Background Image\n\n    Args:\n        background (BackgroundImage | Path | str | bytes | None): Existing Image or filepath/url or raw bytes or None to unset\n\n    Returns:\n        (BackgroundImage | None): If a backround image was set or created\n    \"\"\"\n    # Force a PermissionError early if this user isn't the current user or an admin\n    if self.id != self.session.current_id and self.session.current_role != 'admin':\n        self.endpoints.createBackgroundImage(self.id, **{'file': b'NO_PERMISSION'})\n\n    if background is None:\n        self.remove_background()\n        return\n\n    if isinstance(background, BackgroundImage):\n        # Assign the image if it is in this project\n        if background in self.background_images:\n            self.background_image = background\n\n        # Re-Upload to this project\n        else:\n            self.update_background_image(background.url)\n        return background\n\n    if isinstance(background, Path):\n        # Convert Path to a string so it can be handled normally\n        background = str(background.resolve())\n\n    # Deferred import of mimetypes that is only used here\n    # This function takes so long anyways so the import delay \n    # isn't noticable\n    import mimetypes\n\n    # Handle filepath or URL\n    mime_type = None\n    if isinstance(background, str):\n        # Guess URL file type\n        if background.startswith('http'):\n            mime_type, *_ = mimetypes.guess_type(background)\n            mime_type = mime_type or 'application/octet-stream'\n            try:\n                req = self.client.get(background)\n                req.raise_for_status()\n                background = req.content\n            except HTTPStatusError as status_error:\n                status_error.add_note(f'Unable to download attachment from {background}')\n                raise\n        # Guess local file type\n        # And read Bytes\n        else:\n            mime_type, *_ = mimetypes.guess_file_type(background)\n            mime_type = mime_type or 'application/octet-stream'\n            background = open(background, 'rb').read()\n\n    mime_type = mime_type or 'application/octet-stream'\n    return BackgroundImage(\n        self.endpoints.createBackgroundImage(\n            self.id, \n            file=bytes(background), \n            mime_type=mime_type,\n        )['item'],\n        self.session\n    )\n</code></pre>"},{"location":"v2/models/project/#plankapy.v2.models.project.Project.update_background_image(background)","title":"<code>background</code>","text":""},{"location":"v2/models/task-list/","title":"Task List","text":"CLASS DESCRIPTION <code>TaskList</code> <p>Python interface for Planka TaskLists</p>"},{"location":"v2/models/task-list/#plankapy.v2.models.task_list.TaskList","title":"TaskList","text":"<pre><code>TaskList(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[TaskList]</code></p> <p>Python interface for Planka TaskLists</p> Returned by: <ul> <li> Plankapy v2 models <ul> <li> Board <code></code>\u00a0Board <code></code>\u00a0task_lists </li> <li> Card <code></code>\u00a0Card <ul> <li> <code></code>\u00a0task_lists </li> <li> <code></code>\u00a0add_task_list </li> <li> <code></code>\u00a0create_task_list </li> </ul> </li> <li> List <code></code>\u00a0List <code></code>\u00a0task_lists </li> <li> Task <code></code>\u00a0Task <code></code>\u00a0task_list </li> </ul> </li> </ul> Used by: <ul> <li> Plankapy v2 models Card <code></code>\u00a0Card <code></code>\u00a0add_task_list </li> </ul> METHOD DESCRIPTION <code>add_task</code> <p>Create a new Task in the TaskList</p> <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>delete</code> <p>Delete the TaskList</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> <code>positon</code> <p>Set the TaskList position within the Card</p> <code>sync</code> <p>Sync the TaskList with the Planka server</p> <code>update</code> <p>Update the TaskList</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>card</code> <p>The Card the TaskList belongs to</p> <p> TYPE: <code>Card</code> </p> <code>created_at</code> <p>When the TaskList was created</p> <p> TYPE: <code>datetime</code> </p> <code>hide_completed_tasks</code> <p>Whether to hide completed Tasks</p> <p> TYPE: <code>bool</code> </p> <code>name</code> <p>Name/title of the TaskList</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the TaskList within the Card</p> <p> TYPE: <code>int</code> </p> <code>show_on_front_of_card</code> <p>Whether to show the TaskList on the front of the Card</p> <p> TYPE: <code>bool</code> </p> <code>tasks</code> <p>All Tasks associated with the TaskList</p> <p> TYPE: <code>list[Task]</code> </p> <code>updated_at</code> <p>When the TaskList was last updated</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/task-list/#plankapy.v2.models.task_list.TaskList.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/task-list/#plankapy.v2.models.task_list.TaskList.card","title":"card  <code>property</code>","text":"<pre><code>card: Card\n</code></pre> <p>The Card the TaskList belongs to</p>"},{"location":"v2/models/task-list/#plankapy.v2.models.task_list.TaskList.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>When the TaskList was created</p>"},{"location":"v2/models/task-list/#plankapy.v2.models.task_list.TaskList.hide_completed_tasks","title":"hide_completed_tasks  <code>property</code> <code>writable</code>","text":"<pre><code>hide_completed_tasks: bool\n</code></pre> <p>Whether to hide completed Tasks</p>"},{"location":"v2/models/task-list/#plankapy.v2.models.task_list.TaskList.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the TaskList</p>"},{"location":"v2/models/task-list/#plankapy.v2.models.task_list.TaskList.position","title":"position  <code>property</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the TaskList within the Card</p>"},{"location":"v2/models/task-list/#plankapy.v2.models.task_list.TaskList.show_on_front_of_card","title":"show_on_front_of_card  <code>property</code> <code>writable</code>","text":"<pre><code>show_on_front_of_card: bool\n</code></pre> <p>Whether to show the TaskList on the front of the Card</p>"},{"location":"v2/models/task-list/#plankapy.v2.models.task_list.TaskList.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: list[Task]\n</code></pre> <p>All Tasks associated with the TaskList</p>"},{"location":"v2/models/task-list/#plankapy.v2.models.task_list.TaskList.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>When the TaskList was last updated</p>"},{"location":"v2/models/task-list/#plankapy.v2.models.task_list.TaskList.add_task","title":"add_task","text":"<pre><code>add_task(name: str, *, is_completed: bool = False, position: Position = 'top', linked_card: Card | None = None) -&gt; Task\n</code></pre> <p>Create a new Task in the TaskList</p> PARAMETER DESCRIPTION <p>The name of the task</p> <p> TYPE: <code>str</code> </p> <p>Is the task completed or not (default: <code>False</code>)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Position of the task in the TaskList (default: <code>top</code>)</p> <p> TYPE: <code>Position | int</code> DEFAULT: <code>'top'</code> </p> <p>Optional Card to link the Task to (default: <code>None</code>)</p> <p> TYPE: <code>Card | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/plankapy/v2/models/task_list.py</code> <pre><code>def add_task(self, name: str, *, \n             is_completed: bool=False, \n             position: Position='top',\n             linked_card: Card|None=None) -&gt; Task:\n    \"\"\"Create a new Task in the TaskList\n\n    Args:\n        name (str): The name of the task\n        is_completed (bool): Is the task completed or not (default: `False`)\n        position (Position | int): Position of the task in the TaskList (default: `top`)\n        linked_card (Card|None): Optional Card to link the Task to (default: `None`)\n    \"\"\"\n    args = { # type: ignore\n        'name': name,\n        'position': get_position(self.tasks, position),\n        'isCompleted': is_completed\n    }\n    if linked_card is not None:\n        args['linkedCardId'] = linked_card.id\n\n    return Task(\n        self.endpoints.createTask(\n            self.id, \n            **args, # type: ignore\n            )['item'],  \n        self.session\n    )\n</code></pre>"},{"location":"v2/models/task-list/#plankapy.v2.models.task_list.TaskList.add_task(name)","title":"<code>name</code>","text":""},{"location":"v2/models/task-list/#plankapy.v2.models.task_list.TaskList.add_task(is_completed)","title":"<code>is_completed</code>","text":""},{"location":"v2/models/task-list/#plankapy.v2.models.task_list.TaskList.add_task(position)","title":"<code>position</code>","text":""},{"location":"v2/models/task-list/#plankapy.v2.models.task_list.TaskList.add_task(linked_card)","title":"<code>linked_card</code>","text":""},{"location":"v2/models/task-list/#plankapy.v2.models.task_list.TaskList.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/task-list/#plankapy.v2.models.task_list.TaskList.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the TaskList</p> Source code in <code>src/plankapy/v2/models/task_list.py</code> <pre><code>def delete(self):\n    \"\"\"Delete the TaskList\"\"\"\n    self.endpoints.deleteTaskList(self.id)\n</code></pre>"},{"location":"v2/models/task-list/#plankapy.v2.models.task_list.TaskList.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/task-list/#plankapy.v2.models.task_list.TaskList.positon","title":"positon","text":"<pre><code>positon(position: int) -&gt; None\n</code></pre> <p>Set the TaskList position within the Card</p> Source code in <code>src/plankapy/v2/models/task_list.py</code> <pre><code>@position.setter\ndef positon(self, position: int) -&gt; None:\n    \"\"\"Set the TaskList position within the Card\"\"\"\n    self.update(position=position)\n</code></pre>"},{"location":"v2/models/task-list/#plankapy.v2.models.task_list.TaskList.sync","title":"sync","text":"<pre><code>sync()\n</code></pre> <p>Sync the TaskList with the Planka server</p> Source code in <code>src/plankapy/v2/models/task_list.py</code> <pre><code>def sync(self):\n    \"\"\"Sync the TaskList with the Planka server\"\"\"\n    self.schema = self.endpoints.getTaskList(self.id)['item']\n</code></pre>"},{"location":"v2/models/task-list/#plankapy.v2.models.task_list.TaskList.update","title":"update","text":"<pre><code>update(**kwargs: Unpack[Request_updateTaskList])\n</code></pre> <p>Update the TaskList</p> Source code in <code>src/plankapy/v2/models/task_list.py</code> <pre><code>def update(self, **kwargs: Unpack[paths.Request_updateTaskList]):\n    \"\"\"Update the TaskList\"\"\"\n    self.schema = self.endpoints.updateTaskList(self.id, **kwargs)['item']\n</code></pre>"},{"location":"v2/models/task/","title":"Task","text":"CLASS DESCRIPTION <code>Task</code> <p>Python interface for Planka Tasks</p>"},{"location":"v2/models/task/#plankapy.v2.models.task.Task","title":"Task","text":"<pre><code>Task(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[Task]</code></p> <p>Python interface for Planka Tasks</p> Returned by: <ul> <li> Plankapy v2 models <ul> <li> Board <code></code>\u00a0Board <code></code>\u00a0tasks </li> <li> Card <code></code>\u00a0Card <code></code>\u00a0tasks </li> <li> List <code></code>\u00a0List <code></code>\u00a0tasks </li> <li> Task List <code></code>\u00a0TaskList <ul> <li> <code></code>\u00a0tasks </li> <li> <code></code>\u00a0add_task </li> </ul> </li> </ul> </li> </ul> METHOD DESCRIPTION <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>delete</code> <p>Delete the Task</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> <code>sync</code> <p>Sync the Task with the Planka server</p> <code>update</code> <p>Update the Task</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>assignee</code> <p>The User assigned to the Task if there is one</p> <p> TYPE: <code>User | None</code> </p> <code>card</code> <p>The Card the Task is linked to</p> <p> TYPE: <code>Card</code> </p> <code>created_at</code> <p>When the Task was created</p> <p> TYPE: <code>datetime</code> </p> <code>is_completed</code> <p>Whether the Task is completed</p> <p> TYPE: <code>bool</code> </p> <code>name</code> <p>Name/title of the Task</p> <p> TYPE: <code>str</code> </p> <code>position</code> <p>Position of the Task within the TaskList</p> <p> TYPE: <code>int</code> </p> <code>task_list</code> <p>The TaskList the Task belongs to</p> <p> TYPE: <code>TaskList</code> </p> <code>updated_at</code> <p>When the Task was last updated</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/task/#plankapy.v2.models.task.Task.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/task/#plankapy.v2.models.task.Task.assignee","title":"assignee  <code>property</code> <code>writable</code>","text":"<pre><code>assignee: User | None\n</code></pre> <p>The User assigned to the Task if there is one</p>"},{"location":"v2/models/task/#plankapy.v2.models.task.Task.card","title":"card  <code>property</code>","text":"<pre><code>card: Card\n</code></pre> <p>The Card the Task is linked to</p>"},{"location":"v2/models/task/#plankapy.v2.models.task.Task.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>When the Task was created</p>"},{"location":"v2/models/task/#plankapy.v2.models.task.Task.is_completed","title":"is_completed  <code>property</code> <code>writable</code>","text":"<pre><code>is_completed: bool\n</code></pre> <p>Whether the Task is completed</p>"},{"location":"v2/models/task/#plankapy.v2.models.task.Task.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the Task</p>"},{"location":"v2/models/task/#plankapy.v2.models.task.Task.position","title":"position  <code>property</code> <code>writable</code>","text":"<pre><code>position: int\n</code></pre> <p>Position of the Task within the TaskList</p>"},{"location":"v2/models/task/#plankapy.v2.models.task.Task.task_list","title":"task_list  <code>property</code> <code>writable</code>","text":"<pre><code>task_list: TaskList\n</code></pre> <p>The TaskList the Task belongs to</p>"},{"location":"v2/models/task/#plankapy.v2.models.task.Task.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>When the Task was last updated</p>"},{"location":"v2/models/task/#plankapy.v2.models.task.Task.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/task/#plankapy.v2.models.task.Task.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the Task</p> Source code in <code>src/plankapy/v2/models/task.py</code> <pre><code>def delete(self):\n    \"\"\"Delete the Task\"\"\"\n    self.endpoints.deleteTask(self.id)\n</code></pre>"},{"location":"v2/models/task/#plankapy.v2.models.task.Task.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/task/#plankapy.v2.models.task.Task.sync","title":"sync","text":"<pre><code>sync()\n</code></pre> <p>Sync the Task with the Planka server</p> Source code in <code>src/plankapy/v2/models/task.py</code> <pre><code>def sync(self):\n    \"\"\"Sync the Task with the Planka server\"\"\"\n    _tsks = [tsk for tsk in self.task_list.tasks if tsk == self]\n    if _tsks:\n        self.schema = _tsks.pop().schema\n</code></pre>"},{"location":"v2/models/task/#plankapy.v2.models.task.Task.update","title":"update","text":"<pre><code>update(**kwargs: Unpack[Request_updateTask])\n</code></pre> <p>Update the Task</p> Source code in <code>src/plankapy/v2/models/task.py</code> <pre><code>def update(self, **kwargs: Unpack[paths.Request_updateTask]):\n    \"\"\"Update the Task\"\"\"\n    self.schema = self.endpoints.updateTask(self.id, **kwargs)['item']\n</code></pre>"},{"location":"v2/models/user/","title":"User","text":"CLASS DESCRIPTION <code>User</code> <p>Python interface for Planka Users</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User","title":"User","text":"<pre><code>User(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[User]</code></p> <p>Python interface for Planka Users</p> Returned by: <ul> <li> Plankapy v2 <ul> <li> models <ul> <li> Action <code></code>\u00a0Action <code></code>\u00a0user </li> <li> Attachment <code></code>\u00a0Attachment <code></code>\u00a0creator </li> <li> Board <code></code>\u00a0Board <ul> <li> <code></code>\u00a0editors </li> <li> <code></code>\u00a0users </li> <li> <code></code>\u00a0viewers </li> <li> <code></code>\u00a0remove_user </li> <li> <code></code>\u00a0remove_users </li> </ul> </li> <li> Board Membership <code></code>\u00a0BoardMembership <code></code>\u00a0user </li> <li> Card <code></code>\u00a0Card <ul> <li> <code></code>\u00a0creator </li> <li> <code></code>\u00a0members </li> <li> <code></code>\u00a0users </li> <li> <code></code>\u00a0remove_member </li> <li> <code></code>\u00a0remove_members </li> </ul> </li> <li> Card Membership <code></code>\u00a0CardMembership <code></code>\u00a0user </li> <li> Comment <code></code>\u00a0Comment <code></code>\u00a0user </li> <li> List <code></code>\u00a0List <code></code>\u00a0users </li> <li> Notification <code></code>\u00a0Notification <ul> <li> <code></code>\u00a0creator </li> <li> <code></code>\u00a0user </li> <li> <code></code>\u00a0users </li> </ul> </li> <li> Notification Service <code></code>\u00a0NotificationService <code></code>\u00a0user </li> <li> Project <code></code>\u00a0Project <ul> <li> <code></code>\u00a0owner </li> <li> <code></code>\u00a0users </li> </ul> </li> <li> Project Manager <code></code>\u00a0ProjectManager <code></code>\u00a0user </li> <li> Task <code></code>\u00a0Task <code></code>\u00a0assignee </li> <li> User <code></code>\u00a0User <code></code>\u00a0update_avatar </li> </ul> </li> <li> interface Planka Interface <code></code>\u00a0interface <code></code>\u00a0Planka <ul> <li> <code></code>\u00a0me </li> <li> <code></code>\u00a0users </li> <li> <code></code>\u00a0create_user </li> </ul> </li> </ul> </li> </ul> Used by: <ul> <li> Plankapy v2 models <ul> <li> Board <code></code>\u00a0Board <ul> <li> <code></code>\u00a0add_editor </li> <li> <code></code>\u00a0add_editors </li> <li> <code></code>\u00a0add_member </li> <li> <code></code>\u00a0add_members </li> <li> <code></code>\u00a0add_viewer </li> <li> <code></code>\u00a0add_viewers </li> <li> <code></code>\u00a0filter </li> <li> <code></code>\u00a0remove_user </li> <li> <code></code>\u00a0remove_users </li> </ul> </li> <li> Card <code></code>\u00a0Card <ul> <li> <code></code>\u00a0add_member </li> <li> <code></code>\u00a0add_members </li> <li> <code></code>\u00a0comment </li> <li> <code></code>\u00a0remove_member </li> <li> <code></code>\u00a0remove_members </li> </ul> </li> <li> List <code></code>\u00a0List <code></code>\u00a0filter </li> <li> Project <code></code>\u00a0Project <ul> <li> <code></code>\u00a0add_project_manager </li> <li> <code></code>\u00a0remove_project_manager </li> </ul> </li> </ul> </li> </ul> METHOD DESCRIPTION <code>add_notification_service</code> <p>Add/Copy an existing NotificationService to this User</p> <code>add_to_board</code> <p>Add the User to a board</p> <code>add_to_card</code> <p>Add the User to a Card</p> <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>create_notification_service</code> <p>Create a NEW Notification Service</p> <code>delete</code> <p>Delete the User</p> <code>delete_notification_service</code> <p>Deletes a NotificationService for a User</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> <code>remove_from_board</code> <p>Remove the User from a Board</p> <code>remove_from_card</code> <p>Remove the User from a Card</p> <code>sync</code> <p>Sync the User with the Planka server (Can only sync your own User)</p> <code>update</code> <p>Update the User</p> <code>update_avatar</code> <p>Update the User avatar</p> <code>update_email</code> <p>Update the current User's email</p> <code>update_password</code> <p>Update the User's password</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>avatar</code> <p>Avatar information for the user with generated URLs</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>created_at</code> <p>When the user was created</p> <p> TYPE: <code>datetime</code> </p> <code>default_editor_mode</code> <p>Default markdown editor mode (personal field)</p> <p> TYPE: <code>EditorMode</code> </p> <code>default_home_view</code> <p>Default view mode for the home page (personal field)</p> <p> TYPE: <code>HomeView | None</code> </p> <code>default_projects_order</code> <p>Default sort order for projects display (personal field)</p> <p> TYPE: <code>ProjectOrdering | None</code> </p> <code>email</code> <p>Email address for login and notifications (private field)</p> <p> TYPE: <code>str | None</code> </p> <code>enable_favorites_by_default</code> <p>Whether favorites are enabled by default (personal field)</p> <p> TYPE: <code>bool</code> </p> <code>gravatar_url</code> <p>Gravatar URL for the user (conditionally added if configured)</p> <p> TYPE: <code>str | None</code> </p> <code>is_deactivated</code> <p>Whether the user account is deactivated and cannot log in</p> <p> TYPE: <code>bool</code> </p> <code>is_default_admin</code> <p>Whether the user is the default admin (visible only to current user or admin)</p> <p> TYPE: <code>bool</code> </p> <code>is_sso_user</code> <p>Whether the user is SSO user (private field)</p> <p> TYPE: <code>bool</code> </p> <code>language</code> <p>Preferred language for user interface and notifications (personal field)</p> <p> TYPE: <code>Language | None</code> </p> <code>locked_field_names</code> <p>List of fields locked from editing (visible only to current user or admin)</p> <p> TYPE: <code>list[LockableField]</code> </p> <code>name</code> <p>Full display name of the user</p> <p> TYPE: <code>str</code> </p> <code>notification_services</code> <p>Get all User NotificationServices</p> <p> TYPE: <code>list[NotificationService]</code> </p> <code>organization</code> <p>Organization or company name</p> <p> TYPE: <code>str</code> </p> <code>phone</code> <p>Contact phone number</p> <p> TYPE: <code>str</code> </p> <code>role</code> <p>User role defining access permissions</p> <p> </p> <code>subscribe_to_card_when_commenting</code> <p>Whether the user subscribes to cards when commenting (personal field)</p> <p> TYPE: <code>bool</code> </p> <code>subscribe_to_own_cards</code> <p>Whether the user subscribes to their own cards (personal field)</p> <p> TYPE: <code>bool</code> </p> <code>terms_type</code> <p>Type of terms applicable to the user based on role</p> <p> TYPE: <code>TermsType</code> </p> <code>turn_off_recent_card_highlighting</code> <p>Whether recent card highlighting is disabled (personal field)</p> <p> TYPE: <code>bool</code> </p> <code>updated_at</code> <p>When the user was last updated</p> <p> TYPE: <code>datetime</code> </p> <code>username</code> <p>Unique username for user identification</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.avatar","title":"avatar  <code>property</code> <code>writable</code>","text":"<pre><code>avatar: dict[str, Any]\n</code></pre> <p>Avatar information for the user with generated URLs</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>When the user was created</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.default_editor_mode","title":"default_editor_mode  <code>property</code> <code>writable</code>","text":"<pre><code>default_editor_mode: EditorMode\n</code></pre> <p>Default markdown editor mode (personal field)</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.default_home_view","title":"default_home_view  <code>property</code> <code>writable</code>","text":"<pre><code>default_home_view: HomeView | None\n</code></pre> <p>Default view mode for the home page (personal field)</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.default_projects_order","title":"default_projects_order  <code>property</code> <code>writable</code>","text":"<pre><code>default_projects_order: ProjectOrdering | None\n</code></pre> <p>Default sort order for projects display (personal field)</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.email","title":"email  <code>property</code> <code>writable</code>","text":"<pre><code>email: str | None\n</code></pre> <p>Email address for login and notifications (private field)</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.enable_favorites_by_default","title":"enable_favorites_by_default  <code>property</code> <code>writable</code>","text":"<pre><code>enable_favorites_by_default: bool\n</code></pre> <p>Whether favorites are enabled by default (personal field)</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.gravatar_url","title":"gravatar_url  <code>property</code>","text":"<pre><code>gravatar_url: str | None\n</code></pre> <p>Gravatar URL for the user (conditionally added if configured)</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.is_deactivated","title":"is_deactivated  <code>property</code>","text":"<pre><code>is_deactivated: bool\n</code></pre> <p>Whether the user account is deactivated and cannot log in</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.is_default_admin","title":"is_default_admin  <code>property</code>","text":"<pre><code>is_default_admin: bool\n</code></pre> <p>Whether the user is the default admin (visible only to current user or admin)</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.is_sso_user","title":"is_sso_user  <code>property</code>","text":"<pre><code>is_sso_user: bool\n</code></pre> <p>Whether the user is SSO user (private field)</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.language","title":"language  <code>property</code> <code>writable</code>","text":"<pre><code>language: Language | None\n</code></pre> <p>Preferred language for user interface and notifications (personal field)</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.locked_field_names","title":"locked_field_names  <code>property</code>","text":"<pre><code>locked_field_names: list[LockableField]\n</code></pre> <p>List of fields locked from editing (visible only to current user or admin)</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str\n</code></pre> <p>Full display name of the user</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.notification_services","title":"notification_services  <code>property</code>","text":"<pre><code>notification_services: list[NotificationService]\n</code></pre> <p>Get all User NotificationServices</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.organization","title":"organization  <code>property</code> <code>writable</code>","text":"<pre><code>organization: str\n</code></pre> <p>Organization or company name</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.phone","title":"phone  <code>property</code> <code>writable</code>","text":"<pre><code>phone: str\n</code></pre> <p>Contact phone number</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.role","title":"role  <code>property</code> <code>writable</code>","text":"<pre><code>role\n</code></pre> <p>User role defining access permissions</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.subscribe_to_card_when_commenting","title":"subscribe_to_card_when_commenting  <code>property</code> <code>writable</code>","text":"<pre><code>subscribe_to_card_when_commenting: bool\n</code></pre> <p>Whether the user subscribes to cards when commenting (personal field)</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.subscribe_to_own_cards","title":"subscribe_to_own_cards  <code>property</code> <code>writable</code>","text":"<pre><code>subscribe_to_own_cards: bool\n</code></pre> <p>Whether the user subscribes to their own cards (personal field)</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.terms_type","title":"terms_type  <code>property</code>","text":"<pre><code>terms_type: TermsType\n</code></pre> <p>Type of terms applicable to the user based on role</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.turn_off_recent_card_highlighting","title":"turn_off_recent_card_highlighting  <code>property</code> <code>writable</code>","text":"<pre><code>turn_off_recent_card_highlighting: bool\n</code></pre> <p>Whether recent card highlighting is disabled (personal field)</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>When the user was last updated</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.username","title":"username  <code>property</code>","text":"<pre><code>username: str\n</code></pre> <p>Unique username for user identification</p>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.add_notification_service","title":"add_notification_service","text":"<pre><code>add_notification_service(notification_service: NotificationService, *, url: str | None = None, format: NotificationServiceFormat | None = None) -&gt; NotificationService\n</code></pre> <p>Add/Copy an existing NotificationService to this User</p> PARAMETER DESCRIPTION <p>The NotificaitonService to add</p> <p> TYPE: <code>NotificaitonService</code> </p> <p>Optional url override (default: from notification_service)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <p>Optional format override (default: from notification_service)</p> <p> TYPE: <code>NotificationServiceFormat | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/plankapy/v2/models/user.py</code> <pre><code>def add_notification_service(self, notification_service: NotificationService, \n                             *, \n                             url: str|None=None, \n                             format: NotificationServiceFormat|None=None) -&gt; NotificationService:\n    \"\"\"Add/Copy an existing NotificationService to this User\n\n    Args:\n        notificaiton_service (NotificaitonService): The NotificaitonService to add\n        url (str | None): Optional url override (default: from notification_service)\n        format (NotificationServiceFormat | None): Optional format override (default: from notification_service)\n    \"\"\"\n    if notification_service not in self.notification_services:\n        return self.create_notification_service(\n            url=url or notification_service.url,\n            format=format or notification_service.format\n        )\n    return notification_service\n</code></pre>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.add_notification_service(notificaiton_service)","title":"<code>notificaiton_service</code>","text":""},{"location":"v2/models/user/#plankapy.v2.models.user.User.add_notification_service(url)","title":"<code>url</code>","text":""},{"location":"v2/models/user/#plankapy.v2.models.user.User.add_notification_service(format)","title":"<code>format</code>","text":""},{"location":"v2/models/user/#plankapy.v2.models.user.User.add_to_board","title":"add_to_board","text":"<pre><code>add_to_board(board: Board, *, role: BoardRole = 'viewer', can_comment: bool = False) -&gt; None\n</code></pre> <p>Add the User to a board</p> PARAMETER DESCRIPTION <p>The role of the User in the Board (default: <code>viewer</code>)</p> <p> TYPE: <code>Literal['viewer', 'editor']</code> DEFAULT: <code>'viewer'</code> </p> <p>The comment permission for the user if <code>role</code> is set to <code>viewer</code> (default: <code>False</code>)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Note <p>If the User is already a Board member, but the role or comment permission are different,  the User role and comment permission will be updated</p> Source code in <code>src/plankapy/v2/models/user.py</code> <pre><code>def add_to_board(self, board: Board, \n                 *,\n                 role: BoardRole='viewer',\n                 can_comment: bool=False) -&gt; None:\n    \"\"\"Add the User to a board\n\n    Args:\n        role (Literal['viewer', 'editor']): The role of the User in the Board (default: `viewer`)\n        can_comment (bool): The comment permission for the user if `role` is set to `viewer` (default: `False`)\n\n    Note:\n        If the User is already a Board member, but the role or comment permission are different, \n        the User role and comment permission will be updated\n    \"\"\"\n    board.add_member(self, role=role, can_comment=can_comment)\n</code></pre>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.add_to_board(role)","title":"<code>role</code>","text":""},{"location":"v2/models/user/#plankapy.v2.models.user.User.add_to_board(can_comment)","title":"<code>can_comment</code>","text":""},{"location":"v2/models/user/#plankapy.v2.models.user.User.add_to_card","title":"add_to_card","text":"<pre><code>add_to_card(card: Card) -&gt; None\n</code></pre> <p>Add the User to a Card</p> PARAMETER DESCRIPTION <p>The Card to add the user to (must be a member of the Card's Board)</p> <p> TYPE: <code>Card</code> </p> RAISES DESCRIPTION <code>PermissionError</code> <p>If the User is not a member of the Card's Board</p> Note <p>If the User is already a Card member, no changes will be made</p> Source code in <code>src/plankapy/v2/models/user.py</code> <pre><code>def add_to_card(self, card: Card) -&gt; None:\n    \"\"\"Add the User to a Card\n\n    Args:\n        card (Card): The Card to add the user to (must be a member of the Card's Board)\n\n    Raises:\n        PermissionError: If the User is not a member of the Card's Board\n\n    Note:\n        If the User is already a Card member, no changes will be made\n    \"\"\"\n\n    if self not in card.board.users:\n        raise PermissionError(f'User is not a member of the Board')\n\n    if self not in card.members:\n        self.endpoints.createCardMembership(card.id, userId=self.id)\n</code></pre>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.add_to_card(card)","title":"<code>card</code>","text":""},{"location":"v2/models/user/#plankapy.v2.models.user.User.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.create_notification_service","title":"create_notification_service","text":"<pre><code>create_notification_service(**kwargs: Unpack[Request_createUserNotificationService]) -&gt; NotificationService\n</code></pre> <p>Create a NEW Notification Service</p> PARAMETER DESCRIPTION <p>The webhook URL for the NotificationService</p> <p> TYPE: <code>str</code> </p> <p>The format of the NotificationService (default: <code>text</code>)</p> <p> TYPE: <code>NotificationServiceFormat</code> </p> Source code in <code>src/plankapy/v2/models/user.py</code> <pre><code>def create_notification_service(self, **kwargs: Unpack[paths.Request_createUserNotificationService]) -&gt; NotificationService:\n    \"\"\"Create a NEW Notification Service\n\n    Args:\n        url (str): The webhook URL for the NotificationService\n        format (NotificationServiceFormat): The format of the NotificationService (default: `text`)\n    \"\"\"\n    return NotificationService(self.endpoints.createUserNotificationService(self.id, **kwargs)['item'], self.session)\n</code></pre>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.create_notification_service(url)","title":"<code>url</code>","text":""},{"location":"v2/models/user/#plankapy.v2.models.user.User.create_notification_service(format)","title":"<code>format</code>","text":""},{"location":"v2/models/user/#plankapy.v2.models.user.User.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the User</p> Source code in <code>src/plankapy/v2/models/user.py</code> <pre><code>def delete(self):\n    \"\"\"Delete the User\"\"\"\n    return self.endpoints.deleteUser(self.id)\n</code></pre>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.delete_notification_service","title":"delete_notification_service","text":"<pre><code>delete_notification_service(notification_service: NotificationService) -&gt; None\n</code></pre> <p>Deletes a NotificationService for a User</p> PARAMETER DESCRIPTION <p>The NotificaitonService to delete</p> <p> TYPE: <code>NotificaitonService</code> </p> Source code in <code>src/plankapy/v2/models/user.py</code> <pre><code>def delete_notification_service(self, notification_service: NotificationService) -&gt; None:\n    \"\"\"Deletes a NotificationService for a User\n\n    Args:\n        notificaiton_service (NotificaitonService): The NotificaitonService to delete\n    \"\"\"\n    if notification_service in self.notification_services:\n        notification_service.delete()\n</code></pre>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.delete_notification_service(notificaiton_service)","title":"<code>notificaiton_service</code>","text":""},{"location":"v2/models/user/#plankapy.v2.models.user.User.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.remove_from_board","title":"remove_from_board","text":"<pre><code>remove_from_board(board: Board) -&gt; None\n</code></pre> <p>Remove the User from a Board</p> Note <p>If the User is not a Board member, no change will be made</p> Source code in <code>src/plankapy/v2/models/user.py</code> <pre><code>def remove_from_board(self, board: Board) -&gt; None:\n    \"\"\"Remove the User from a Board\n\n    Note:\n        If the User is not a Board member, no change will be made\n    \"\"\"\n    if self in board.users:\n        board.remove_user(self)\n</code></pre>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.remove_from_card","title":"remove_from_card","text":"<pre><code>remove_from_card(card: Card) -&gt; None\n</code></pre> <p>Remove the User from a Card</p> PARAMETER DESCRIPTION <p>The Card to remove the User from</p> <p> TYPE: <code>Card</code> </p> Note <p>if the User is not a member of the Card, no change will be made</p> Source code in <code>src/plankapy/v2/models/user.py</code> <pre><code>def remove_from_card(self, card: Card) -&gt; None:\n    \"\"\"Remove the User from a Card\n\n    Args:\n        card (Card): The Card to remove the User from\n\n    Note:\n        if the User is not a member of the Card, no change will be made\n    \"\"\"\n    if self in card.members:\n        card.remove_member(self)\n</code></pre>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.remove_from_card(card)","title":"<code>card</code>","text":""},{"location":"v2/models/user/#plankapy.v2.models.user.User.sync","title":"sync","text":"<pre><code>sync()\n</code></pre> <p>Sync the User with the Planka server (Can only sync your own User)</p> Source code in <code>src/plankapy/v2/models/user.py</code> <pre><code>def sync(self):\n    \"\"\"Sync the User with the Planka server (Can only sync your own User)\"\"\"\n    if self.id == self.session.me.id:\n        self.schema = self.session.me.schema\n</code></pre>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.update","title":"update","text":"<pre><code>update(**kwargs: Unpack[Request_updateUser])\n</code></pre> <p>Update the User</p> Source code in <code>src/plankapy/v2/models/user.py</code> <pre><code>def update(self, **kwargs: Unpack[paths.Request_updateUser]):\n    \"\"\"Update the User\"\"\"\n    self.schema = self.endpoints.updateUser(self.id, **kwargs)['item']\n</code></pre>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.update_avatar","title":"update_avatar","text":"<pre><code>update_avatar(avatar: str | bytes | None) -&gt; User\n</code></pre> <p>Update the User avatar</p> <p>You can pass a filepath, URL, raw bytes, or None to the avatar argument.  Only Admins can update other User's avatars</p> PARAMETER DESCRIPTION <p>filepath/URL or file bytes or None to clear</p> <p> TYPE: <code>str | bytes | None</code> </p> RETURNS DESCRIPTION <code>User</code> <p>The updated User</p> <p> TYPE: <code>User</code> </p> Source code in <code>src/plankapy/v2/models/user.py</code> <pre><code>def update_avatar(self, avatar: str | bytes | None) -&gt; User:\n    \"\"\"Update the User avatar\n\n    You can pass a filepath, URL, raw bytes, or None to the avatar argument. \n    Only Admins can update other User's avatars\n\n    Args:\n        avatar (str | bytes | None): filepath/URL or file bytes or None to clear\n\n    Returns:\n        User: The updated User\n    \"\"\"\n    # Force a PermissionError early if this user isn't the current user or an admin\n    if self.id != self.session.current_id and self.session.current_role != 'admin':\n        self.endpoints.updateUserAvatar(self.id, **{'file': b'NO_PERMISSION'})\n\n    if avatar is None:\n        self.avatar = None\n        return self\n\n    # Deferred import of mimetypes that is only used here\n    # This function takes so long anyways so the import delay \n    # isn't noticable\n    import mimetypes\n\n    # Handle filepath or URL\n    mime_type = None\n    if isinstance(avatar, str):\n        # Guess URL file type\n        if avatar.startswith('http'):\n            mime_type, *_ = mimetypes.guess_type(avatar)\n            mime_type = mime_type or 'application/octet-stream'\n            try:\n                req = self.client.get(avatar)\n                req.raise_for_status()\n                avatar = req.content\n            except HTTPStatusError as status_error:\n                status_error.add_note(f'Unable to download attachment from {avatar}')\n                raise\n        # Guess local file type\n        # And read Bytes\n        else:\n            mime_type, *_ = mimetypes.guess_file_type(avatar)\n            mime_type = mime_type or 'application/octet-stream'\n            avatar = open(avatar, 'rb').read()\n\n    mime_type = mime_type or 'application/octet-stream'\n    self.endpoints.updateUserAvatar(\n        self.id, \n        file=bytes(avatar), \n        mime_type=mime_type,\n    )\n    return self\n</code></pre>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.update_avatar(avatar)","title":"<code>avatar</code>","text":""},{"location":"v2/models/user/#plankapy.v2.models.user.User.update_email","title":"update_email","text":"<pre><code>update_email(email: str, *, password: str | None = None) -&gt; None\n</code></pre> <p>Update the current User's email</p> PARAMETER DESCRIPTION <p>The User's password (required if not admin)</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>PermissionError</code> <p>If the current user is not admin and attempts to set another user's password</p> <code>PermissionError</code> <p>If the current user is not admin and the <code>password</code> arg is not set</p> <code>HTTPStatusError</code> <p>If the password is wrong or the update operation fails</p> Source code in <code>src/plankapy/v2/models/user.py</code> <pre><code>def update_email(self, email: str, \n                 *, \n                 password: str|None=None) -&gt; None:\n    \"\"\"Update the current User's email\n\n    Args:\n        password (str): The User's password (required if not admin)\n\n    Raises:\n        PermissionError: If the current user is not admin and attempts to set another user's password\n        PermissionError: If the current user is not admin and the `password` arg is not set\n        HTTPStatusError: If the password is wrong or the update operation fails\n    \"\"\"\n\n    # Allow Admins to set user email directly or ignore password kwarg\n    if self.current_role == 'admin':\n        self.endpoints.updateUserEmail(self.id, email=email)\n        return\n\n    if self.current_id != self.id:\n        raise PermissionError(f'Cannot set other User emails unless admin')\n\n    if not password:\n        raise PermissionError(f'User password required to update email!')\n\n    self.endpoints.updateUserEmail(self.id, email=email, currentPassword=password)\n</code></pre>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.update_email(password)","title":"<code>password</code>","text":""},{"location":"v2/models/user/#plankapy.v2.models.user.User.update_password","title":"update_password","text":"<pre><code>update_password(*, new_password: str, current_password: str | None = None) -&gt; None\n</code></pre> <p>Update the User's password</p> PARAMETER DESCRIPTION <p>The new password to use</p> <p> TYPE: <code>str</code> </p> <p>The User's current password (required for non-admin)</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>PermissionError</code> <p>If a non-admin attempts to update another user's password</p> <code>PermissionError</code> <p>If a user attempts to update their own password without passing a <code>current_password</code></p> <code>HTTPStatusError</code> <p>If the password is wrong or the update operation fails</p> Source code in <code>src/plankapy/v2/models/user.py</code> <pre><code>def update_password(self, \n                    *, \n                    new_password: str, \n                    current_password: str|None=None) -&gt; None:\n    \"\"\"Update the User's password\n\n    Args:\n        new_password (str): The new password to use\n        current_password (str): The User's current password (required for non-admin)\n\n    Raises:\n        PermissionError: If a non-admin attempts to update another user's password\n        PermissionError: If a user attempts to update their own password without passing a `current_password`\n        HTTPStatusError: If the password is wrong or the update operation fails\n    \"\"\"\n    # Admins can set any User password\n    if self.current_role == 'admin':\n        self.endpoints.updateUserPassword(self.id, password=new_password)\n        return\n\n    # Users's cannot set other user's passwords\n    if self.current_id != self.id:\n        raise PermissionError(f\"Cannot set another User's password! (must be admin)\")\n\n    # Password change required current password\n    if not current_password:\n        raise PermissionError(f'Cannot set other User passwords unless admin')\n\n    self.endpoints.updateUserPassword(self.id, password=new_password, currentPassword=current_password)\n</code></pre>"},{"location":"v2/models/user/#plankapy.v2.models.user.User.update_password(new_password)","title":"<code>new_password</code>","text":""},{"location":"v2/models/user/#plankapy.v2.models.user.User.update_password(current_password)","title":"<code>current_password</code>","text":""},{"location":"v2/models/webhook/","title":"Webhook","text":"CLASS DESCRIPTION <code>Webhook</code> <p>Python interface for Planka Webhooks</p>"},{"location":"v2/models/webhook/#plankapy.v2.models.webhook.Webhook","title":"Webhook","text":"<pre><code>Webhook(schema: Schema, session: Planka)\n</code></pre> <p>               Bases: <code>PlankaModel[Webhook]</code></p> <p>Python interface for Planka Webhooks</p> Returned by: <ul> <li> Plankapy v2 interface Planka Interface <code></code>\u00a0interface <code></code>\u00a0Planka <ul> <li> <code></code>\u00a0webhooks </li> <li> <code></code>\u00a0create_webhook </li> </ul> </li> </ul> METHOD DESCRIPTION <code>copy</code> <p>Create a deepcopy of the model and its associated schema.</p> <code>delete</code> <p>Delete the Webhook (admin only)</p> <code>diff</code> <p>Get a schema diff between two model schemas.</p> <code>sync</code> <p>Sync the Webhook with the Planka server (admin only)</p> <code>update</code> <p>Update the Webhook (admin only)</p> ATTRIBUTE DESCRIPTION <code>__formatter__</code> <p>Formatter func that allows overriding str behavior for models</p> <p> TYPE: <code>ModelFormatter[Self]</code> </p> <code>access_token</code> <p>Access token for webhook authentication</p> <p> TYPE: <code>str</code> </p> <code>created_at</code> <p>When the Webhook was created</p> <p> TYPE: <code>datetime</code> </p> <code>events</code> <p>List of events that trigger the Webhook</p> <p> TYPE: <code>list[WebhookEvent]</code> </p> <code>excluded_events</code> <p>List of events excluded from the Webhook</p> <p> TYPE: <code>list[WebhookEvent]</code> </p> <code>name</code> <p>Name/title of the Webhook</p> <p> TYPE: <code>str</code> </p> <code>updated_at</code> <p>When the Webhook was last updated</p> <p> TYPE: <code>datetime</code> </p> <code>url</code> <p>URL endpoint for the Webhook</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def __init__(self, schema: Schema, session: Planka) -&gt; None:\n    self._schema = schema\n    self.session = session\n    self.endpoints = session.endpoints\n    self.client = session.client\n    self.current_role = session.current_role\n    self.current_id = session.current_id\n</code></pre>"},{"location":"v2/models/webhook/#plankapy.v2.models.webhook.Webhook.__formatter__","title":"__formatter__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__formatter__: ModelFormatter[Self] = DEFAULT_FORMATTER\n</code></pre> <p>Formatter func that allows overriding str behavior for models</p>"},{"location":"v2/models/webhook/#plankapy.v2.models.webhook.Webhook.access_token","title":"access_token  <code>property</code>","text":"<pre><code>access_token: str\n</code></pre> <p>Access token for webhook authentication</p>"},{"location":"v2/models/webhook/#plankapy.v2.models.webhook.Webhook.created_at","title":"created_at  <code>property</code>","text":"<pre><code>created_at: datetime\n</code></pre> <p>When the Webhook was created</p>"},{"location":"v2/models/webhook/#plankapy.v2.models.webhook.Webhook.events","title":"events  <code>property</code>","text":"<pre><code>events: list[WebhookEvent]\n</code></pre> <p>List of events that trigger the Webhook</p>"},{"location":"v2/models/webhook/#plankapy.v2.models.webhook.Webhook.excluded_events","title":"excluded_events  <code>property</code>","text":"<pre><code>excluded_events: list[WebhookEvent]\n</code></pre> <p>List of events excluded from the Webhook</p>"},{"location":"v2/models/webhook/#plankapy.v2.models.webhook.Webhook.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Name/title of the Webhook</p>"},{"location":"v2/models/webhook/#plankapy.v2.models.webhook.Webhook.updated_at","title":"updated_at  <code>property</code>","text":"<pre><code>updated_at: datetime\n</code></pre> <p>When the Webhook was last updated</p>"},{"location":"v2/models/webhook/#plankapy.v2.models.webhook.Webhook.url","title":"url  <code>property</code>","text":"<pre><code>url: str\n</code></pre> <p>URL endpoint for the Webhook</p>"},{"location":"v2/models/webhook/#plankapy.v2.models.webhook.Webhook.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a deepcopy of the model and its associated schema.</p> Note <p>Since the endpoints for both instances of the Model are the same, any  calls to update will restore the state and bring both copies into sync.  copies like this are meant more for comparing changes when running a sync  or update/assignemnt operation.</p> <p>Example: <pre><code>    &gt;&gt;&gt; card_copy = card.copy()\n    &gt;&gt;&gt; card.name = 'Updated Name'\n    &gt;&gt;&gt; card_copy.name\n    'Original Name'\n    &gt;&gt;&gt; card.name\n    'Updated Name'\n    &gt;&gt;&gt; # This update may have had side effects\n    &gt;&gt;&gt; print(card_copy.diff(card))\n    {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n</code></pre></p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"Create a deepcopy of the model and its associated schema.\n\n    Note:\n        Since the endpoints for both instances of the Model are the same, any \n        calls to update will restore the state and bring both copies into sync. \n        copies like this are meant more for comparing changes when running a sync \n        or update/assignemnt operation.\n\n    Example:\n    ```python\n        &gt;&gt;&gt; card_copy = card.copy()\n        &gt;&gt;&gt; card.name = 'Updated Name'\n        &gt;&gt;&gt; card_copy.name\n        'Original Name'\n        &gt;&gt;&gt; card.name\n        'Updated Name'\n        &gt;&gt;&gt; # This update may have had side effects\n        &gt;&gt;&gt; print(card_copy.diff(card))\n        {'name': ('Original Name', 'Updated Name'), 'updatedAt': ('...2:00pm', '...2:45pm'), ...}\n    ```\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"v2/models/webhook/#plankapy.v2.models.webhook.Webhook.delete","title":"delete","text":"<pre><code>delete()\n</code></pre> <p>Delete the Webhook (admin only)</p> Source code in <code>src/plankapy/v2/models/webhook.py</code> <pre><code>def delete(self):\n    \"\"\"Delete the Webhook (admin only)\"\"\"\n    if self.current_role == 'admin':\n        self.endpoints.deleteWebhook(self.id)\n</code></pre>"},{"location":"v2/models/webhook/#plankapy.v2.models.webhook.Webhook.diff","title":"diff","text":"<pre><code>diff(other: PlankaModel[Schema]) -&gt; Diff\n</code></pre> <p>Get a schema diff between two model schemas.</p> Note <p>Only matching keys are diffed. Any schema keys that are not in the source schema  will not be checked in the target schema</p> Source code in <code>src/plankapy/v2/models/_base.py</code> <pre><code>def diff(self, other: PlankaModel[Schema]) -&gt; Diff:\n    \"\"\"Get a schema diff between two model schemas.\n\n    Note:\n        Only matching keys are diffed. Any schema keys that are not in the source schema \n        will not be checked in the target schema\n    \"\"\"\n    return {\n        k: (source, delta) \n        for k, source in self.schema\n        if k in other.schema\n        and (delta := other.schema[k]) \n        and delta != source\n    }\n</code></pre>"},{"location":"v2/models/webhook/#plankapy.v2.models.webhook.Webhook.sync","title":"sync","text":"<pre><code>sync()\n</code></pre> <p>Sync the Webhook with the Planka server (admin only)</p> Source code in <code>src/plankapy/v2/models/webhook.py</code> <pre><code>def sync(self):\n    \"\"\"Sync the Webhook with the Planka server (admin only)\"\"\"\n    if self.current_role == 'admin':\n        self.schema = [\n            Webhook(w, self.session) \n            for w in self.endpoints.getWebhooks()['items'] \n            if w['id'] == self.id\n        ].pop().schema\n</code></pre>"},{"location":"v2/models/webhook/#plankapy.v2.models.webhook.Webhook.update","title":"update","text":"<pre><code>update(**kwargs: Unpack[Request_updateWebhook])\n</code></pre> <p>Update the Webhook (admin only)</p> Source code in <code>src/plankapy/v2/models/webhook.py</code> <pre><code>def update(self, **kwargs: Unpack[paths.Request_updateWebhook]):\n    \"\"\"Update the Webhook (admin only)\"\"\"\n    if self.current_role == 'admin':\n        self.schema = self.endpoints.updateWebhook(self.id, **kwargs)['item']\n</code></pre>"}]}