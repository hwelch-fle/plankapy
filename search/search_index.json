{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"plankapy","text":"<p>A Python API for Planka</p> <p></p> <p> </p> <p> </p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install plankapy\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>The full documentation can be found here.</p> <p>All Interfaces are documented in the API section.</p>"},{"location":"#features","title":"Features","text":""},{"location":"#no-keys-required","title":"No Keys Required","text":"<p>Planka models have all been implemented as Python objects. This means that you can access all the properties of a resource as if it were a Python object: <pre><code>&gt;&gt;&gt; project.name\n'Project 1'\n\n&gt;&gt;&gt; project.managers\n[User(id=1, username='username', ...), User(id=2, username='username2', ...), ...]\n</code></pre></p>"},{"location":"#disambiguation-of-resource-attributes-and-methods","title":"Disambiguation of resource attributes and methods","text":"<p>All models have type hints for every property and attribute, meaning you don't have to guess what a method or property will return. When using a modern IDE, this allows for extensive code completion and prevents you from having to remember what every property and method returns.</p>"},{"location":"#synced-by-default","title":"Synced by Default","text":"<p>All included resources are accessible through object properties that send out a request to the server when accessed. This means that you can access up to date information about a resource without having to manually refresh it. <pre><code>&gt;&gt;&gt; list1 = board.lists[0]\n&gt;&gt;&gt; list2 = board.lists[1]\n\n&gt;&gt;&gt; list1.cards\n[Card(id=1, name='Card 1', ...), Card(id=2, name='Card 2', ...)]\n\n&gt;&gt;&gt; list2.cards\n[]\n\n&gt;&gt;&gt; list1.cards[0].move(list2)\n\n&gt;&gt;&gt; list1.cards\n[Card(id=2, name='Card 2', ...)]\n\n&gt;&gt;&gt; list2.cards\n[Card(id=1, name='Card 1', ...)]\n</code></pre></p>"},{"location":"#edit-with-context","title":"Edit with Context","text":"<p>Because all stored objects maintain the attributes assigned to them on their creation, direct attribute editing is not synced with the server resource. To mitigate this a <code>.editor()</code> context manager is provided that refreshes the resource on entry and updates the resource on exit.</p>"},{"location":"#direct-editing-of-attributes-fails-to-update-the-resource","title":"Direct editing of attributes fails to update the resource","text":"<pre><code>&gt;&gt;&gt; c1 = list1.cards[0]\n&gt;&gt;&gt; c1.name = \"New Name\"\n&gt;&gt;&gt; c1.name\n'New Name'\n\n# Get the resource again to see that the name has not changed\n&gt;&gt;&gt; c2 = list1.cards[0]\n&gt;&gt;&gt; c2.name\n'Card 1'\n</code></pre>"},{"location":"#context-editing-updates-the-resource-after-exiting-the-context","title":"Context editing updates the resource after exiting the context","text":"<pre><code>&gt;&gt;&gt; c1 = list1.cards[0]\n&gt;&gt;&gt; with c1.editor():\n...     c1.name = \"New Name\"\n\n&gt;&gt;&gt; c1.name\n'New Name'\n\n# Get the resource again to see that the name has changed\n&gt;&gt;&gt; c2 = list1.cards[0]\n\n&gt;&gt;&gt; c2.name\n'New Name'\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Getting started with plankapy is as simple as creating a <code>Planka</code> object and passing it your authentication method. From there, you can access all the resources available to your logged in user account.</p> <pre><code>&gt;&gt;&gt; from plankapy import Planka, PasswordAuth\n\n&gt;&gt;&gt; planka = Planka(\"https://planka.example.com\", PasswordAuth(\"username\", \"password\"))\n\n&gt;&gt;&gt; planka.me\nUser(id=1, username='username', ...)\n\n&gt;&gt;&gt; planka.projects\n[Project(id=1, name='Project 1', ...), Project(id=2, name='Project 2', ...), ...]\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the AGPLv3 License - see the LICENSE file for details.</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"auth/BaseAuth/","title":"Base Auth","text":"<p>               Bases: <code>Protocol</code></p> Source code in <code>src/plankapy/handlers.py</code> <pre><code>class BaseAuth(Protocol):\n    endpoint = None\n    def __repr__(self) -&gt; str:\n        return f\"&lt; {self.__class__.__name__}: {self.endpoint} &gt;\"\n\n    def authenticate(self) -&gt; str: ...\n</code></pre>"},{"location":"auth/PasswordAuth/","title":"PasswordAuth","text":"<p>               Bases: <code>BaseAuth</code></p> <p>Authentication using a username or email and password</p> <p>Attributes:</p> Name Type Description <code>endpoint</code> <code>str</code> <p>The token to use for authentication (default: 'api/access-tokens')</p> Source code in <code>src/plankapy/handlers.py</code> <pre><code>class PasswordAuth(BaseAuth):\n    \"\"\"Authentication using a username or email and password\n\n    Attributes:\n        endpoint (str): The token to use for authentication (default: 'api/access-tokens')\n    \"\"\"\n\n    endpoint = 'api/access-tokens'\n\n    def __init__(self, username_or_email: str, password: str) -&gt; None:\n        \"\"\"Initialize a PasswordAuth instance with a username or email and password\n\n        Args:\n            username_or_email (str): The username or email to use for authentication\n            password (str): The password to use for authentication\n\n        Example:\n            ```python\n            &gt;&gt;&gt; auth = PasswordAuth('username', 'password')\n            &gt;&gt;&gt; auth.authenticate('http://planka.instance')\n            {'Authorization' : 'Bearer &lt;token&gt;'}\n            ```    \n        \"\"\"\n        self.token = None\n        self.credentials = {\n            'emailOrUsername': username_or_email,\n            'password': password\n        }\n\n    def authenticate(self, url: str) -&gt; dict[str, str]:\n        \"\"\"Implementation of the authenticate method\n\n        Args:\n            url (str): The base url of the Planka instance\n\n        Returns:\n            Headers with the token in the `Authorization` key\n        \"\"\"\n        self.token = JSONHandler(url, endpoint=self.endpoint).post(self.credentials)['item']\n        return {\"Authorization\": f\"Bearer {self.token}\"}\n</code></pre>"},{"location":"auth/PasswordAuth/#plankapy.handlers.PasswordAuth.__init__","title":"<code>__init__(username_or_email, password)</code>","text":"<p>Initialize a PasswordAuth instance with a username or email and password</p> <p>Parameters:</p> Name Type Description Default <code>username_or_email</code> <code>str</code> <p>The username or email to use for authentication</p> required <code>password</code> <code>str</code> <p>The password to use for authentication</p> required Example <pre><code>&gt;&gt;&gt; auth = PasswordAuth('username', 'password')\n&gt;&gt;&gt; auth.authenticate('http://planka.instance')\n{'Authorization' : 'Bearer &lt;token&gt;'}\n</code></pre> Source code in <code>src/plankapy/handlers.py</code> <pre><code>def __init__(self, username_or_email: str, password: str) -&gt; None:\n    \"\"\"Initialize a PasswordAuth instance with a username or email and password\n\n    Args:\n        username_or_email (str): The username or email to use for authentication\n        password (str): The password to use for authentication\n\n    Example:\n        ```python\n        &gt;&gt;&gt; auth = PasswordAuth('username', 'password')\n        &gt;&gt;&gt; auth.authenticate('http://planka.instance')\n        {'Authorization' : 'Bearer &lt;token&gt;'}\n        ```    \n    \"\"\"\n    self.token = None\n    self.credentials = {\n        'emailOrUsername': username_or_email,\n        'password': password\n    }\n</code></pre>"},{"location":"auth/PasswordAuth/#plankapy.handlers.PasswordAuth.authenticate","title":"<code>authenticate(url)</code>","text":"<p>Implementation of the authenticate method</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The base url of the Planka instance</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Headers with the token in the <code>Authorization</code> key</p> Source code in <code>src/plankapy/handlers.py</code> <pre><code>def authenticate(self, url: str) -&gt; dict[str, str]:\n    \"\"\"Implementation of the authenticate method\n\n    Args:\n        url (str): The base url of the Planka instance\n\n    Returns:\n        Headers with the token in the `Authorization` key\n    \"\"\"\n    self.token = JSONHandler(url, endpoint=self.endpoint).post(self.credentials)['item']\n    return {\"Authorization\": f\"Bearer {self.token}\"}\n</code></pre>"},{"location":"auth/TokenAuth/","title":"TokenAuth","text":"<p>               Bases: <code>BaseAuth</code></p> <p>Authentication using a pre-supplied token</p> <p>Attributes:</p> Name Type Description <code>endpoint</code> <code>str</code> <p>The token to use for authentication (default: 'api/access-tokens')</p> Example <pre><code>&gt;&gt;&gt; auth = TokenAuth('&lt;token&gt;')\n&gt;&gt;&gt; auth.authenticate()\n{'Authorization : 'Bearer &lt;token&gt;'}\n</code></pre> Source code in <code>src/plankapy/handlers.py</code> <pre><code>class TokenAuth(BaseAuth):\n    \"\"\"Authentication using a pre-supplied token\n\n    Attributes:\n        endpoint (str): The token to use for authentication (default: 'api/access-tokens')\n\n    Example:\n        ```python\n        &gt;&gt;&gt; auth = TokenAuth('&lt;token&gt;')\n        &gt;&gt;&gt; auth.authenticate()\n        {'Authorization : 'Bearer &lt;token&gt;'}\n        ```\n    \"\"\"\n    endpoint = 'api/access-tokens'\n\n    def __init__(self, token: str) -&gt; None:\n        \"\"\"Initialize a TokenAuth instance with a token\n\n        Args:\n            token (str): The token to use for authentication\n        \"\"\"\n        self.token = token\n\n    def authenticate(self, url: str=None) -&gt; dict[str, str]:\n        \"\"\"Implementation of the authenticate method\n\n        Args:\n            url (str): Not used, but required by the protocol\n\n        Returns:\n           Headers with the token in the `Authorization` key\n        \"\"\"\n        return {\"Authorization\": f\"Bearer {self.token}\"}\n</code></pre>"},{"location":"auth/TokenAuth/#plankapy.handlers.TokenAuth.__init__","title":"<code>__init__(token)</code>","text":"<p>Initialize a TokenAuth instance with a token</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The token to use for authentication</p> required Source code in <code>src/plankapy/handlers.py</code> <pre><code>def __init__(self, token: str) -&gt; None:\n    \"\"\"Initialize a TokenAuth instance with a token\n\n    Args:\n        token (str): The token to use for authentication\n    \"\"\"\n    self.token = token\n</code></pre>"},{"location":"auth/TokenAuth/#plankapy.handlers.TokenAuth.authenticate","title":"<code>authenticate(url=None)</code>","text":"<p>Implementation of the authenticate method</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Not used, but required by the protocol</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Headers with the token in the <code>Authorization</code> key</p> Source code in <code>src/plankapy/handlers.py</code> <pre><code>def authenticate(self, url: str=None) -&gt; dict[str, str]:\n    \"\"\"Implementation of the authenticate method\n\n    Args:\n        url (str): Not used, but required by the protocol\n\n    Returns:\n       Headers with the token in the `Authorization` key\n    \"\"\"\n    return {\"Authorization\": f\"Bearer {self.token}\"}\n</code></pre>"},{"location":"cli/cli/","title":"COMING SOON ?","text":""},{"location":"constants/constants/","title":"Constants","text":""},{"location":"constants/constants/#actiontype","title":"ActionType","text":"<p><code>createCard</code> <code>moveCard</code> <code>commentCard</code></p>"},{"location":"constants/constants/#boardrole","title":"BoardRole","text":"<p><code>editor</code> <code>viewer</code></p>"},{"location":"constants/constants/#sort-options","title":"Sort Options","text":"<p><code>Name</code> <code>Due date</code> <code>Oldest First</code> <code>Newest First</code></p>"},{"location":"constants/constants/#label-colors","title":"Label Colors","text":"Name Hex  berry-red  #c0392b  pumpkin-orange  #f0982d  lagoon-blue  #109dc0  pink-tulip  #f97394  light-mud  #c7a57b  orange-peel  #fab623  bright-moss  #a5c261  antique-blue  #6c99bb  dark-granite  #8b8680  lagune-blue  #00b4b1  sunny-grass  #bfca02  morning-sky  #52bad5  light-orange  #ffc66d  midnight-blue  #004d73  tank-green  #8aa177  gun-metal  #355263  wet-moss  #4a8753  red-burgundy  #ad5f7d  light-concrete  #afb0a4  apricot-red  #fc736d  desert-sand  #edcb76  navy-blue  #166a8f  egg-yellow  #f7d036  coral-green  #2b6a6c  light-cocoa  #87564a"},{"location":"constants/constants/#project-gradients","title":"Project Gradients","text":"<p>Note: Some of these gradients are not supported currently, but I've included them here because they are defined in the planka codebase.</p> Name CSS  ocean-dive  <code>linear-gradient(to top, #062e53, #1ad0e0)</code>  old-lime  <code>linear-gradient(to bottom, #7b920a, #add100)</code>  tzepesch-style  <code>linear-gradient(to bottom, #190a05, #870000)</code>  jungle-mesh  <code>linear-gradient(to bottom, #727a17, #414d0b)</code>  blue-danube  <code>radial-gradient(circle, rgba(9, 9, 121, 1) 0%, rgba(2, 0, 36, 1) 0%, rgba(2, 29, 66, 1) 0%, rgba(2, 41, 78, 1) 0%, rgba(2, 57, 95, 1) 0%, rgba(1, 105, 144, 1) 100%, rgba(1, 151, 192, 1) 100%, rgba(0, 212, 255, 1) 100%)</code>  sundown-stripe  <code>linear-gradient(22deg, rgba(31, 30, 30, 1) 0%, rgba(255, 128, 0, 1) 10%, rgba(255, 128, 0, 1) 41%, rgba(0, 0, 0, 1) 41%, rgba(0, 102, 204, 1) 89%)</code>  magical-dawn  <code>radial-gradient(circle, rgba(0, 107, 141, 1) 0%, rgba(0, 69, 91, 1) 90%)</code>  strawberry-dust  <code>linear-gradient(180deg, rgba(172, 79, 115, 1) 0%, rgba(254, 158, 150, 1) 66%)</code>  purple-rose  <code>linear-gradient(128deg, rgba(116, 43, 62, 1) 19%, rgba(192, 71, 103, 1) 90%)</code>  sun-scream  <code>linear-gradient(112deg, rgba(251, 221, 19, 1) 19%, rgba(255, 153, 1, 1) 62%)</code>  warm-rust  <code>linear-gradient(141deg, rgba(255, 90, 8, 1) 0%, rgba(88, 0, 0, 1) 96%)</code>  sky-change  <code>linear-gradient(135deg, rgba(0, 52, 89, 1) 0%, rgba(0, 168, 232, 1) 90%)</code>  green-eyes  <code>linear-gradient(138deg, rgba(19, 170, 82, 1) 0%, rgba(0, 102, 43, 1) 90%)</code>  blue-xchange  <code>radial-gradient(circle, #294f83, #162c4a)</code>  blood-orange  <code>linear-gradient(360deg, #d64759 10%, #da7352 360%)</code>  sour-peel  <code>linear-gradient(360deg, #fd6f46 10%, #fb9832 360%)</code>  green-ninja  <code>linear-gradient(360deg, #224e4d 10%, #083023 360%)</code>  ice-blue  <code>linear-gradient(360deg, #38aecc 10%, #347fb9 360%)</code>  epic-green  <code>linear-gradient(360deg, #01a99c 10%, #0698b1 360%)</code>  algae-green  <code>radial-gradient(circle farthest-corner at 10% 20%, rgba(0, 95, 104, 1) 0%, rgba(15, 156, 168, 1) 90%)</code>  coral-reef  <code>linear-gradient(110.3deg, rgba(238, 179, 123, 1) 8.7%, rgba(216, 103, 77, 1) 47.5%, rgba(238, 179, 123, 1) 100%)</code>  wow-blue  <code>linear-gradient(111.8deg, rgba(0, 104, 155, 1) 19.8%, rgba(0, 173, 239, 1) 92.1%)</code>  velvet-lounge  <code>radial-gradient(circle farthest-corner at 10% 20%, rgba(151, 10, 130, 1) 0%, rgba(33, 33, 33, 1) 100.2%)</code>  lagoon  <code>radial-gradient(circle farthest-corner at 10% 20%, rgba(0, 107, 141, 1) 0%, rgba(0, 69, 91, 1) 90%)</code>  purple-rain  <code>linear-gradient(91.7deg, rgba(50, 25, 79, 1) -4.3%, rgba(122, 101, 149, 1) 101.8%)</code>  blue-steel  <code>linear-gradient(to top, #09203f 0%, #537895 100%)</code>  blueish-curve  <code>linear-gradient(171.8deg, rgba(5, 111, 146, 1) 13.5%, rgba(6, 57, 84, 1) 78.6%)</code>  prism-light  <code>linear-gradient(111.7deg, rgba(251, 198, 6, 1) 2.4%, rgba(224, 82, 95, 1) 28.3%, rgba(194, 78, 154, 1) 46.2%, rgba(32, 173, 190, 1) 79.4%, rgba(22, 158, 95, 1) 100.2%)</code>  the-bow  <code>radial-gradient(circle farthest-corner at -8.9% 51.2%, rgba(255, 124, 0, 1) 0%, rgba(255, 124, 0, 1) 15.9%, rgba(255, 163, 77, 1) 15.9%, rgba(255, 163, 77, 1) 24.4%, rgba(19, 30, 37, 1) 24.5%, rgba(19, 30, 37, 1) 66%)</code>  green-mist  <code>linear-gradient(180.5deg, rgba(0, 128, 128, 1) 8.5%, rgba(174, 206, 100, 1) 118.2%)</code>  red-curtain  <code>radial-gradient(circle 371px at 2.9% 14.3%, rgba(255, 0, 102, 1) 0%, rgba(80, 5, 35, 1) 100.7%)</code>  steel-grey  <code>radial-gradient(circle farthest-corner at -4% -12.9%, rgba(74, 98, 110, 1) 0.3%, rgba(30, 33, 48, 1) 90.2%)</code>"},{"location":"helpers/helpers/","title":"Helpers","text":""},{"location":"helpers/helpers/#plankapy.helpers.add_editors_to_board","title":"<code>add_editors_to_board(board, users)</code>","text":"<p>Add users to a board with editing permissions</p> <p>Parameters:</p> Name Type Description Default <code>board</code> <code>Board</code> <p>Board to add users to</p> required <code>users</code> <code>list[User]</code> <p>Users to add</p> required <p>Returns:</p> Name Type Description <code>Board</code> <code>list[BoardMembership]</code> <p>Board with users added</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def add_editors_to_board(board: Board, users: list[User]) -&gt; list[BoardMembership]:\n    \"\"\"Add users to a board with editing permissions\n\n    Args:\n        board (Board): Board to add users to\n        users (list[User]): Users to add\n\n    Returns:\n        Board: Board with users added\n    \"\"\"\n    return [board.add_user(users, canComment=True) for user in users]\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.add_labels_to_card","title":"<code>add_labels_to_card(card, labels)</code>","text":"<p>Add labels to a card</p> <p>Parameters:</p> Name Type Description Default <code>card</code> <code>Card</code> <p>Card to add labels to</p> required <code>labels</code> <code>list[Label]</code> <p>Labels to add</p> required <p>Returns:</p> Type Description <code>list[CardLabel]</code> <p>list[CardLabel]: CardLabel relationships created</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def add_labels_to_card(card: Card, labels: list[Label]) -&gt; list[CardLabel]:\n    \"\"\"Add labels to a card\n\n    Args:\n        card (Card): Card to add labels to\n        labels (list[Label]): Labels to add\n\n    Returns:\n        list[CardLabel]: CardLabel relationships created\n    \"\"\"\n    return [card.add_label(label) for label in labels]\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.add_members_to_card","title":"<code>add_members_to_card(card, members)</code>","text":"<p>Add members to a card</p> <p>Parameters:</p> Name Type Description Default <code>card</code> <code>Card</code> <p>Card to add members to</p> required <code>members</code> <code>list[User]</code> <p>Members to add</p> required <p>Returns:</p> Type Description <code>list[CardMembership]</code> <p>list[CardMembership]: CardMemberships created</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def add_members_to_card(card: Card, members: list[User]) -&gt; list[CardMembership]:\n    \"\"\"Add members to a card\n\n    Args:\n        card (Card): Card to add members to\n        members (list[User]): Members to add\n\n    Returns:\n        list[CardMembership]: CardMemberships created\n    \"\"\"\n    return [card.add_member(member) for member in members]\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.add_viewers_to_board","title":"<code>add_viewers_to_board(board, users)</code>","text":"<p>Add users to a board with viewing permissions</p> <p>Parameters:</p> Name Type Description Default <code>board</code> <code>Board</code> <p>Board to add users to</p> required <code>users</code> <code>list[User]</code> <p>Users to add</p> required <p>Returns:</p> Type Description <code>list[BoardMembership]</code> <p>list[BoardMembership]: BoardMemberships created</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def add_viewers_to_board(board: Board, users: list[User]) -&gt; list[BoardMembership]:\n    \"\"\"Add users to a board with viewing permissions\n\n    Args:\n        board (Board): Board to add users to\n        users (list[User]): Users to add\n\n    Returns:\n        list[BoardMembership]: BoardMemberships created\n    \"\"\"\n    return [board.add_user(user, canComment=False) for user in users]\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.by_action_type","title":"<code>by_action_type(action_list, type)</code>","text":"<p>Get actions by type</p> <p>Parameters:</p> Name Type Description Default <code>action_list</code> <code>list[Action]</code> <p>List of actions to search</p> required <code>type</code> <code>ActionType</code> <p>Type of the action</p> required <p>Returns:</p> Type Description <code>list[Action]</code> <p>list[Action]: Actions with the given type</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def by_action_type(action_list: list[Action], type: ActionType) -&gt; list[Action]:\n    \"\"\"Get actions by type\n\n    Args:\n        action_list (list[Action]): List of actions to search\n        type (ActionType): Type of the action\n\n    Returns:\n        list[Action]: Actions with the given type\n    \"\"\"\n    return [action for action in action_list if action.type == type]\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.by_board_name","title":"<code>by_board_name(board_list, name)</code>","text":"<p>Get boards by name</p> <p>Parameters:</p> Name Type Description Default <code>board_list</code> <code>list[Board]</code> <p>List of boards to search</p> required <code>name</code> <code>str</code> <p>Name of the board</p> required <p>Returns:</p> Type Description <code>list[Board]</code> <p>list[Board]: Boards with the given name</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def by_board_name(board_list: list[Board], name: str) -&gt; list[Board]:\n    \"\"\"Get boards by name\n\n    Args:\n        board_list (list[Board]): List of boards to search\n        name (str): Name of the board\n\n    Returns:\n        list[Board]: Boards with the given name\n    \"\"\"\n    return [board for board in board_list if board.name == name]\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.by_card_name","title":"<code>by_card_name(card_list, name)</code>","text":"<p>Get cards by name</p> <p>Parameters:</p> Name Type Description Default <code>card_list</code> <code>list[Card]</code> <p>List of cards to search</p> required <code>name</code> <code>str</code> <p>Name of the card</p> required <p>Returns:</p> Type Description <code>list[Card]</code> <p>list[Card]: Cards with the given</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def by_card_name(card_list: list[Card], name: str) -&gt; list[Card]:\n    \"\"\"Get cards by name\n\n    Args:\n        card_list (list[Card]): List of cards to search\n        name (str): Name of the card\n\n    Returns:\n        list[Card]: Cards with the given \n    \"\"\"\n    return [card for card in card_list if card.name == name]\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.by_label_name","title":"<code>by_label_name(label_list, name)</code>","text":"<p>Get labels by name</p> <p>Parameters:</p> Name Type Description Default <code>label_list</code> <code>list[Label]</code> <p>List of labels to search</p> required <code>name</code> <code>str</code> <p>Name of the label</p> required <p>Returns:</p> Type Description <code>list[Label]</code> <p>list[Label]: Labels with the given name</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def by_label_name(label_list: list[Label], name: str) -&gt; list[Label]:\n    \"\"\"Get labels by name\n\n    Args:\n        label_list (list[Label]): List of labels to search\n        name (str): Name of the label\n\n    Returns:\n        list[Label]: Labels with the given name\n    \"\"\"\n    return [label for label in label_list if label.name == name]\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.by_list_name","title":"<code>by_list_name(list_list, name)</code>","text":"<p>Get lists by name</p> <p>Parameters:</p> Name Type Description Default <code>list_list</code> <code>list[List]</code> <p>List of lists to search</p> required <code>name</code> <code>str</code> <p>Name of the list</p> required <p>Returns:</p> Type Description <code>list[List]</code> <p>list[List]: Lists with the given name</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def by_list_name(list_list: list[List], name: str) -&gt; list[List]:\n    \"\"\"Get lists by name\n\n    Args:\n        list_list (list[List]): List of lists to search\n        name (str): Name of the list\n\n    Returns:\n        list[List]: Lists with the given name\n    \"\"\"\n    return [list_ for list_ in list_list if list_.name == name]\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.by_project_name","title":"<code>by_project_name(project_list, name)</code>","text":"<p>Get projects by name</p> <p>Parameters:</p> Name Type Description Default <code>project_list</code> <code>list[Project]</code> <p>List of projects to search</p> required <code>name</code> <code>str</code> <p>Name of the project</p> required <p>Returns:</p> Type Description <code>list[Project]</code> <p>list[Project]: Projects with the given name</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def by_project_name(project_list: list[Project], name: str) -&gt; list[Project]:\n    \"\"\"Get projects by name\n\n    Args:\n        project_list (list[Project]): List of projects to search\n        name (str): Name of the project\n\n    Returns:\n        list[Project]: Projects with the given name\n    \"\"\"\n    return [project for project in project_list if project.name == name]\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.by_username","title":"<code>by_username(user_list, name)</code>","text":"<p>Get users by username</p> <p>Parameters:</p> Name Type Description Default <code>user_list</code> <code>list[User]</code> <p>List of users to search</p> required <code>name</code> <code>str</code> <p>Username of the user</p> required <p>Returns:</p> Type Description <code>list[User]</code> <p>list[User]: Users with the given username</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def by_username(user_list: list[User], name: str) -&gt; list[User]:\n    \"\"\"Get users by username\n\n    Args:\n        user_list (list[User]): List of users to search\n        name (str): Username of the user\n\n    Returns:\n        list[User]: Users with the given username\n    \"\"\"\n    return [user for user in user_list if user.username == name]\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.create_board_labels","title":"<code>create_board_labels(board, labels)</code>","text":"<p>Create labels on a board</p> <p>Parameters:</p> Name Type Description Default <code>board</code> <code>Board</code> <p>Board to create labels on</p> required <code>labels</code> <code>list[Label]</code> <p>Labels to create</p> required <p>Returns:</p> Type Description <code>list[Label]</code> <p>list[Label]: The labels that were created</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def create_board_labels(board: Board, labels: list[Label]) -&gt; list[Label]:\n    \"\"\"Create labels on a board\n\n    Args:\n        board (Board): Board to create labels on\n        labels (list[Label]): Labels to create\n\n    Returns:\n        list[Label]: The labels that were created\n    \"\"\"\n    return [board.create_label(label) for label in labels]\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.delete_actions","title":"<code>delete_actions(actions)</code>","text":"<p>Delete a list of actions</p> <p>Parameters:</p> Name Type Description Default <code>actions</code> <code>list[Action]</code> <p>Actions to delete</p> required <p>Returns:</p> Type Description <code>list[Action]</code> <p>list[Action]: Actions that were deleted</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def delete_actions(actions: list[Action]) -&gt; list[Action]:\n    \"\"\"Delete a list of actions\n\n    Args:\n        actions (list[Action]): Actions to delete\n\n    Returns:\n        list[Action]: Actions that were deleted\n    \"\"\"\n    return [action.delete() for action in actions]\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.delete_boards","title":"<code>delete_boards(boards)</code>","text":"<p>Delete a list of boards</p> <p>Parameters:</p> Name Type Description Default <code>boards</code> <code>list[Board]</code> <p>Boards to delete</p> required <p>Returns:</p> Type Description <code>list[Board]</code> <p>list[Board]: Boards that were deleted</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def delete_boards(boards: list[Board]) -&gt; list[Board]:\n    \"\"\"Delete a list of boards\n\n    Args:\n        boards (list[Board]): Boards to delete\n\n    Returns:\n        list[Board]: Boards that were deleted\n    \"\"\"\n    return [board.delete() for board in boards]\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.delete_cards","title":"<code>delete_cards(cards)</code>","text":"<p>Delete a list of cards</p> <p>Parameters:</p> Name Type Description Default <code>cards</code> <code>list[Card]</code> <p>Cards to delete</p> required <p>Returns:</p> Type Description <code>list[Card]</code> <p>list[Card]: Cards that were deleted</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def delete_cards(cards: list[Card]) -&gt; list[Card]:\n    \"\"\"Delete a list of cards\n\n    Args:\n        cards (list[Card]): Cards to delete\n\n    Returns:\n        list[Card]: Cards that were deleted\n    \"\"\"\n    return [card.delete() for card in cards]\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.delete_labels","title":"<code>delete_labels(labels)</code>","text":"<p>Delete a list of labels</p> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>list[Label]</code> <p>Labels to delete</p> required <p>Returns:</p> Type Description <code>list[Label]</code> <p>list[Label]: Labels that were deleted</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def delete_labels(labels: list[Label]) -&gt; list[Label]:\n    \"\"\"Delete a list of labels\n\n    Args:\n        labels (list[Label]): Labels to delete\n\n    Returns:\n        list[Label]: Labels that were deleted\n    \"\"\"\n    return [label.delete() for label in labels]\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.delete_lists","title":"<code>delete_lists(lists)</code>","text":"<p>Delete a list of lists</p> <p>Parameters:</p> Name Type Description Default <code>lists</code> <code>list[List]</code> <p>Lists to delete</p> required <p>Returns:</p> Type Description <code>list[List]</code> <p>list[List]: Lists that were deleted</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def delete_lists(lists: list[List]) -&gt; list[List]:\n    \"\"\"Delete a list of lists\n\n    Args:\n        lists (list[List]): Lists to delete\n\n    Returns:\n        list[List]: Lists that were deleted\n    \"\"\"\n    return [list_.delete() for list_ in lists]\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.delete_projects","title":"<code>delete_projects(projects)</code>","text":"<p>Delete a list of projects</p> <p>Parameters:</p> Name Type Description Default <code>projects</code> <code>list[Project]</code> <p>Projects to delete</p> required <p>Returns:</p> Type Description <code>list[Project]</code> <p>list[Project]: Projects that were deleted</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def delete_projects(projects: list[Project]) -&gt; list[Project]:\n    \"\"\"Delete a list of projects\n\n    Args:\n        projects (list[Project]): Projects to delete\n\n    Returns:\n        list[Project]: Projects that were deleted\n    \"\"\"\n    return [project.delete() for project in projects]\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.delete_users","title":"<code>delete_users(users)</code>","text":"<p>Delete a list of users</p> <p>Parameters:</p> Name Type Description Default <code>users</code> <code>list[User]</code> <p>Users to delete</p> required <p>Returns:</p> Type Description <code>list[User]</code> <p>list[User]: Users that were deleted</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def delete_users(users: list[User]) -&gt; list[User]:\n    \"\"\"Delete a list of users\n\n    Args:\n        users (list[User]): Users to delete\n\n    Returns:\n        list[User]: Users that were deleted\n    \"\"\"\n    return [user.delete() for user in users]\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.get_boards_by_name","title":"<code>get_boards_by_name(project, name)</code>","text":"<p>Get all boards in a project by name</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>Project</code> <p>Project to search</p> required <code>name</code> <code>str</code> <p>Name of the board</p> required <p>Returns:</p> Type Description <code>list[Board]</code> <p>list[Board]: Boards in the project with the given name</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def get_boards_by_name(project: Project, name: str) -&gt; list[Board]:\n    \"\"\"Get all boards in a project by name\n\n    Args:\n        project (Project): Project to search\n        name (str): Name of the board\n\n    Returns:\n        list[Board]: Boards in the project with the given name\n    \"\"\"\n    return by_board_name(project.boards, name)\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.get_cards_by_name","title":"<code>get_cards_by_name(org_unit, name)</code>","text":"<p>Get a card by name from a list or board</p> <p>Parameters:</p> Name Type Description Default <code>org_unit</code> <code>List | Board</code> <p>List or Board to search</p> required <code>name</code> <code>str</code> <p>Name of the card</p> required <p>Returns:</p> Type Description <code>list[Card]</code> <p>list[Card]: Cards in the list or board with the given name</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def get_cards_by_name(org_unit: List | Board, name: str) -&gt; list[Card]:\n    \"\"\"Get a card by name from a list or board\n\n    Args:\n        org_unit (List | Board): List or Board to search\n        name (str): Name of the card\n\n    Returns:\n        list[Card]: Cards in the list or board with the given name\n    \"\"\"\n    return by_card_name(org_unit.cards, name)\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.get_labels_by_name","title":"<code>get_labels_by_name(org_unit, name)</code>","text":"<p>Get a label by name from a board or card</p> <p>Parameters:</p> Name Type Description Default <code>org_unit</code> <code>Board | Card</code> <p>Board or Card to search</p> required <code>name</code> <code>str</code> <p>Name of the label</p> required <p>Returns:</p> Type Description <code>list[Label]</code> <p>list[Label]: Labels in the board or card with the given name</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def get_labels_by_name(org_unit: Board | Card, name: str) -&gt; list[Label]:\n    \"\"\"Get a label by name from a board or card\n\n    Args:\n        org_unit (Board | Card): Board or Card to search\n        name (str): Name of the label\n\n    Returns:\n        list[Label]: Labels in the board or card with the given name\n    \"\"\"\n    return by_label_name(org_unit.labels, name)\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.get_lists_by_name","title":"<code>get_lists_by_name(board, name)</code>","text":"<p>Get all lists in a board by name</p> <p>Parameters:</p> Name Type Description Default <code>board</code> <code>Board</code> <p>Board to search</p> required <code>name</code> <code>str</code> <p>Name of the list</p> required <p>Returns:</p> Type Description <code>list[List]</code> <p>list[List]: Lists in the board with the given name</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def get_lists_by_name(board: Board, name: str) -&gt; list[List]:\n    \"\"\"Get all lists in a board by name\n\n    Args:\n        board (Board): Board to search\n        name (str): Name of the list\n\n    Returns:\n        list[List]: Lists in the board with the given name\n    \"\"\"\n    return by_list_name(board.lists, name)\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.get_projects_by_name","title":"<code>get_projects_by_name(planka, name)</code>","text":"<p>Get all projects with the given name</p> <p>Parameters:</p> Name Type Description Default <code>planka</code> <code>Planka</code> <p>Planka instance</p> required <code>name</code> <code>str</code> <p>Name of the project</p> required <p>Returns:</p> Type Description <code>list[Project]</code> <p>list[Project]: List of projects with the given name</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def get_projects_by_name(planka: Planka, name: str) -&gt; list[Project]:\n    \"\"\"Get all projects with the given name\n\n    Args:\n        planka (Planka): Planka instance\n        name (str): Name of the project\n\n    Returns:\n        list[Project]: List of projects with the given name\n    \"\"\"\n    return by_project_name(planka.projects, name)\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.get_users_by_username","title":"<code>get_users_by_username(org_unit, username)</code>","text":"<p>Get a user by username from a Planka Instance, Project, or Board</p> <p>Parameters:</p> Name Type Description Default <code>org_unit</code> <code>Planka | Project | Board</code> <p>Planka instance, Project, or Board to search</p> required <code>username</code> <code>str</code> <p>Username of the user</p> required <p>Returns:</p> Type Description <code>list[User]</code> <p>list[User]: Users in the org_unit with the given username</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def get_users_by_username(org_unit: Planka | Project | Board, username: str) -&gt; list[User]:\n    \"\"\"Get a user by username from a Planka Instance, Project, or Board\n\n    Args:\n        org_unit (Planka | Project | Board): Planka instance, Project, or Board to search\n        username (str): Username of the user\n\n    Returns:\n        list[User]: Users in the org_unit with the given username\n    \"\"\"\n    return by_username(org_unit.users, username)\n</code></pre>"},{"location":"helpers/helpers/#plankapy.helpers.remove_labels_from_card","title":"<code>remove_labels_from_card(card, labels)</code>","text":"<p>Remove labels from a card</p> <p>Parameters:</p> Name Type Description Default <code>card</code> <code>Card</code> <p>Card to remove labels from</p> required <code>labels</code> <code>list[Label]</code> <p>Labels to remove</p> required <p>Returns:</p> Type Description <code>list[Label]</code> <p>list[Label]: Labels that were removed</p> Source code in <code>src/plankapy/helpers.py</code> <pre><code>def remove_labels_from_card(card: Card, labels: list[Label]) -&gt; list[Label]:\n    \"\"\"Remove labels from a card\n\n    Args:\n        card (Card): Card to remove labels from\n        labels (list[Label]): Labels to remove\n\n    Returns:\n        list[Label]: Labels that were removed\n    \"\"\"\n    return [card.remove_label(label) for label in labels]\n</code></pre>"},{"location":"interfaces/Action/","title":"Action","text":"<p>               Bases: <code>Action_</code></p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>class Action(Action_): \n\n    @property\n    def card(self) -&gt; Card:\n        card_route = self.routes.get_card(id=self.cardId)\n        return Card(**card_route()['item']).bind(self.routes)\n\n    @property\n    def user(self) -&gt; User:\n        user_route = self.routes.get_user(id=self.userId)\n        return User(**user_route()['item']).bind(self.routes)\n\n    @overload\n    def update(self): ...\n\n    @overload\n    def update(self, action: Action): ...\n\n    @overload\n    def update(self, text: str=None): ...\n\n    def update(self, *args, **kwargs) -&gt; Action:\n        overload = parse_overload(\n            args, kwargs, \n            model='action', \n            options=('text',),\n            noarg=self)\n\n        route = self.routes.patch_comment_action(id=self.id)\n        self.__init__(**route(**overload)['item'])\n        return self\n\n    def delete(self) -&gt; Action:\n        \"\"\"Deletes the comment action\n\n        Danger:\n            This action is irreversible and cannot be undone\n\n        Returns:\n            Action: Deleted comment action instance\n        \"\"\"\n        self.refresh()\n        route = self.routes.delete_comment_action(id=self.id)\n        route()\n        return self\n\n    def refresh(self) -&gt; None:\n        \"\"\"Refreshes the action data\"\"\"\n        for action in self.card.comments:\n            if action.id == self.id:\n                self.__init__(**action)\n</code></pre>"},{"location":"interfaces/Action/#plankapy.interfaces.Action.delete","title":"<code>delete()</code>","text":"<p>Deletes the comment action</p> Danger <p>This action is irreversible and cannot be undone</p> <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>Deleted comment action instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def delete(self) -&gt; Action:\n    \"\"\"Deletes the comment action\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        Action: Deleted comment action instance\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_comment_action(id=self.id)\n    route()\n    return self\n</code></pre>"},{"location":"interfaces/Action/#plankapy.interfaces.Action.refresh","title":"<code>refresh()</code>","text":"<p>Refreshes the action data</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshes the action data\"\"\"\n    for action in self.card.comments:\n        if action.id == self.id:\n            self.__init__(**action)\n</code></pre>"},{"location":"interfaces/Archive/","title":"Archive","text":"<p>               Bases: <code>Archive_</code></p> <p>Interface for interacting with planka Archives and their included sub-objects</p> Warning <p>This class is not yet implemented and is a placeholder for future development There are no current Planka endpoints for interacting with <code>Archive</code> objects</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>class Archive(Archive_): \n    \"\"\"Interface for interacting with planka Archives and their included sub-objects\n\n    Warning:\n        This class is not yet implemented and is a placeholder for future development\n        There are no current Planka endpoints for interacting with `Archive` objects\n    \"\"\"\n    ...\n</code></pre>"},{"location":"interfaces/Attachment/","title":"Attachment","text":"<p>               Bases: <code>Attachment_</code></p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>class Attachment(Attachment_):\n\n    @property\n    def creator(self) -&gt; User:\n        \"\"\"User that created the attachment\"\"\"\n        user_route = self.routes.get_user(id=self.creatorUserId)\n        return User(**user_route()['item']).bind(self.routes)\n\n    @property\n    def card(self) -&gt; Card:\n        \"\"\"Card the attachment belongs to\"\"\"\n        card_route = self.routes.get_card(id=self.cardId)\n        return Card(**card_route()['item']).bind(self.routes)\n\n    def refresh(self):\n        \"\"\"Refreshes the attachment data\"\"\"\n        for attachment in self.card.attachments:\n            if attachment.id == self.id:\n                self.__init__(**attachment)\n\n    def data(self) -&gt; bytes:\n        \"\"\"Attachment data as bytes\n\n        Returns:\n            Attachment data\n        \"\"\"\n        return self.routes.handler._get_file(self.url)\n\n    def download(self, path: Path) -&gt; None:\n        \"\"\"Downloads the attachment to a file\n\n        Args:\n            path (Path): Path to the file to save the attachment to\n        \"\"\"\n        with open(path, 'wb') as file:\n            file.write(self.data())\n\n    def update(self) -&gt; Attachment:\n        \"\"\"Updates the attachment with new values\"\"\"\n        route = self.routes.patch_attachment(id=self.id)\n        self.__init__(**route(**self)['item'])\n        return self\n\n    def delete(self) -&gt; Attachment:\n        \"\"\"Deletes the attachment\n\n        Danger:\n            This action is irreversible and cannot be undone\n\n        Returns:\n            Attachment: Deleted attachment instance\n        \"\"\"\n        self.refresh()\n        route = self.routes.delete_attachment(id=self.id)\n        route()\n        return self\n</code></pre>"},{"location":"interfaces/Attachment/#plankapy.interfaces.Attachment.card","title":"<code>card</code>  <code>property</code>","text":"<p>Card the attachment belongs to</p>"},{"location":"interfaces/Attachment/#plankapy.interfaces.Attachment.creator","title":"<code>creator</code>  <code>property</code>","text":"<p>User that created the attachment</p>"},{"location":"interfaces/Attachment/#plankapy.interfaces.Attachment.data","title":"<code>data()</code>","text":"<p>Attachment data as bytes</p> <p>Returns:</p> Type Description <code>bytes</code> <p>Attachment data</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def data(self) -&gt; bytes:\n    \"\"\"Attachment data as bytes\n\n    Returns:\n        Attachment data\n    \"\"\"\n    return self.routes.handler._get_file(self.url)\n</code></pre>"},{"location":"interfaces/Attachment/#plankapy.interfaces.Attachment.delete","title":"<code>delete()</code>","text":"<p>Deletes the attachment</p> Danger <p>This action is irreversible and cannot be undone</p> <p>Returns:</p> Name Type Description <code>Attachment</code> <code>Attachment</code> <p>Deleted attachment instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def delete(self) -&gt; Attachment:\n    \"\"\"Deletes the attachment\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        Attachment: Deleted attachment instance\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_attachment(id=self.id)\n    route()\n    return self\n</code></pre>"},{"location":"interfaces/Attachment/#plankapy.interfaces.Attachment.download","title":"<code>download(path)</code>","text":"<p>Downloads the attachment to a file</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the file to save the attachment to</p> required Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def download(self, path: Path) -&gt; None:\n    \"\"\"Downloads the attachment to a file\n\n    Args:\n        path (Path): Path to the file to save the attachment to\n    \"\"\"\n    with open(path, 'wb') as file:\n        file.write(self.data())\n</code></pre>"},{"location":"interfaces/Attachment/#plankapy.interfaces.Attachment.refresh","title":"<code>refresh()</code>","text":"<p>Refreshes the attachment data</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def refresh(self):\n    \"\"\"Refreshes the attachment data\"\"\"\n    for attachment in self.card.attachments:\n        if attachment.id == self.id:\n            self.__init__(**attachment)\n</code></pre>"},{"location":"interfaces/Attachment/#plankapy.interfaces.Attachment.update","title":"<code>update()</code>","text":"<p>Updates the attachment with new values</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def update(self) -&gt; Attachment:\n    \"\"\"Updates the attachment with new values\"\"\"\n    route = self.routes.patch_attachment(id=self.id)\n    self.__init__(**route(**self)['item'])\n    return self\n</code></pre>"},{"location":"interfaces/Board/","title":"Board","text":"<p>               Bases: <code>Board_</code></p> <p>Interface for interacting with planka Boards and their included sub-objects</p> Note <p>All implemented public properties return API responses with accessed. This means that the values are not cached  and will be updated on every access. If you wish to cache values, you are responsible for doing so. By default,  property access will always provide the most up to date information.</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>class Board(Board_):\n    \"\"\"Interface for interacting with planka Boards and their included sub-objects\n\n    Note:\n        All implemented public properties return API responses with accessed. This means that the values are not cached \n        and will be updated on every access. If you wish to cache values, you are responsible for doing so. By default, \n        property access will always provide the most up to date information. \n    \"\"\"\n\n    roles = BoardRole.__args__\n\n    @property\n    def _included(self) -&gt; JSONHandler.JSONResponse:\n        \"\"\"Included data for the board\n\n        Warning:\n            This property is meant to be used internally for building objects in the other properties\n            It can be directly accessed, but it will only return JSON data and not objects\n\n        Returns:\n            Included data for the board\n        \"\"\"\n        route = self.routes.get_board(id=self.id)\n        return route()['included']\n\n    @property\n    def project(self) -&gt; Project:\n        \"\"\"Project the board belongs to\n\n        Note:\n            All objects include a reference to their parent object and parent objects include a reference to their children\n            This means that you can traverse the entire API structure from any object\n\n        Returns:\n            Project: Project instance\n        \"\"\"\n        project_route = self.routes.get_project(id=self.projectId)\n        return Project(**project_route()['item']).bind(self.routes)\n\n    @property\n    def users(self) -&gt; QueryableList[User]:\n        \"\"\"All users in the board\n\n        Returns:\n            Queryable List of all users\n        \"\"\"\n        return QueryableList([\n            User(**user).bind(self.routes)\n            for user in self._included['users']\n        ])\n\n    @property\n    def editors(self) -&gt; QueryableList[User]:\n        \"\"\"All users that can edit the board\n\n        Returns:\n            Queryable List of all editors\n        \"\"\"\n        return QueryableList([\n            user\n            for user in self.users\n            for boardMembership in self.boardMemberships\n            if boardMembership.userId == user.id and boardMembership.role == 'editor'\n        ])\n\n    @property\n    def viewers(self) -&gt; QueryableList[User]:\n        \"\"\"All users that can view the board\n\n        Returns:\n            Queryable List of all viewers\n        \"\"\"\n        return QueryableList([\n            user\n            for user in self.users\n            for boardMembership in self.boardMemberships\n            if boardMembership.userId == user.id and boardMembership.role == 'viewer'\n        ])\n\n    @property\n    def boardMemberships(self) -&gt; QueryableList[BoardMembership]:\n        \"\"\"All board memberships\n\n        Note:\n            This property is primarily here for internal use, '.editor' and '.viewer' properties \n            are derived from the board memberships\n\n        Returns:\n            Queryable List of all membership types (editor, viewer)\n        \"\"\"\n        return QueryableList([\n            BoardMembership(**boardMembership).bind(self.routes)\n            for boardMembership in self._included['boardMemberships']\n        ])\n\n    @property\n    def labels(self) -&gt; QueryableList[Label]:\n        \"\"\"All labels in the board\n\n        Returns:\n            Queryable List of all labels in the board\n        \"\"\"\n        return QueryableList([\n            Label(**label).bind(self.routes)\n            for label in self._included['labels']\n        ])\n\n    @property\n    def lists(self) -&gt; QueryableList[List]:\n        \"\"\"All lists in the board\n\n        Returns:\n            Queryable List of all lists in the board\n        \"\"\"\n        return QueryableList([\n            List(**_list).bind(self.routes)\n            for _list in self._included['lists']\n        ])\n\n    @property\n    def cards(self) -&gt; QueryableList[Card]:\n        \"\"\"All cards in the board\n\n        Returns:\n            A list of all cards in the board\n        \"\"\"\n        return QueryableList([\n            Card(**card).bind(self.routes)\n            for card in self._included['cards']\n        ])\n\n    @property\n    def cardMemberships(self) -&gt; QueryableList[CardMembership]:\n        \"\"\"All card -&gt; user relationships in the board\n\n        Note:\n            This property is used by the `Card` class to determine its users\n\n        Returns:\n            A list of all card memberships in the board\n        \"\"\"\n        return QueryableList([\n            CardMembership(**cardMembership).bind(self.routes)\n            for cardMembership in self._included['cardMemberships']\n        ])\n\n    @property\n    def cardLabels(self) -&gt; QueryableList[CardLabel]:\n        \"\"\"All card -&gt; label relationships in the board\n\n        Note:\n            This property is used by the `Card` class to determine its labels\n\n        Returns:\n            A list of all card labels in the board\n        \"\"\"\n        return QueryableList([\n            CardLabel(**cardLabel).bind(self.routes)\n            for cardLabel in self._included['cardLabels']\n        ])\n\n    @property\n    def tasks(self) -&gt; QueryableList[Task]:\n        \"\"\"All tasks in the board\n\n        Note:\n            This property is used by the `Card` class to determine its tasks\n\n        Returns:\n            A list of all card tasks in the board\n        \"\"\"\n        return QueryableList([\n            Task(**task).bind(self.routes)\n            for task in self._included['tasks']\n        ])\n\n    @property\n    def attachments(self) -&gt; QueryableList[Attachment]:\n        \"\"\"All attachments in the board\n\n        Note:\n            This property is used by the `Card` class to determine its attachments\n\n        Returns:\n            A list of all card attachments in the board\n        \"\"\"\n        return QueryableList([\n            Attachment(**attachment).bind(self.routes)\n            for attachment in self._included['attachments']\n        ])\n\n    @overload\n    def create_list(self, _list: List) -&gt; List: ...\n\n    @overload\n    def create_list(self, name: str, position: int) -&gt; List: ...\n\n    def create_list(self, *args, **kwargs) -&gt; List:\n        \"\"\"Creates a new list in the board\n\n        Args:\n            name (str): Name of the list (required)\n            position (int): Position of the list (default: 0)\n\n        Args: Alternate\n            list (List): List instance to create\n\n        Returns:\n            List: New list instance\n\n        Example:\n            ```python\n            &gt;&gt;&gt; new_list = board.create_list('My List')\n\n            &gt;&gt;&gt; l = List(name='My List', position=0)\n            &gt;&gt;&gt; new_list2 = board.create_list(l)\n            ```\n        \"\"\"\n        overload = parse_overload(args, kwargs, model='list', \n                                  options=('name', 'position'), \n                                  required=('name',))\n\n        overload['position'] = overload.get('position', 0)\n        overload['boardId'] = self.id\n\n        route = self.routes.post_list(boardId=self.id)\n        return List(**route(**overload)['item']).bind(self.routes)\n\n    @overload\n    def create_label(self, label: Label) -&gt; Label: ...\n\n    @overload\n    def create_label(self, name: str, position: int=0, color: LabelColor=None) -&gt; Label: ...\n\n    def create_label(self, *args, **kwargs) -&gt; Label:\n        \"\"\"Creates a new label in the board\n\n        Args:\n            name (str): Name of the label (required)\n            position (int): Position of the label (default: 0)\n            color (LabelColor): Color of the label (default: \"berry-red\")\n\n        Args: Alternate\n            label (Label): Label instance to create\n\n        Returns:\n            Label: New label instance\n\n        Example:\n            ```python\n            &gt;&gt;&gt; new_label = board.create_label('My Label')\n            &gt;&gt;&gt; label = Label(name='My Label', position=0, color='wet-moss')\n            &gt;&gt;&gt; new_label2 = board.create_label(label)\n            ```\n        \"\"\"\n        overload = parse_overload(args, kwargs, model='label', \n                                  options=('name', 'position', 'color'), \n                                  required=('name',)) # Only name requires user provided value\n\n        # Required arguments with defaults must be manually assigned\n        overload['position'] = overload.get('position', 0)\n        overload['color'] = overload.get('color', choice(LabelColor.__args__))\n        overload['boardId'] = self.id\n\n        route = self.routes.post_label(boardId=self.id)\n        return Label(**route(**overload)['item']).bind(self.routes)\n\n    def add_user(self, user: User, role: BoardRole='viewer', canComment: bool=False) -&gt; BoardMembership:\n        \"\"\"Adds a user to the board\n\n        Args:\n            user (User): User instance to add\n            canComment (bool): Whether the user can comment on the board (default: False)\n\n        Returns:\n            BoardMembership: New board membership\n\n        Raises:\n            ValueError: If the role is invalid (must be 'viewer' or 'editor')\n        \"\"\"\n        if role not in self.roles:\n            raise ValueError(f'Invalid role: {role}')\n\n        if role == 'editor':\n            canComment = True\n        route = self.routes.post_board_membership(boardId=self.id)\n        return BoardMembership(**route(userId=user.id, boardId=self.id, canComment=canComment, role=role)['item']).bind(self.routes)\n\n    @overload\n    def remove_user(self, user: User) -&gt; User: ...\n\n    @overload\n    def remove_user(self, userId: int) -&gt; User: ...\n\n    def remove_user(self, *args, **kwargs) -&gt; User:\n        \"\"\"Remove a user from a board\n        \"\"\"\n        overload = parse_overload(args, kwargs,\n                                  model='user',\n                                  options=('userId',),\n                                  required=('userId',))\n\n        if 'userId' not in overload: # Case if passed User\n            overload['userId'] = overload['id']\n\n        for member in self.boardMemberships:\n            if member.userId == overload['userId']:\n                member.delete()\n\n    def delete(self) -&gt; Board:\n        \"\"\"Deletes the board\n\n        Danger:\n            This action is irreversible and cannot be undone\n\n        Returns:\n            Board: Deleted board instance\n        \"\"\"\n        self.refresh()\n        route = self.routes.delete_board(id=self.id)\n        route()\n        return self\n\n    @overload\n    def update(self) -&gt; Board: ...\n\n    @overload\n    def update(self, board: Board) -&gt; Board: ...\n\n    @overload\n    def update(self, name: str=None, position: int=None) -&gt; Board: ...\n\n    def update(self, *args, **kwargs) -&gt; Board:\n        \"\"\"Updates the board with new values\n\n        Args:\n            name (str): Name of the board (optional)\n            position (int): Position of the board (optional)\n\n        Args: Alternate\n            board (Board): Board instance to update (required)\n\n        Note:\n            If no arguments are provided, the board will update itself with the current values\n            stored in its attributes\n\n        Returns:\n            Board: Updated board instance\n        \"\"\"\n        overload = parse_overload(\n            args, kwargs, \n            model='board', \n            options=('name', 'position'),\n            noarg=self)\n\n        route = self.routes.patch_board(id=self.id)\n        self.__init__(**route(**overload)['item'])\n        return self\n\n    def refresh(self) -&gt; None:\n        \"\"\"Refreshes the board data\"\"\"\n        route = self.routes.get_board(id=self.id)\n        self.__init__(**route()['item'])\n</code></pre>"},{"location":"interfaces/Board/#plankapy.interfaces.Board.attachments","title":"<code>attachments</code>  <code>property</code>","text":"<p>All attachments in the board</p> Note <p>This property is used by the <code>Card</code> class to determine its attachments</p> <p>Returns:</p> Type Description <code>QueryableList[Attachment]</code> <p>A list of all card attachments in the board</p>"},{"location":"interfaces/Board/#plankapy.interfaces.Board.boardMemberships","title":"<code>boardMemberships</code>  <code>property</code>","text":"<p>All board memberships</p> Note <p>This property is primarily here for internal use, '.editor' and '.viewer' properties  are derived from the board memberships</p> <p>Returns:</p> Type Description <code>QueryableList[BoardMembership]</code> <p>Queryable List of all membership types (editor, viewer)</p>"},{"location":"interfaces/Board/#plankapy.interfaces.Board.cardLabels","title":"<code>cardLabels</code>  <code>property</code>","text":"<p>All card -&gt; label relationships in the board</p> Note <p>This property is used by the <code>Card</code> class to determine its labels</p> <p>Returns:</p> Type Description <code>QueryableList[CardLabel]</code> <p>A list of all card labels in the board</p>"},{"location":"interfaces/Board/#plankapy.interfaces.Board.cardMemberships","title":"<code>cardMemberships</code>  <code>property</code>","text":"<p>All card -&gt; user relationships in the board</p> Note <p>This property is used by the <code>Card</code> class to determine its users</p> <p>Returns:</p> Type Description <code>QueryableList[CardMembership]</code> <p>A list of all card memberships in the board</p>"},{"location":"interfaces/Board/#plankapy.interfaces.Board.cards","title":"<code>cards</code>  <code>property</code>","text":"<p>All cards in the board</p> <p>Returns:</p> Type Description <code>QueryableList[Card]</code> <p>A list of all cards in the board</p>"},{"location":"interfaces/Board/#plankapy.interfaces.Board.editors","title":"<code>editors</code>  <code>property</code>","text":"<p>All users that can edit the board</p> <p>Returns:</p> Type Description <code>QueryableList[User]</code> <p>Queryable List of all editors</p>"},{"location":"interfaces/Board/#plankapy.interfaces.Board.labels","title":"<code>labels</code>  <code>property</code>","text":"<p>All labels in the board</p> <p>Returns:</p> Type Description <code>QueryableList[Label]</code> <p>Queryable List of all labels in the board</p>"},{"location":"interfaces/Board/#plankapy.interfaces.Board.lists","title":"<code>lists</code>  <code>property</code>","text":"<p>All lists in the board</p> <p>Returns:</p> Type Description <code>QueryableList[List]</code> <p>Queryable List of all lists in the board</p>"},{"location":"interfaces/Board/#plankapy.interfaces.Board.project","title":"<code>project</code>  <code>property</code>","text":"<p>Project the board belongs to</p> Note <p>All objects include a reference to their parent object and parent objects include a reference to their children This means that you can traverse the entire API structure from any object</p> <p>Returns:</p> Name Type Description <code>Project</code> <code>Project</code> <p>Project instance</p>"},{"location":"interfaces/Board/#plankapy.interfaces.Board.tasks","title":"<code>tasks</code>  <code>property</code>","text":"<p>All tasks in the board</p> Note <p>This property is used by the <code>Card</code> class to determine its tasks</p> <p>Returns:</p> Type Description <code>QueryableList[Task]</code> <p>A list of all card tasks in the board</p>"},{"location":"interfaces/Board/#plankapy.interfaces.Board.users","title":"<code>users</code>  <code>property</code>","text":"<p>All users in the board</p> <p>Returns:</p> Type Description <code>QueryableList[User]</code> <p>Queryable List of all users</p>"},{"location":"interfaces/Board/#plankapy.interfaces.Board.viewers","title":"<code>viewers</code>  <code>property</code>","text":"<p>All users that can view the board</p> <p>Returns:</p> Type Description <code>QueryableList[User]</code> <p>Queryable List of all viewers</p>"},{"location":"interfaces/Board/#plankapy.interfaces.Board.add_user","title":"<code>add_user(user, role='viewer', canComment=False)</code>","text":"<p>Adds a user to the board</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>User instance to add</p> required <code>canComment</code> <code>bool</code> <p>Whether the user can comment on the board (default: False)</p> <code>False</code> <p>Returns:</p> Name Type Description <code>BoardMembership</code> <code>BoardMembership</code> <p>New board membership</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the role is invalid (must be 'viewer' or 'editor')</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def add_user(self, user: User, role: BoardRole='viewer', canComment: bool=False) -&gt; BoardMembership:\n    \"\"\"Adds a user to the board\n\n    Args:\n        user (User): User instance to add\n        canComment (bool): Whether the user can comment on the board (default: False)\n\n    Returns:\n        BoardMembership: New board membership\n\n    Raises:\n        ValueError: If the role is invalid (must be 'viewer' or 'editor')\n    \"\"\"\n    if role not in self.roles:\n        raise ValueError(f'Invalid role: {role}')\n\n    if role == 'editor':\n        canComment = True\n    route = self.routes.post_board_membership(boardId=self.id)\n    return BoardMembership(**route(userId=user.id, boardId=self.id, canComment=canComment, role=role)['item']).bind(self.routes)\n</code></pre>"},{"location":"interfaces/Board/#plankapy.interfaces.Board.create_label","title":"<code>create_label(*args, **kwargs)</code>","text":"<pre><code>create_label(label: Label) -&gt; Label\n</code></pre><pre><code>create_label(name: str, position: int = 0, color: LabelColor = None) -&gt; Label\n</code></pre> <p>Creates a new label in the board</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the label (required)</p> required <code>position</code> <code>int</code> <p>Position of the label (default: 0)</p> required <code>color</code> <code>LabelColor</code> <p>Color of the label (default: \"berry-red\")</p> required <p>Alternate</p> Name Type Description Default <code>label</code> <code>Label</code> <p>Label instance to create</p> required <p>Returns:</p> Name Type Description <code>Label</code> <code>Label</code> <p>New label instance</p> Example <pre><code>&gt;&gt;&gt; new_label = board.create_label('My Label')\n&gt;&gt;&gt; label = Label(name='My Label', position=0, color='wet-moss')\n&gt;&gt;&gt; new_label2 = board.create_label(label)\n</code></pre> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def create_label(self, *args, **kwargs) -&gt; Label:\n    \"\"\"Creates a new label in the board\n\n    Args:\n        name (str): Name of the label (required)\n        position (int): Position of the label (default: 0)\n        color (LabelColor): Color of the label (default: \"berry-red\")\n\n    Args: Alternate\n        label (Label): Label instance to create\n\n    Returns:\n        Label: New label instance\n\n    Example:\n        ```python\n        &gt;&gt;&gt; new_label = board.create_label('My Label')\n        &gt;&gt;&gt; label = Label(name='My Label', position=0, color='wet-moss')\n        &gt;&gt;&gt; new_label2 = board.create_label(label)\n        ```\n    \"\"\"\n    overload = parse_overload(args, kwargs, model='label', \n                              options=('name', 'position', 'color'), \n                              required=('name',)) # Only name requires user provided value\n\n    # Required arguments with defaults must be manually assigned\n    overload['position'] = overload.get('position', 0)\n    overload['color'] = overload.get('color', choice(LabelColor.__args__))\n    overload['boardId'] = self.id\n\n    route = self.routes.post_label(boardId=self.id)\n    return Label(**route(**overload)['item']).bind(self.routes)\n</code></pre>"},{"location":"interfaces/Board/#plankapy.interfaces.Board.create_list","title":"<code>create_list(*args, **kwargs)</code>","text":"<pre><code>create_list(_list: List) -&gt; List\n</code></pre><pre><code>create_list(name: str, position: int) -&gt; List\n</code></pre> <p>Creates a new list in the board</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the list (required)</p> required <code>position</code> <code>int</code> <p>Position of the list (default: 0)</p> required <p>Alternate</p> Name Type Description Default <code>list</code> <code>List</code> <p>List instance to create</p> required <p>Returns:</p> Name Type Description <code>List</code> <code>List</code> <p>New list instance</p> Example <pre><code>&gt;&gt;&gt; new_list = board.create_list('My List')\n\n&gt;&gt;&gt; l = List(name='My List', position=0)\n&gt;&gt;&gt; new_list2 = board.create_list(l)\n</code></pre> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def create_list(self, *args, **kwargs) -&gt; List:\n    \"\"\"Creates a new list in the board\n\n    Args:\n        name (str): Name of the list (required)\n        position (int): Position of the list (default: 0)\n\n    Args: Alternate\n        list (List): List instance to create\n\n    Returns:\n        List: New list instance\n\n    Example:\n        ```python\n        &gt;&gt;&gt; new_list = board.create_list('My List')\n\n        &gt;&gt;&gt; l = List(name='My List', position=0)\n        &gt;&gt;&gt; new_list2 = board.create_list(l)\n        ```\n    \"\"\"\n    overload = parse_overload(args, kwargs, model='list', \n                              options=('name', 'position'), \n                              required=('name',))\n\n    overload['position'] = overload.get('position', 0)\n    overload['boardId'] = self.id\n\n    route = self.routes.post_list(boardId=self.id)\n    return List(**route(**overload)['item']).bind(self.routes)\n</code></pre>"},{"location":"interfaces/Board/#plankapy.interfaces.Board.delete","title":"<code>delete()</code>","text":"<p>Deletes the board</p> Danger <p>This action is irreversible and cannot be undone</p> <p>Returns:</p> Name Type Description <code>Board</code> <code>Board</code> <p>Deleted board instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def delete(self) -&gt; Board:\n    \"\"\"Deletes the board\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        Board: Deleted board instance\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_board(id=self.id)\n    route()\n    return self\n</code></pre>"},{"location":"interfaces/Board/#plankapy.interfaces.Board.refresh","title":"<code>refresh()</code>","text":"<p>Refreshes the board data</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshes the board data\"\"\"\n    route = self.routes.get_board(id=self.id)\n    self.__init__(**route()['item'])\n</code></pre>"},{"location":"interfaces/Board/#plankapy.interfaces.Board.remove_user","title":"<code>remove_user(*args, **kwargs)</code>","text":"<pre><code>remove_user(user: User) -&gt; User\n</code></pre><pre><code>remove_user(userId: int) -&gt; User\n</code></pre> <p>Remove a user from a board</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def remove_user(self, *args, **kwargs) -&gt; User:\n    \"\"\"Remove a user from a board\n    \"\"\"\n    overload = parse_overload(args, kwargs,\n                              model='user',\n                              options=('userId',),\n                              required=('userId',))\n\n    if 'userId' not in overload: # Case if passed User\n        overload['userId'] = overload['id']\n\n    for member in self.boardMemberships:\n        if member.userId == overload['userId']:\n            member.delete()\n</code></pre>"},{"location":"interfaces/Board/#plankapy.interfaces.Board.update","title":"<code>update(*args, **kwargs)</code>","text":"<pre><code>update() -&gt; Board\n</code></pre><pre><code>update(board: Board) -&gt; Board\n</code></pre><pre><code>update(name: str = None, position: int = None) -&gt; Board\n</code></pre> <p>Updates the board with new values</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the board (optional)</p> required <code>position</code> <code>int</code> <p>Position of the board (optional)</p> required <p>Alternate</p> Name Type Description Default <code>board</code> <code>Board</code> <p>Board instance to update (required)</p> required Note <p>If no arguments are provided, the board will update itself with the current values stored in its attributes</p> <p>Returns:</p> Name Type Description <code>Board</code> <code>Board</code> <p>Updated board instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def update(self, *args, **kwargs) -&gt; Board:\n    \"\"\"Updates the board with new values\n\n    Args:\n        name (str): Name of the board (optional)\n        position (int): Position of the board (optional)\n\n    Args: Alternate\n        board (Board): Board instance to update (required)\n\n    Note:\n        If no arguments are provided, the board will update itself with the current values\n        stored in its attributes\n\n    Returns:\n        Board: Updated board instance\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='board', \n        options=('name', 'position'),\n        noarg=self)\n\n    route = self.routes.patch_board(id=self.id)\n    self.__init__(**route(**overload)['item'])\n    return self\n</code></pre>"},{"location":"interfaces/BoardMembership/","title":"BoardMembership","text":"<p>               Bases: <code>BoardMembership_</code></p> <p>Interface for interacting with planka Board Memberships</p> Note <p>Only memberships that the current user has manager access to can be seen</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>class BoardMembership(BoardMembership_):\n    \"\"\"Interface for interacting with planka Board Memberships\n\n    Note:\n        Only memberships that the current user has manager access to can be seen\n    \"\"\"\n    @property\n    def user(self) -&gt; User:\n        \"\"\"User that the membership is associated with\n\n        Returns:\n            User: User instance\n        \"\"\"\n        user_route = self.routes.get_user(id=self.userId)\n        return User(**user_route()['item']).bind(self.routes)\n\n    @property\n    def board(self) -&gt; Board:\n        \"\"\"Board that the membership is associated with\n\n        Returns:\n            Board: Board instance\n        \"\"\"\n        board_route = self.routes.get_board(id=self.boardId)\n        return Board(**board_route()['item']).bind(self.routes)\n\n    @overload\n    def update(self): ...\n\n    @overload\n    def update(self, boardMembership: BoardMembership): ...\n\n    @overload\n    def update(self, role: BoardRole=None, canComment: bool=None): ...\n\n    def update(self, *args, **kwargs) -&gt; BoardMembership:\n        \"\"\"Updates the board membership with new values\n\n        Tip:\n            Use `.editor()` context manager to update the board membership with the user as an editor\n\n            Example:\n            ```python\n            &gt;&gt;&gt; with boardMembership.editor():\n            ...    boardMembership.role = 'editor'\n\n            &gt;&gt;&gt; boardMembership\n            BoardMembership(userId='...', boardId='...', role='editor', canComment=True)\n            ```\n\n        Warning:\n            canComment will always be set to True if the role is 'editor', if a context is used as a user is \n            switched to a viewer, they will maintain their ability to comment unless explicitly set to False\n\n            Example:\n            ```python\n            &gt;&gt;&gt; boardMembership.role\n            'editor'\n\n            &gt;&gt;&gt; with boardMembership.editor():\n            ...    boardMembership.role = 'viewer'\n\n            &gt;&gt;&gt; boardMembership.canComment\n            True\n\n            &gt;&gt;&gt; # Using .update() will not automatically set canComment to False\n            &gt;&gt;&gt; # on role change unless specified\n            &gt;&gt;&gt; boardMembership.update(role='viewer')\n            &gt;&gt;&gt; boardMembership.canComment\n            False\n            ```\n\n        Args:\n            role (BoardRole): Role of the user in the board (default: None)\n            canComment (bool): Whether the user can comment on the board (default: None)\n\n        Args: Alternate\n            boardMembership (BoardMembership): Board membership instance to update with\n\n        Returns:\n            BoardMembership: Updated board membership instance\n\n        Raises:\n            ValueError: If the role is invalid (must be 'viewer' or 'editor')\n\n        Note:\n            If no arguments are provided, the board membership will update itself with the current values stored in its attributes\n        \"\"\"\n        overload = parse_overload(\n            args, kwargs, \n            model='boardMembership', \n            options=('role', 'canComment'),\n            noarg=self)\n\n        if 'role' in overload:\n            if overload['role'] not in self.roles:\n                raise ValueError(\n                    f'Invalid role: {overload[\"role\"]}'\n                    f'Available roles: {self.roles}')\n\n            if overload['role'] == 'editor': # Editors can always comment\n                overload['canComment'] = True\n\n            if overload['role'] == 'viewer': # Viewers can only comment if explicitly set\n                overload['canComment'] = overload.get('canComment', False)\n\n        route = self.routes.patch_board_membership(id=self.id)\n        self.__init__(**route(**overload)['item'])\n        return self\n\n    def delete(self) -&gt; tuple[User, Board]:\n        \"\"\"Deletes the board membership relation\n\n        Danger:\n            This action is irreversible and cannot be undone\n\n        Returns:\n            User: The user that was removed from the board\n        \"\"\"\n        self.refresh()\n        route = self.routes.delete_board_membership(id=self.id)\n        route()\n        return (self.user, self.board)\n\n    def refresh(self) -&gt; None:\n        \"\"\"Refreshes the board membership data\"\"\"\n        for membership in self.board.boardMemberships:\n            if membership.id == self.id:\n                self.__init__(**membership)\n</code></pre>"},{"location":"interfaces/BoardMembership/#plankapy.interfaces.BoardMembership.board","title":"<code>board</code>  <code>property</code>","text":"<p>Board that the membership is associated with</p> <p>Returns:</p> Name Type Description <code>Board</code> <code>Board</code> <p>Board instance</p>"},{"location":"interfaces/BoardMembership/#plankapy.interfaces.BoardMembership.user","title":"<code>user</code>  <code>property</code>","text":"<p>User that the membership is associated with</p> <p>Returns:</p> Name Type Description <code>User</code> <code>User</code> <p>User instance</p>"},{"location":"interfaces/BoardMembership/#plankapy.interfaces.BoardMembership.delete","title":"<code>delete()</code>","text":"<p>Deletes the board membership relation</p> Danger <p>This action is irreversible and cannot be undone</p> <p>Returns:</p> Name Type Description <code>User</code> <code>tuple[User, Board]</code> <p>The user that was removed from the board</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def delete(self) -&gt; tuple[User, Board]:\n    \"\"\"Deletes the board membership relation\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        User: The user that was removed from the board\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_board_membership(id=self.id)\n    route()\n    return (self.user, self.board)\n</code></pre>"},{"location":"interfaces/BoardMembership/#plankapy.interfaces.BoardMembership.refresh","title":"<code>refresh()</code>","text":"<p>Refreshes the board membership data</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshes the board membership data\"\"\"\n    for membership in self.board.boardMemberships:\n        if membership.id == self.id:\n            self.__init__(**membership)\n</code></pre>"},{"location":"interfaces/BoardMembership/#plankapy.interfaces.BoardMembership.update","title":"<code>update(*args, **kwargs)</code>","text":"<pre><code>update()\n</code></pre><pre><code>update(boardMembership: BoardMembership)\n</code></pre><pre><code>update(role: BoardRole = None, canComment: bool = None)\n</code></pre> <p>Updates the board membership with new values</p> Tip <p>Use <code>.editor()</code> context manager to update the board membership with the user as an editor</p> <p>Example: <pre><code>&gt;&gt;&gt; with boardMembership.editor():\n...    boardMembership.role = 'editor'\n\n&gt;&gt;&gt; boardMembership\nBoardMembership(userId='...', boardId='...', role='editor', canComment=True)\n</code></pre></p> Warning <p>canComment will always be set to True if the role is 'editor', if a context is used as a user is  switched to a viewer, they will maintain their ability to comment unless explicitly set to False</p> <p>Example: <pre><code>&gt;&gt;&gt; boardMembership.role\n'editor'\n\n&gt;&gt;&gt; with boardMembership.editor():\n...    boardMembership.role = 'viewer'\n\n&gt;&gt;&gt; boardMembership.canComment\nTrue\n\n&gt;&gt;&gt; # Using .update() will not automatically set canComment to False\n&gt;&gt;&gt; # on role change unless specified\n&gt;&gt;&gt; boardMembership.update(role='viewer')\n&gt;&gt;&gt; boardMembership.canComment\nFalse\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>BoardRole</code> <p>Role of the user in the board (default: None)</p> required <code>canComment</code> <code>bool</code> <p>Whether the user can comment on the board (default: None)</p> required <p>Alternate</p> Name Type Description Default <code>boardMembership</code> <code>BoardMembership</code> <p>Board membership instance to update with</p> required <p>Returns:</p> Name Type Description <code>BoardMembership</code> <code>BoardMembership</code> <p>Updated board membership instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the role is invalid (must be 'viewer' or 'editor')</p> Note <p>If no arguments are provided, the board membership will update itself with the current values stored in its attributes</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def update(self, *args, **kwargs) -&gt; BoardMembership:\n    \"\"\"Updates the board membership with new values\n\n    Tip:\n        Use `.editor()` context manager to update the board membership with the user as an editor\n\n        Example:\n        ```python\n        &gt;&gt;&gt; with boardMembership.editor():\n        ...    boardMembership.role = 'editor'\n\n        &gt;&gt;&gt; boardMembership\n        BoardMembership(userId='...', boardId='...', role='editor', canComment=True)\n        ```\n\n    Warning:\n        canComment will always be set to True if the role is 'editor', if a context is used as a user is \n        switched to a viewer, they will maintain their ability to comment unless explicitly set to False\n\n        Example:\n        ```python\n        &gt;&gt;&gt; boardMembership.role\n        'editor'\n\n        &gt;&gt;&gt; with boardMembership.editor():\n        ...    boardMembership.role = 'viewer'\n\n        &gt;&gt;&gt; boardMembership.canComment\n        True\n\n        &gt;&gt;&gt; # Using .update() will not automatically set canComment to False\n        &gt;&gt;&gt; # on role change unless specified\n        &gt;&gt;&gt; boardMembership.update(role='viewer')\n        &gt;&gt;&gt; boardMembership.canComment\n        False\n        ```\n\n    Args:\n        role (BoardRole): Role of the user in the board (default: None)\n        canComment (bool): Whether the user can comment on the board (default: None)\n\n    Args: Alternate\n        boardMembership (BoardMembership): Board membership instance to update with\n\n    Returns:\n        BoardMembership: Updated board membership instance\n\n    Raises:\n        ValueError: If the role is invalid (must be 'viewer' or 'editor')\n\n    Note:\n        If no arguments are provided, the board membership will update itself with the current values stored in its attributes\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='boardMembership', \n        options=('role', 'canComment'),\n        noarg=self)\n\n    if 'role' in overload:\n        if overload['role'] not in self.roles:\n            raise ValueError(\n                f'Invalid role: {overload[\"role\"]}'\n                f'Available roles: {self.roles}')\n\n        if overload['role'] == 'editor': # Editors can always comment\n            overload['canComment'] = True\n\n        if overload['role'] == 'viewer': # Viewers can only comment if explicitly set\n            overload['canComment'] = overload.get('canComment', False)\n\n    route = self.routes.patch_board_membership(id=self.id)\n    self.__init__(**route(**overload)['item'])\n    return self\n</code></pre>"},{"location":"interfaces/Card/","title":"Card","text":"<p>               Bases: <code>Card_</code></p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>class Card(Card_):\n\n    @property \n    def _included(self) -&gt; JSONHandler.JSONResponse:\n        route = self.routes.get_card(id=self.id)\n        return route()['included']\n\n\n    @property\n    def creator(self) -&gt; User:\n        \"\"\"User that created the card\n\n        Returns:\n            User: Creator of the card\n        \"\"\"\n        user_route = self.routes.get_user(id=self.creatorUserId)\n        return User(**user_route()['item']).bind(self.routes)\n\n    @property\n    def board(self) -&gt; Board:\n        \"\"\"Board the card belongs to\n\n        Returns:\n            Board: Board instance\n        \"\"\"\n        board_route = self.routes.get_board(id=self.boardId)\n        return Board(**board_route()['item']).bind(self.routes)\n\n    @property\n    def list(self) -&gt; List:\n        \"\"\"List the card belongs to\n\n        Returns:\n            List: List instance\n        \"\"\"\n        for list in self.board.lists:\n            if list.id == self.listId:\n                return list\n\n    @property\n    def labels(self) -&gt; QueryableList[Label]:\n        \"\"\"All labels on the card\n\n        Returns:\n            Queryable List of all labels on the card\n        \"\"\"\n        return QueryableList([\n            cardLabel.label\n            for cardLabel in self.board.cardLabels\n            if cardLabel.cardId == self.id\n        ])\n\n    @property\n    def members(self) -&gt; QueryableList[User]:\n        \"\"\"All users assigned to the card\n\n        Returns:\n            Queryable List of all users assigned to the card\n        \"\"\"\n        return QueryableList([\n            cardMembership.user\n            for cardMembership in self.board.cardMemberships\n            if cardMembership.cardId == self.id\n        ])\n\n    @property\n    def comments(self) -&gt; QueryableList[Action]:\n        \"\"\"All comments on the card\n\n        Returns:\n            Queryable List of all comments on the card\n        \"\"\"\n        route = self.routes.get_action_index(cardId=self.id)\n        return QueryableList([\n            Action(**action).bind(self.routes)\n            for action in route()['items']\n        ])\n\n    @property\n    def tasks(self) -&gt; QueryableList[Task]:\n        \"\"\"All tasks on the card\n\n        Returns:\n            Queryable List of all tasks on the card\n        \"\"\"\n        return QueryableList([\n            task\n            for task in self.board.tasks\n            if task.cardId == self.id\n        ])\n\n    @property\n    def attachments(self) -&gt; QueryableList[Attachment]:\n        \"\"\"All attachments on the card\n\n        Returns:\n            Queryable List of all attachments on the card\n        \"\"\"\n        return QueryableList(\n            Attachment(**attachment).bind(self.routes)\n            for attachment in self._included['attachments'])\n\n    @property\n    def due_date(self) -&gt; datetime | None:\n        \"\"\"Due date of the card in datetime format\n\n        Note:\n            The `dueDate` attribute is stored as an ISO 8601 string, this property will return\n            the due date as a python datetime object\n\n        Returns:\n            Due date of the card\n        \"\"\"\n        return datetime.fromisoformat(self.dueDate) if self.dueDate else None\n\n    def move(self, list: List) -&gt; Card:\n        \"\"\"Moves the card to a new list\n\n        Args:\n            list (List): List instance to move the card to\n\n        Returns:\n            Card: The moved card instance\n        \"\"\"\n        self.listId = list.id\n        self.boardId = list.boardId\n        self.update()\n        return self\n\n    def duplicate(self) -&gt; Card:\n        \"\"\"Duplicates the card\n\n        Note:\n            Duplicating a card will always insert it one slot below the original card\n\n        Returns:\n            Card: The duplicated card instance\n        \"\"\"\n        route = self.routes.post_duplicate_card(id=self.id)\n        return Card(**route(**self)['item']).bind(self.routes)\n\n    # Not currently working without a file upload endpoint\n    # For this to work, we'd need to take the attacment data, post it to the filesystem,\n    # Then take the response object and dumb those values (url, coverUrl) into a new\n    # Attachment object then post it to the card using the `post_attachment(cardId)` route\n    def add_attachment(self, file_path: Path) -&gt; Attachment:\n        \"\"\"Adds an attachment to the card\n\n        Args:\n            attachment (Path | &lt;url&gt;): Attachment instance to add (can be a file path or url)\n\n        Returns:\n            Attachment: New attachment instance\n        \"\"\"\n        route = self.routes.post_attachment(cardId=self.id)\n        return Attachment(**route(_file=file_path)['item']).bind(self.routes)\n\n    def add_label(self, label: Label) -&gt; CardLabel:\n        \"\"\"Adds a label to the card\n\n        Args:\n            label (Label): Label instance to add\n\n        Returns:\n            CardLabel: New card label instance\n        \"\"\"\n        route = self.routes.post_card_label(cardId=self.id)\n        return CardLabel(**route(labelId=label.id, cardId=self.id)['item']).bind(self.routes)\n\n    def add_member(self, user: User) -&gt; CardMembership:\n        \"\"\"Adds a user to the card\n\n        Args:\n            user (User): User instance to add\n\n        Returns:\n            CardMembership: New card membership instance\n        \"\"\"\n        route = self.routes.post_card_membership(cardId=self.id)\n        return CardMembership(**route(userId=user.id, cardId=self.id)['item']).bind(self.routes)\n\n    def add_comment(self, comment: str) -&gt; Action:\n        \"\"\"Adds a comment to the card\n\n        Note:\n            Comments can only be added by the authenticated user, all comments made\n            through plankapy will be attributed to the user in `planka.me`\n\n        Args:\n            comment (str): Comment to add\n\n        Returns:\n            Action: New comment action instance\n        \"\"\"\n        route = self.routes.post_comment_action(cardId=self.id)        \n        return Action(**route(text=comment, cardId=self.id)['item']).bind(self.routes)\n\n    @overload\n    def add_task(self, task: Task) -&gt; Task: ...\n\n    @overload\n    def add_task(self, name: str, position: int=0, \n                 isCompleted: bool=False, isDeleted: bool=False) -&gt; Task: ...\n\n    def add_task(self, *args, **kwargs) -&gt; Task:\n        \"\"\"Adds a task to the card\n\n        Args:\n            name (str): Name of the task (required)\n            position (int): Position of the task (default: 0)\n            isCompleted (bool): Whether the task is completed (default: False)\n            isDeleted (bool): Whether the task is deleted (default: False)\n\n        Args: Alternate\n            task (Task): Task instance to create\n\n        Returns:\n            Task: New task instance\n        \"\"\"\n        overload = parse_overload(\n            args, kwargs, \n            model='task', \n            options=('name', 'position', 'isCompleted', 'isDeleted'), \n            required=('name',)) # Only name requires user provided value\n\n        route = self.routes.post_task(cardId=self.id)\n\n        # Required arguments with defaults must be manually assigned\n        overload['position'] = overload.get('position', 0)\n        overload['isCompleted'] = overload.get('isCompleted', False)\n        overload['isDeleted'] = overload.get('isDeleted', False)\n\n        return Task(**route(**overload)['item']).bind(self.routes)\n\n    def add_stopwatch(self) -&gt; Stopwatch:\n        \"\"\"Adds a stopwatch to the card if there is not one already\n\n        Warning:\n            The stopwatch stored in the Card instance dictionary is actually a dictionary\n            that is used to update the stopwatch on Planka. When you access the stopwatch\n            attribute with `card.stopwatch`, a `Stopwatch` instance is generated. This is\n            an implementation detail to keep the stopwatch interface separate from the Card\n            interface.\n\n            Example:\n                ```python\n                &gt;&gt;&gt; card.add_stopwatch()\n                &gt;&gt;&gt; card.stopwatch\n                Stopwatch(startedAt=None, total=0)\n\n                &gt;&gt;&gt; card.__dict__['stopwatch']\n                {'startedAt': None, 'total': 0}\n\n                &gt;&gt;&gt; card.stopwatch.start()\n                &gt;&gt;&gt; card.stopwatch\n                Stopwatch(startedAt=datetime.datetime(2024, 9, 30, 0, 0, 0), total=0)\n\n                &gt;&gt;&gt; card.__dict__['stopwatch']\n                {'startedAt': '2024-9-30T00:00:00Z', 'total': 0}\n                ```\n\n        Returns:\n            Stopwatch: A stopwatch instance used to track time on the card\n        \"\"\"\n        self.refresh()\n\n        if not self.stopwatch:\n            with self.editor():\n                self.stopwatch = {**Stopwatch(startedAt=None, total=0).stop()}\n        return self.stopwatch\n\n    def remove_attachment(self, attachment: Attachment) -&gt; Attachment | None:\n        \"\"\"Removes an attachment from the card\n\n        Args:\n            attachment (Attachment): Attachment instance to remove\n\n        Note:\n            This method will remove the attachment from the card, but the attachment itself will not be deleted\n\n        Returns:\n            Card: The card instance with the attachment removed\n        \"\"\"\n        for card_attachment in self.attachments:\n            if card_attachment.id == attachment.id:\n                return card_attachment.delete()\n        return None\n\n    def remove_label(self, label: Label) -&gt; Card:\n        \"\"\"Removes a label from the card\n\n        Args:\n            label (Label): Label instance to remove\n\n        Note:\n            This method will remove the label from the card, but the label itself will not be deleted\n\n        Returns:\n            Card: The card instance with the label removed   \n        \"\"\"\n        for card_label in self.board.cardLabels:\n            if card_label.cardId == self.id and card_label.labelId == label.id:\n                card_label.delete()\n        return self\n\n    def remove_member(self, user: User) -&gt; Card:\n        \"\"\"Removes a user from the card\n\n        Args:\n            user (User): User instance to remove\n\n        Note:\n            This method will remove the user from the card, but the user itself will not be deleted\n\n        Returns:\n            Card: The card instance with the user removed\n        \"\"\"\n        for card_membership in self.board.cardMemberships:\n            if card_membership.cardId == self.id and card_membership.userId == user.id:\n                card_membership.delete()\n        return self\n\n    def remove_comment(self, comment_action: Action) -&gt; Card:\n        \"\"\"Pass a comment from self.comments to remove it\n\n        Args:\n            comment_action (Action): Comment instance to remove\n\n        Note:\n            This method will remove the comment from the card, but the comment itself will not be deleted\n\n        Returns:\n            Card: The card instance with the comment removed\n        \"\"\"\n        for comment in self.comments:\n            if comment.id == comment_action.id:\n                comment.delete()\n        return self\n\n    def remove_stopwatch(self) -&gt; Stopwatch:\n        \"\"\"Removes the stopwatch from the card\n\n        Returns:\n            Stopwatch: The stopwatch instance that was removed\n        \"\"\"\n        self.refresh()\n        with self.editor():\n            _stopwatch = self.stopwatch\n            self.stopwatch = None\n        return _stopwatch\n\n    # Stopwatch handling is a bit weird, this is a hacky override to always show the user a Stopwatch instance\n    def __getattribute__(self, name):\n        if name == 'stopwatch':\n            current = super().__getattribute__(name)\n            if not current:\n                current = {'startedAt':None, 'total':0}\n            return Stopwatch(_card=self, **current)\n        return super().__getattribute__(name)\n\n    def __setattr__(self, name, value):\n        if name == 'stopwatch' and isinstance(value, Stopwatch):\n            super().__setattr__(name, dict(value))\n        else:\n            super().__setattr__(name, value)\n\n    def set_due_date(self, due_date: datetime  | None) -&gt; Card:\n        \"\"\"Sets the due date of the card\n\n        Args:\n            dueDate (datetime): Due date of the card (None to remove)\n\n        Returns:\n            Card: The card instance with the due date set\n        \"\"\"\n        with self.editor():\n            self.dueDate = due_date.isoformat() if due_date else None\n        return self\n\n    @overload\n    def update(self) -&gt; Card: ...\n\n    @overload\n    def update(self, card: Card) -&gt; Card: ...\n\n    @overload\n    def update(self, name: str, position: int=0, \n                    description: str=None, dueDate: datetime=None,\n                    isDueDateCompleted: bool=None,\n                    stopwatch: Stopwatch=None, boardId: int=None,\n                    listId: int=None, creatorUserId: int=None,\n                    coverAttachmentId: int=None, isSubscribed: bool=None) -&gt; Card: ...\n\n    def update(self, *args, **kwargs) -&gt; Card:\n        \"\"\"Updates the card with new values\n\n        Tip:\n            It's recommended to use a `card.editor()` context manager to update the card\n\n            Example:\n            ```python\n            &gt;&gt;&gt; with card.editor():\n            ...    card.name='New Name'\n\n            &gt;&gt;&gt; card\n            Card(name='New Name', ...)\n            ``\n\n        Args:\n            name (str): Name of the card (optional)\n            position (int): Position of the card (optional)\n            description (str): Description of the card (optional)\n            dueDate (datetime): Due date of the card (optional)\n            isDueDateCompleted (bool): Whether the due date is completed (optional)\n            stopwatch (Stopwatch): Stopwatch of the card (optional)\n            boardId (int): Board id of the card (optional)\n            listId (int): List id of the card (optional)\n            creatorUserId (int): Creator user id of the card (optional)\n            coverAttachmentId (int): Cover attachment id of the card (optional)\n            isSubscribed (bool): Whether the card is subscribed (optional)\n\n        Args: Alternate\n            card (Card): Card instance to update (required)\n\n        Note:\n            If no arguments are provided, the card will update itself with the current values stored in its attributes\n\n        Returns:\n            Card: Updated card instance\n        \"\"\"\n        overload = parse_overload(\n            args, kwargs, \n            model='card', \n            options=('name', 'position', 'description', 'dueDate', \n                    'isDueDateCompleted', 'stopwatch', \n                    'creatorUserId', 'coverAttachmentId', \n                    'isSubscribed'), \n            noarg=self)\n\n        route = self.routes.patch_card(id=self.id)\n        self.__init__(**route(**overload)['item'])\n        return self\n\n    def delete(self) -&gt; Card:\n        \"\"\"Deletes the card\n\n        Danger:\n            This action is irreversible and cannot be undone\n\n        Returns:\n            Card: The deleted card instance\n        \"\"\"\n        self.refresh()\n        route = self.routes.delete_card(id=self.id)\n        route()\n        return self\n\n    def refresh(self):\n        \"\"\"Refreshes the card data\n\n        Note:\n            This method is used to update the card instance with the latest data from the server\n        \"\"\"\n        route = self.routes.get_card(id=self.id)\n        self.__init__(**route()['item'])\n</code></pre>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.attachments","title":"<code>attachments</code>  <code>property</code>","text":"<p>All attachments on the card</p> <p>Returns:</p> Type Description <code>QueryableList[Attachment]</code> <p>Queryable List of all attachments on the card</p>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.board","title":"<code>board</code>  <code>property</code>","text":"<p>Board the card belongs to</p> <p>Returns:</p> Name Type Description <code>Board</code> <code>Board</code> <p>Board instance</p>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.comments","title":"<code>comments</code>  <code>property</code>","text":"<p>All comments on the card</p> <p>Returns:</p> Type Description <code>QueryableList[Action]</code> <p>Queryable List of all comments on the card</p>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.creator","title":"<code>creator</code>  <code>property</code>","text":"<p>User that created the card</p> <p>Returns:</p> Name Type Description <code>User</code> <code>User</code> <p>Creator of the card</p>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.due_date","title":"<code>due_date</code>  <code>property</code>","text":"<p>Due date of the card in datetime format</p> Note <p>The <code>dueDate</code> attribute is stored as an ISO 8601 string, this property will return the due date as a python datetime object</p> <p>Returns:</p> Type Description <code>datetime | None</code> <p>Due date of the card</p>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.labels","title":"<code>labels</code>  <code>property</code>","text":"<p>All labels on the card</p> <p>Returns:</p> Type Description <code>QueryableList[Label]</code> <p>Queryable List of all labels on the card</p>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.list","title":"<code>list</code>  <code>property</code>","text":"<p>List the card belongs to</p> <p>Returns:</p> Name Type Description <code>List</code> <code>List</code> <p>List instance</p>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.members","title":"<code>members</code>  <code>property</code>","text":"<p>All users assigned to the card</p> <p>Returns:</p> Type Description <code>QueryableList[User]</code> <p>Queryable List of all users assigned to the card</p>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.tasks","title":"<code>tasks</code>  <code>property</code>","text":"<p>All tasks on the card</p> <p>Returns:</p> Type Description <code>QueryableList[Task]</code> <p>Queryable List of all tasks on the card</p>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.add_attachment","title":"<code>add_attachment(file_path)</code>","text":"<p>Adds an attachment to the card</p> <p>Parameters:</p> Name Type Description Default <code>attachment</code> <code>Path | &lt;url&gt;</code> <p>Attachment instance to add (can be a file path or url)</p> required <p>Returns:</p> Name Type Description <code>Attachment</code> <code>Attachment</code> <p>New attachment instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def add_attachment(self, file_path: Path) -&gt; Attachment:\n    \"\"\"Adds an attachment to the card\n\n    Args:\n        attachment (Path | &lt;url&gt;): Attachment instance to add (can be a file path or url)\n\n    Returns:\n        Attachment: New attachment instance\n    \"\"\"\n    route = self.routes.post_attachment(cardId=self.id)\n    return Attachment(**route(_file=file_path)['item']).bind(self.routes)\n</code></pre>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.add_comment","title":"<code>add_comment(comment)</code>","text":"<p>Adds a comment to the card</p> Note <p>Comments can only be added by the authenticated user, all comments made through plankapy will be attributed to the user in <code>planka.me</code></p> <p>Parameters:</p> Name Type Description Default <code>comment</code> <code>str</code> <p>Comment to add</p> required <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>New comment action instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def add_comment(self, comment: str) -&gt; Action:\n    \"\"\"Adds a comment to the card\n\n    Note:\n        Comments can only be added by the authenticated user, all comments made\n        through plankapy will be attributed to the user in `planka.me`\n\n    Args:\n        comment (str): Comment to add\n\n    Returns:\n        Action: New comment action instance\n    \"\"\"\n    route = self.routes.post_comment_action(cardId=self.id)        \n    return Action(**route(text=comment, cardId=self.id)['item']).bind(self.routes)\n</code></pre>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.add_label","title":"<code>add_label(label)</code>","text":"<p>Adds a label to the card</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>Label</code> <p>Label instance to add</p> required <p>Returns:</p> Name Type Description <code>CardLabel</code> <code>CardLabel</code> <p>New card label instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def add_label(self, label: Label) -&gt; CardLabel:\n    \"\"\"Adds a label to the card\n\n    Args:\n        label (Label): Label instance to add\n\n    Returns:\n        CardLabel: New card label instance\n    \"\"\"\n    route = self.routes.post_card_label(cardId=self.id)\n    return CardLabel(**route(labelId=label.id, cardId=self.id)['item']).bind(self.routes)\n</code></pre>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.add_member","title":"<code>add_member(user)</code>","text":"<p>Adds a user to the card</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>User instance to add</p> required <p>Returns:</p> Name Type Description <code>CardMembership</code> <code>CardMembership</code> <p>New card membership instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def add_member(self, user: User) -&gt; CardMembership:\n    \"\"\"Adds a user to the card\n\n    Args:\n        user (User): User instance to add\n\n    Returns:\n        CardMembership: New card membership instance\n    \"\"\"\n    route = self.routes.post_card_membership(cardId=self.id)\n    return CardMembership(**route(userId=user.id, cardId=self.id)['item']).bind(self.routes)\n</code></pre>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.add_stopwatch","title":"<code>add_stopwatch()</code>","text":"<p>Adds a stopwatch to the card if there is not one already</p> Warning <p>The stopwatch stored in the Card instance dictionary is actually a dictionary that is used to update the stopwatch on Planka. When you access the stopwatch attribute with <code>card.stopwatch</code>, a <code>Stopwatch</code> instance is generated. This is an implementation detail to keep the stopwatch interface separate from the Card interface.</p> <p>Example:     <pre><code>&gt;&gt;&gt; card.add_stopwatch()\n&gt;&gt;&gt; card.stopwatch\nStopwatch(startedAt=None, total=0)\n\n&gt;&gt;&gt; card.__dict__['stopwatch']\n{'startedAt': None, 'total': 0}\n\n&gt;&gt;&gt; card.stopwatch.start()\n&gt;&gt;&gt; card.stopwatch\nStopwatch(startedAt=datetime.datetime(2024, 9, 30, 0, 0, 0), total=0)\n\n&gt;&gt;&gt; card.__dict__['stopwatch']\n{'startedAt': '2024-9-30T00:00:00Z', 'total': 0}\n</code></pre></p> <p>Returns:</p> Name Type Description <code>Stopwatch</code> <code>Stopwatch</code> <p>A stopwatch instance used to track time on the card</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def add_stopwatch(self) -&gt; Stopwatch:\n    \"\"\"Adds a stopwatch to the card if there is not one already\n\n    Warning:\n        The stopwatch stored in the Card instance dictionary is actually a dictionary\n        that is used to update the stopwatch on Planka. When you access the stopwatch\n        attribute with `card.stopwatch`, a `Stopwatch` instance is generated. This is\n        an implementation detail to keep the stopwatch interface separate from the Card\n        interface.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; card.add_stopwatch()\n            &gt;&gt;&gt; card.stopwatch\n            Stopwatch(startedAt=None, total=0)\n\n            &gt;&gt;&gt; card.__dict__['stopwatch']\n            {'startedAt': None, 'total': 0}\n\n            &gt;&gt;&gt; card.stopwatch.start()\n            &gt;&gt;&gt; card.stopwatch\n            Stopwatch(startedAt=datetime.datetime(2024, 9, 30, 0, 0, 0), total=0)\n\n            &gt;&gt;&gt; card.__dict__['stopwatch']\n            {'startedAt': '2024-9-30T00:00:00Z', 'total': 0}\n            ```\n\n    Returns:\n        Stopwatch: A stopwatch instance used to track time on the card\n    \"\"\"\n    self.refresh()\n\n    if not self.stopwatch:\n        with self.editor():\n            self.stopwatch = {**Stopwatch(startedAt=None, total=0).stop()}\n    return self.stopwatch\n</code></pre>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.add_task","title":"<code>add_task(*args, **kwargs)</code>","text":"<pre><code>add_task(task: Task) -&gt; Task\n</code></pre><pre><code>add_task(name: str, position: int = 0, isCompleted: bool = False, isDeleted: bool = False) -&gt; Task\n</code></pre> <p>Adds a task to the card</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the task (required)</p> required <code>position</code> <code>int</code> <p>Position of the task (default: 0)</p> required <code>isCompleted</code> <code>bool</code> <p>Whether the task is completed (default: False)</p> required <code>isDeleted</code> <code>bool</code> <p>Whether the task is deleted (default: False)</p> required <p>Alternate</p> Name Type Description Default <code>task</code> <code>Task</code> <p>Task instance to create</p> required <p>Returns:</p> Name Type Description <code>Task</code> <code>Task</code> <p>New task instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def add_task(self, *args, **kwargs) -&gt; Task:\n    \"\"\"Adds a task to the card\n\n    Args:\n        name (str): Name of the task (required)\n        position (int): Position of the task (default: 0)\n        isCompleted (bool): Whether the task is completed (default: False)\n        isDeleted (bool): Whether the task is deleted (default: False)\n\n    Args: Alternate\n        task (Task): Task instance to create\n\n    Returns:\n        Task: New task instance\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='task', \n        options=('name', 'position', 'isCompleted', 'isDeleted'), \n        required=('name',)) # Only name requires user provided value\n\n    route = self.routes.post_task(cardId=self.id)\n\n    # Required arguments with defaults must be manually assigned\n    overload['position'] = overload.get('position', 0)\n    overload['isCompleted'] = overload.get('isCompleted', False)\n    overload['isDeleted'] = overload.get('isDeleted', False)\n\n    return Task(**route(**overload)['item']).bind(self.routes)\n</code></pre>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.delete","title":"<code>delete()</code>","text":"<p>Deletes the card</p> Danger <p>This action is irreversible and cannot be undone</p> <p>Returns:</p> Name Type Description <code>Card</code> <code>Card</code> <p>The deleted card instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def delete(self) -&gt; Card:\n    \"\"\"Deletes the card\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        Card: The deleted card instance\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_card(id=self.id)\n    route()\n    return self\n</code></pre>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.duplicate","title":"<code>duplicate()</code>","text":"<p>Duplicates the card</p> Note <p>Duplicating a card will always insert it one slot below the original card</p> <p>Returns:</p> Name Type Description <code>Card</code> <code>Card</code> <p>The duplicated card instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def duplicate(self) -&gt; Card:\n    \"\"\"Duplicates the card\n\n    Note:\n        Duplicating a card will always insert it one slot below the original card\n\n    Returns:\n        Card: The duplicated card instance\n    \"\"\"\n    route = self.routes.post_duplicate_card(id=self.id)\n    return Card(**route(**self)['item']).bind(self.routes)\n</code></pre>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.move","title":"<code>move(list)</code>","text":"<p>Moves the card to a new list</p> <p>Parameters:</p> Name Type Description Default <code>list</code> <code>List</code> <p>List instance to move the card to</p> required <p>Returns:</p> Name Type Description <code>Card</code> <code>Card</code> <p>The moved card instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def move(self, list: List) -&gt; Card:\n    \"\"\"Moves the card to a new list\n\n    Args:\n        list (List): List instance to move the card to\n\n    Returns:\n        Card: The moved card instance\n    \"\"\"\n    self.listId = list.id\n    self.boardId = list.boardId\n    self.update()\n    return self\n</code></pre>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.refresh","title":"<code>refresh()</code>","text":"<p>Refreshes the card data</p> Note <p>This method is used to update the card instance with the latest data from the server</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def refresh(self):\n    \"\"\"Refreshes the card data\n\n    Note:\n        This method is used to update the card instance with the latest data from the server\n    \"\"\"\n    route = self.routes.get_card(id=self.id)\n    self.__init__(**route()['item'])\n</code></pre>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.remove_attachment","title":"<code>remove_attachment(attachment)</code>","text":"<p>Removes an attachment from the card</p> <p>Parameters:</p> Name Type Description Default <code>attachment</code> <code>Attachment</code> <p>Attachment instance to remove</p> required Note <p>This method will remove the attachment from the card, but the attachment itself will not be deleted</p> <p>Returns:</p> Name Type Description <code>Card</code> <code>Attachment | None</code> <p>The card instance with the attachment removed</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def remove_attachment(self, attachment: Attachment) -&gt; Attachment | None:\n    \"\"\"Removes an attachment from the card\n\n    Args:\n        attachment (Attachment): Attachment instance to remove\n\n    Note:\n        This method will remove the attachment from the card, but the attachment itself will not be deleted\n\n    Returns:\n        Card: The card instance with the attachment removed\n    \"\"\"\n    for card_attachment in self.attachments:\n        if card_attachment.id == attachment.id:\n            return card_attachment.delete()\n    return None\n</code></pre>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.remove_comment","title":"<code>remove_comment(comment_action)</code>","text":"<p>Pass a comment from self.comments to remove it</p> <p>Parameters:</p> Name Type Description Default <code>comment_action</code> <code>Action</code> <p>Comment instance to remove</p> required Note <p>This method will remove the comment from the card, but the comment itself will not be deleted</p> <p>Returns:</p> Name Type Description <code>Card</code> <code>Card</code> <p>The card instance with the comment removed</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def remove_comment(self, comment_action: Action) -&gt; Card:\n    \"\"\"Pass a comment from self.comments to remove it\n\n    Args:\n        comment_action (Action): Comment instance to remove\n\n    Note:\n        This method will remove the comment from the card, but the comment itself will not be deleted\n\n    Returns:\n        Card: The card instance with the comment removed\n    \"\"\"\n    for comment in self.comments:\n        if comment.id == comment_action.id:\n            comment.delete()\n    return self\n</code></pre>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.remove_label","title":"<code>remove_label(label)</code>","text":"<p>Removes a label from the card</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>Label</code> <p>Label instance to remove</p> required Note <p>This method will remove the label from the card, but the label itself will not be deleted</p> <p>Returns:</p> Name Type Description <code>Card</code> <code>Card</code> <p>The card instance with the label removed</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def remove_label(self, label: Label) -&gt; Card:\n    \"\"\"Removes a label from the card\n\n    Args:\n        label (Label): Label instance to remove\n\n    Note:\n        This method will remove the label from the card, but the label itself will not be deleted\n\n    Returns:\n        Card: The card instance with the label removed   \n    \"\"\"\n    for card_label in self.board.cardLabels:\n        if card_label.cardId == self.id and card_label.labelId == label.id:\n            card_label.delete()\n    return self\n</code></pre>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.remove_member","title":"<code>remove_member(user)</code>","text":"<p>Removes a user from the card</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>User</code> <p>User instance to remove</p> required Note <p>This method will remove the user from the card, but the user itself will not be deleted</p> <p>Returns:</p> Name Type Description <code>Card</code> <code>Card</code> <p>The card instance with the user removed</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def remove_member(self, user: User) -&gt; Card:\n    \"\"\"Removes a user from the card\n\n    Args:\n        user (User): User instance to remove\n\n    Note:\n        This method will remove the user from the card, but the user itself will not be deleted\n\n    Returns:\n        Card: The card instance with the user removed\n    \"\"\"\n    for card_membership in self.board.cardMemberships:\n        if card_membership.cardId == self.id and card_membership.userId == user.id:\n            card_membership.delete()\n    return self\n</code></pre>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.remove_stopwatch","title":"<code>remove_stopwatch()</code>","text":"<p>Removes the stopwatch from the card</p> <p>Returns:</p> Name Type Description <code>Stopwatch</code> <code>Stopwatch</code> <p>The stopwatch instance that was removed</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def remove_stopwatch(self) -&gt; Stopwatch:\n    \"\"\"Removes the stopwatch from the card\n\n    Returns:\n        Stopwatch: The stopwatch instance that was removed\n    \"\"\"\n    self.refresh()\n    with self.editor():\n        _stopwatch = self.stopwatch\n        self.stopwatch = None\n    return _stopwatch\n</code></pre>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.set_due_date","title":"<code>set_due_date(due_date)</code>","text":"<p>Sets the due date of the card</p> <p>Parameters:</p> Name Type Description Default <code>dueDate</code> <code>datetime</code> <p>Due date of the card (None to remove)</p> required <p>Returns:</p> Name Type Description <code>Card</code> <code>Card</code> <p>The card instance with the due date set</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def set_due_date(self, due_date: datetime  | None) -&gt; Card:\n    \"\"\"Sets the due date of the card\n\n    Args:\n        dueDate (datetime): Due date of the card (None to remove)\n\n    Returns:\n        Card: The card instance with the due date set\n    \"\"\"\n    with self.editor():\n        self.dueDate = due_date.isoformat() if due_date else None\n    return self\n</code></pre>"},{"location":"interfaces/Card/#plankapy.interfaces.Card.update","title":"<code>update(*args, **kwargs)</code>","text":"<pre><code>update() -&gt; Card\n</code></pre><pre><code>update(card: Card) -&gt; Card\n</code></pre><pre><code>update(name: str, position: int = 0, description: str = None, dueDate: datetime = None, isDueDateCompleted: bool = None, stopwatch: Stopwatch = None, boardId: int = None, listId: int = None, creatorUserId: int = None, coverAttachmentId: int = None, isSubscribed: bool = None) -&gt; Card\n</code></pre> <p>Updates the card with new values</p> Tip <p>It's recommended to use a <code>card.editor()</code> context manager to update the card</p> <p>Example: ```python</p> <p>with card.editor(): ...    card.name='New Name'</p> <p>card Card(name='New Name', ...) ``</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the card (optional)</p> required <code>position</code> <code>int</code> <p>Position of the card (optional)</p> required <code>description</code> <code>str</code> <p>Description of the card (optional)</p> required <code>dueDate</code> <code>datetime</code> <p>Due date of the card (optional)</p> required <code>isDueDateCompleted</code> <code>bool</code> <p>Whether the due date is completed (optional)</p> required <code>stopwatch</code> <code>Stopwatch</code> <p>Stopwatch of the card (optional)</p> required <code>boardId</code> <code>int</code> <p>Board id of the card (optional)</p> required <code>listId</code> <code>int</code> <p>List id of the card (optional)</p> required <code>creatorUserId</code> <code>int</code> <p>Creator user id of the card (optional)</p> required <code>coverAttachmentId</code> <code>int</code> <p>Cover attachment id of the card (optional)</p> required <code>isSubscribed</code> <code>bool</code> <p>Whether the card is subscribed (optional)</p> required <p>Alternate</p> Name Type Description Default <code>card</code> <code>Card</code> <p>Card instance to update (required)</p> required Note <p>If no arguments are provided, the card will update itself with the current values stored in its attributes</p> <p>Returns:</p> Name Type Description <code>Card</code> <code>Card</code> <p>Updated card instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def update(self, *args, **kwargs) -&gt; Card:\n    \"\"\"Updates the card with new values\n\n    Tip:\n        It's recommended to use a `card.editor()` context manager to update the card\n\n        Example:\n        ```python\n        &gt;&gt;&gt; with card.editor():\n        ...    card.name='New Name'\n\n        &gt;&gt;&gt; card\n        Card(name='New Name', ...)\n        ``\n\n    Args:\n        name (str): Name of the card (optional)\n        position (int): Position of the card (optional)\n        description (str): Description of the card (optional)\n        dueDate (datetime): Due date of the card (optional)\n        isDueDateCompleted (bool): Whether the due date is completed (optional)\n        stopwatch (Stopwatch): Stopwatch of the card (optional)\n        boardId (int): Board id of the card (optional)\n        listId (int): List id of the card (optional)\n        creatorUserId (int): Creator user id of the card (optional)\n        coverAttachmentId (int): Cover attachment id of the card (optional)\n        isSubscribed (bool): Whether the card is subscribed (optional)\n\n    Args: Alternate\n        card (Card): Card instance to update (required)\n\n    Note:\n        If no arguments are provided, the card will update itself with the current values stored in its attributes\n\n    Returns:\n        Card: Updated card instance\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='card', \n        options=('name', 'position', 'description', 'dueDate', \n                'isDueDateCompleted', 'stopwatch', \n                'creatorUserId', 'coverAttachmentId', \n                'isSubscribed'), \n        noarg=self)\n\n    route = self.routes.patch_card(id=self.id)\n    self.__init__(**route(**overload)['item'])\n    return self\n</code></pre>"},{"location":"interfaces/CardLabel/","title":"CardLabel","text":"<p>               Bases: <code>CardLabel_</code></p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>class CardLabel(CardLabel_):\n\n    @property\n    def card(self) -&gt; Card:\n        \"\"\"Card the label is attached to\n\n        Returns:\n            Card: Card instance\n        \"\"\"\n        card_route = self.routes.get_card(id=self.cardId)\n        return Card(**card_route()['item']).bind(self.routes)\n\n    @property\n    def board(self) -&gt; Board:\n        \"\"\"Board the card belongs to\n\n        Returns:\n            Board: Board instance\n        \"\"\"\n        board_route = self.routes.get_board(id=self.card.boardId)\n        return Board(**board_route()['item']).bind(self.routes)\n\n    @property\n    def label(self) -&gt; Label:\n        \"\"\"Label attached to the card\n\n        Returns:\n            Label: Label instance\n        \"\"\"\n        for label in self.board.labels:\n            if label.id == self.labelId:\n                return label\n\n    def delete(self) -&gt; tuple[Card, Label]:\n        \"\"\"Deletes the card label relationship\n\n        Danger:\n            This action is irreversible and cannot be undone\n\n        Returns:\n            tuple[Card, Label]: The card and label that were removed from each other\n        \"\"\"\n        self.refresh()\n        route = self.routes.delete_card_label(cardId=self.card.id, labelId=self.labelId)\n        route()\n        return (self.card, self.label)\n</code></pre>"},{"location":"interfaces/CardLabel/#plankapy.interfaces.CardLabel.board","title":"<code>board</code>  <code>property</code>","text":"<p>Board the card belongs to</p> <p>Returns:</p> Name Type Description <code>Board</code> <code>Board</code> <p>Board instance</p>"},{"location":"interfaces/CardLabel/#plankapy.interfaces.CardLabel.card","title":"<code>card</code>  <code>property</code>","text":"<p>Card the label is attached to</p> <p>Returns:</p> Name Type Description <code>Card</code> <code>Card</code> <p>Card instance</p>"},{"location":"interfaces/CardLabel/#plankapy.interfaces.CardLabel.label","title":"<code>label</code>  <code>property</code>","text":"<p>Label attached to the card</p> <p>Returns:</p> Name Type Description <code>Label</code> <code>Label</code> <p>Label instance</p>"},{"location":"interfaces/CardLabel/#plankapy.interfaces.CardLabel.delete","title":"<code>delete()</code>","text":"<p>Deletes the card label relationship</p> Danger <p>This action is irreversible and cannot be undone</p> <p>Returns:</p> Type Description <code>tuple[Card, Label]</code> <p>tuple[Card, Label]: The card and label that were removed from each other</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def delete(self) -&gt; tuple[Card, Label]:\n    \"\"\"Deletes the card label relationship\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        tuple[Card, Label]: The card and label that were removed from each other\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_card_label(cardId=self.card.id, labelId=self.labelId)\n    route()\n    return (self.card, self.label)\n</code></pre>"},{"location":"interfaces/CardMembership/","title":"CardMembership","text":"<p>               Bases: <code>CardMembership_</code></p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>class CardMembership(CardMembership_):\n\n    @property\n    def user(self) -&gt; User:\n        \"\"\"User that is a member of the card\n\n        Returns:\n            User: User instance\n        \"\"\"\n        user_route = self.routes.get_user(id=self.userId)\n        return User(**user_route()['item']).bind(self.routes)\n\n    @property\n    def card(self) -&gt; Card:\n        \"\"\"Card the user is a member of\n\n        Returns:\n            Card: Card instance\n        \"\"\"\n        card_route = self.routes.get_card(id=self.cardId)\n        return Card(**card_route()['item']).bind(self.routes)\n\n    def delete(self) -&gt; tuple[User, Card]:\n        \"\"\"Deletes the card membership\n\n        Danger:\n            This action is irreversible and cannot be undone\n\n        Returns:\n            tuple[User, Card]: The user and card that were removed from each other\n        \"\"\"\n        self.refresh()\n        route = self.routes.delete_card_membership(id=self.id)\n        route()\n        return (self.user, self.card)\n</code></pre>"},{"location":"interfaces/CardMembership/#plankapy.interfaces.CardMembership.card","title":"<code>card</code>  <code>property</code>","text":"<p>Card the user is a member of</p> <p>Returns:</p> Name Type Description <code>Card</code> <code>Card</code> <p>Card instance</p>"},{"location":"interfaces/CardMembership/#plankapy.interfaces.CardMembership.user","title":"<code>user</code>  <code>property</code>","text":"<p>User that is a member of the card</p> <p>Returns:</p> Name Type Description <code>User</code> <code>User</code> <p>User instance</p>"},{"location":"interfaces/CardMembership/#plankapy.interfaces.CardMembership.delete","title":"<code>delete()</code>","text":"<p>Deletes the card membership</p> Danger <p>This action is irreversible and cannot be undone</p> <p>Returns:</p> Type Description <code>tuple[User, Card]</code> <p>tuple[User, Card]: The user and card that were removed from each other</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def delete(self) -&gt; tuple[User, Card]:\n    \"\"\"Deletes the card membership\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        tuple[User, Card]: The user and card that were removed from each other\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_card_membership(id=self.id)\n    route()\n    return (self.user, self.card)\n</code></pre>"},{"location":"interfaces/CardSubscription/","title":"CardSubscription","text":"<p>               Bases: <code>CardSubscription_</code></p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>class CardSubscription(CardSubscription_): \n\n    @property\n    def user(self) -&gt; User:\n        \"\"\"User that is subscribed to the card\n\n        Returns:\n            User: User instance\n        \"\"\"\n        user_route = self.routes.get_user(id=self.userId)\n        return User(**user_route()['item']).bind(self.routes)\n\n    @property\n    def card(self) -&gt; Card:\n        \"\"\"Card the user is subscribed to\n\n        Returns:\n            Card: Card instance\n        \"\"\"\n        card_route = self.routes.get_card(id=self.cardId)\n        return Card(**card_route()['item']).bind(self.routes)\n</code></pre>"},{"location":"interfaces/CardSubscription/#plankapy.interfaces.CardSubscription.card","title":"<code>card</code>  <code>property</code>","text":"<p>Card the user is subscribed to</p> <p>Returns:</p> Name Type Description <code>Card</code> <code>Card</code> <p>Card instance</p>"},{"location":"interfaces/CardSubscription/#plankapy.interfaces.CardSubscription.user","title":"<code>user</code>  <code>property</code>","text":"<p>User that is subscribed to the card</p> <p>Returns:</p> Name Type Description <code>User</code> <code>User</code> <p>User instance</p>"},{"location":"interfaces/IdentityProviderUser/","title":"IdentityProviderUser","text":""},{"location":"interfaces/Label/","title":"Label","text":"<p>               Bases: <code>Label_</code></p> <p>Interface for interacting with planka Labels</p> Note <p>Label Colors are defined in the <code>LabelColor</code> Literal currently:</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>class Label(Label_):\n    \"\"\"Interface for interacting with planka Labels\n\n    Note:\n        Label Colors are defined in the `LabelColor` Literal\n        currently:\n\n    \"\"\"\n    colors = LabelColor.__args__\n    colors_to_hex = LabelColorHexMap\n\n    @property\n    def board(self) -&gt; Board:\n        \"\"\"Board the label belongs to\n\n        Returns:\n            Board: Board instance\n        \"\"\"\n        board_route = self.routes.get_board(id=self.boardId)\n        return Board(**board_route()['item']).bind(self.routes)\n\n    @property\n    def cards(self) -&gt; QueryableList[Card]:\n        \"\"\"All cards with the label in the board\n\n        Returns:\n            Queryable List of all cards with the label in the board\n        \"\"\"\n        return QueryableList([\n            cardLabel.card\n            for cardLabel in self.board.cardLabels\n            if cardLabel.labelId == self.id\n        ])\n\n    @overload\n    def update(self) -&gt; Label: ...\n\n    @overload\n    def update(self, label: Label) -&gt; Label: ...\n\n    @overload\n    def update(self, name: str=None, color: LabelColor=None, position: int=None) -&gt; Label: ...\n\n    def update(self, *args, **kwargs) -&gt; Label:\n        \"\"\"Updates the label with new values\n\n        Tip:\n            Use `.editor()` context manager to update the label with the user as an editor\n\n            Example:\n            ```python\n            &gt;&gt;&gt; with label.editor():\n            ...    label.name = 'My New Label'\n            ...    label.color = 'lagoon-blue'\n\n            &gt;&gt;&gt; label\n            Label(name='My New Label', color='lagoon-blue', position=0, ...)\n            ``\n\n        Args:\n            name (str): Name of the label (optional)\n            color (LabelColor): Color of the label (optional)\n            position (int): Position of the label (optional)\n\n        Args: Alternate\n            label (Label): Label instance to update with\n\n        Returns:\n            Label: Updated label instance\n\n        Raises:\n            ValueError: If the color is not in the available colors\n        \"\"\"\n        overload = parse_overload(\n            args, kwargs, \n            model='label', \n            options=('name', 'color', 'position'),\n            noarg=self)\n\n        if 'color' in overload and overload['color'] not in self.colors:\n            raise ValueError(\n                f\"Invalid color: {overload['color']}\\n\"\n                f\"Valid colors: {self.colors}\")\n\n        route = self.routes.patch_label(id=self.id)\n        self.__init__(**route(**overload)['item'])\n        return self\n\n    def hex_color(self) -&gt; str:\n        \"\"\"Returns the hex color of the label\n\n        Returns:\n            str: Hex color of the label\n        \"\"\"\n        return self.colors_to_hex[self.color]\n\n    def delete(self) -&gt; Label:\n        \"\"\"Deletes the label\n\n        Danger:\n            This action is irreversible and cannot be undone\n\n        Returns:\n            Label: Deleted label instance\n        \"\"\"\n        self.refresh()\n        route = self.routes.delete_label(id=self.id)\n        route()\n        return self\n\n    def refresh(self) -&gt; None:\n        \"\"\"Refreshes the label data\"\"\"\n        for label in self.board.labels:\n            if label.id == self.id:\n                self.__init__(**label)\n</code></pre>"},{"location":"interfaces/Label/#plankapy.interfaces.Label.board","title":"<code>board</code>  <code>property</code>","text":"<p>Board the label belongs to</p> <p>Returns:</p> Name Type Description <code>Board</code> <code>Board</code> <p>Board instance</p>"},{"location":"interfaces/Label/#plankapy.interfaces.Label.cards","title":"<code>cards</code>  <code>property</code>","text":"<p>All cards with the label in the board</p> <p>Returns:</p> Type Description <code>QueryableList[Card]</code> <p>Queryable List of all cards with the label in the board</p>"},{"location":"interfaces/Label/#plankapy.interfaces.Label.delete","title":"<code>delete()</code>","text":"<p>Deletes the label</p> Danger <p>This action is irreversible and cannot be undone</p> <p>Returns:</p> Name Type Description <code>Label</code> <code>Label</code> <p>Deleted label instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def delete(self) -&gt; Label:\n    \"\"\"Deletes the label\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        Label: Deleted label instance\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_label(id=self.id)\n    route()\n    return self\n</code></pre>"},{"location":"interfaces/Label/#plankapy.interfaces.Label.hex_color","title":"<code>hex_color()</code>","text":"<p>Returns the hex color of the label</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Hex color of the label</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def hex_color(self) -&gt; str:\n    \"\"\"Returns the hex color of the label\n\n    Returns:\n        str: Hex color of the label\n    \"\"\"\n    return self.colors_to_hex[self.color]\n</code></pre>"},{"location":"interfaces/Label/#plankapy.interfaces.Label.refresh","title":"<code>refresh()</code>","text":"<p>Refreshes the label data</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshes the label data\"\"\"\n    for label in self.board.labels:\n        if label.id == self.id:\n            self.__init__(**label)\n</code></pre>"},{"location":"interfaces/Label/#plankapy.interfaces.Label.update","title":"<code>update(*args, **kwargs)</code>","text":"<pre><code>update() -&gt; Label\n</code></pre><pre><code>update(label: Label) -&gt; Label\n</code></pre><pre><code>update(name: str = None, color: LabelColor = None, position: int = None) -&gt; Label\n</code></pre> <p>Updates the label with new values</p> Tip <p>Use <code>.editor()</code> context manager to update the label with the user as an editor</p> <p>Example: ```python</p> <p>with label.editor(): ...    label.name = 'My New Label' ...    label.color = 'lagoon-blue'</p> <p>label Label(name='My New Label', color='lagoon-blue', position=0, ...) ``</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the label (optional)</p> required <code>color</code> <code>LabelColor</code> <p>Color of the label (optional)</p> required <code>position</code> <code>int</code> <p>Position of the label (optional)</p> required <p>Alternate</p> Name Type Description Default <code>label</code> <code>Label</code> <p>Label instance to update with</p> required <p>Returns:</p> Name Type Description <code>Label</code> <code>Label</code> <p>Updated label instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the color is not in the available colors</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def update(self, *args, **kwargs) -&gt; Label:\n    \"\"\"Updates the label with new values\n\n    Tip:\n        Use `.editor()` context manager to update the label with the user as an editor\n\n        Example:\n        ```python\n        &gt;&gt;&gt; with label.editor():\n        ...    label.name = 'My New Label'\n        ...    label.color = 'lagoon-blue'\n\n        &gt;&gt;&gt; label\n        Label(name='My New Label', color='lagoon-blue', position=0, ...)\n        ``\n\n    Args:\n        name (str): Name of the label (optional)\n        color (LabelColor): Color of the label (optional)\n        position (int): Position of the label (optional)\n\n    Args: Alternate\n        label (Label): Label instance to update with\n\n    Returns:\n        Label: Updated label instance\n\n    Raises:\n        ValueError: If the color is not in the available colors\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='label', \n        options=('name', 'color', 'position'),\n        noarg=self)\n\n    if 'color' in overload and overload['color'] not in self.colors:\n        raise ValueError(\n            f\"Invalid color: {overload['color']}\\n\"\n            f\"Valid colors: {self.colors}\")\n\n    route = self.routes.patch_label(id=self.id)\n    self.__init__(**route(**overload)['item'])\n    return self\n</code></pre>"},{"location":"interfaces/List/","title":"List","text":"<p>               Bases: <code>List_</code></p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>class List(List_):\n\n    @property\n    def board(self) -&gt; Board:\n        \"\"\"Board the list belongs to\n\n        Returns:\n            Board: Board instance\n        \"\"\"\n        board_route = self.routes.get_board(id=self.boardId)\n        return Board(**board_route()['item']).bind(self.routes)\n\n    @property\n    def cards(self) -&gt; QueryableList[Card]:\n        \"\"\"All cards in the list\n\n        Returns:\n            Queryable List of all cards in the list\n        \"\"\"\n        return QueryableList([\n            card\n            for card in self.board.cards\n            if card.listId == self.id\n        ])\n\n    @overload\n    def create_card(self, card: Card) -&gt; Card: ...\n\n    @overload\n    def create_card(self, name: str, position: int=0, \n                    description: str=None, dueDate: datetime=None,\n                    isDueDateCompleted: bool=None,\n                    stopwatch: Stopwatch=None, boardId: int=None,\n                    listId: int=None, creatorUserId: int=None,\n                    coverAttachmentId: int=None, isSubscribed: bool=None) -&gt; Card: ...\n\n    def create_card(self, *args, **kwargs) -&gt; Card:\n        \"\"\"Creates a card in the list\n\n        Args:\n            name (str): Name of the card (required)\n            position (int): Position of the card (default: 0)\n            description (str): Description of the card (optional)\n            dueDate (datetime): Due date of the card (optional)\n            isDueDateCompleted (bool): Whether the due date is completed (optional)\n            stopwatch (Stopwatch): Stopwatch of the card (optional)\n            boardId (int): Board id of the card (optional)\n            listId (int): List id of the card (optional)\n            creatorUserId (int): Creator user id of the card (optional)\n            coverAttachmentId (int): Cover attachment id of the card (optional)\n            isSubscribed (bool): Whether the card is subscribed (optional)\n\n        Args: Alternate\n            card (Card): Card instance to create\n\n        Returns:\n            Card: New card instance\n        \"\"\"\n        overload = parse_overload(\n            args, kwargs, \n            model='card', \n            options=('name', 'position', 'description', 'dueDate', \n                    'isDueDateCompleted', 'stopwatch', \n                    'creatorUserId', 'coverAttachmentId', \n                    'isSubscribed'), \n            required=('name',))\n\n        overload['boardId'] = self.boardId\n        overload['listId'] = self.id\n        overload['position'] = overload.get('position', 0)\n\n        route = self.routes.post_card(id=self.id)\n        return Card(**route(**overload)['item']).bind(self.routes)\n\n    def _sort(self, sort: SortOption) -&gt; None:\n        route = self.routes.post_sort_list(id=self.id)\n        route(**{'type': ListSorts[sort]})\n\n    def sort_by_name(self) -&gt; None:\n        \"\"\"Sorts cards in the list by name\n\n        Note:\n            After sorting, a call to `list.cards` will return a sorted list of cards\n        \"\"\"\n        self._sort('Name')\n\n    def sort_by_due_date(self) -&gt; None:\n        \"\"\"Sorts cards in the list by due date\n\n        Note:\n            After sorting, a call to `list.cards` will return a sorted list of cards\n        \"\"\"\n        self._sort('Due date')\n\n    def sort_by_newest(self) -&gt; None:\n        \"\"\"Sorts cards in the list by newest first\n\n        Note:\n            After sorting, a call to `list.cards` will return a sorted list of cards\n        \"\"\"\n        self._sort('Newest First')\n\n    def sort_by_oldest(self) -&gt; None:\n        \"\"\"Sorts cards in the list by oldest first\n\n        Note:\n            After sorting, a call to `list.cards` will return a sorted list of cards\n        \"\"\"\n        self._sort('Oldest First')\n\n    def delete(self) -&gt; List:\n        \"\"\"Deletes the list\n\n        Danger:\n            This action is irreversible and cannot be undone\n\n        Returns:\n            List: Deleted list instance\n        \"\"\"\n        self.refresh()\n        route = self.routes.delete_list(id=self.id)\n        route()\n        return self\n\n    @overload\n    def update(self) -&gt; List: ...\n\n    @overload\n    def update(self, list: List) -&gt; List: ...\n\n    @overload\n    def update(self, name: str=None, position: int=None) -&gt; List: ...\n\n    def update(self, *args, **kwargs) -&gt; List:\n        \"\"\"Updates the list with new values\n\n        Tip:\n            If you want to update a list, it's better to use the `editor()` context manager\n\n            Example:\n            ```python\n            &gt;&gt;&gt; with list_.editor():\n            ...    list_.name = 'New List Name'\n            ...    list_.position = 1\n\n            &gt;&gt;&gt; list\n            List(id=1, name='New List Name', position=1, ...)\n            ```\n\n        Args:\n            name (str): Name of the list (optional)\n            position (int): Position of the list (optional)\n\n        Args: Alternate\n            list (List): List instance to update (required)\n\n        Note:\n            If no arguments are provided, the list will update itself with the current values stored in its attributes\n\n        Returns:\n            List: Updated list instance\n        \"\"\"\n        overload = parse_overload(\n            args, kwargs, \n            model='list', \n            options=('name', 'position'),\n            noarg=self)\n\n        route = self.routes.patch_list(id=self.id)\n        self.__init__(**route(**overload)['item'])\n        return self\n\n    def refresh(self) -&gt; None:\n        \"\"\"Refreshes the list data\"\"\"\n        for _list in self.board.lists:\n            if _list.id == self.id:\n                self.__init__(**_list)\n\n    def set_color(self, color: ListColors) -&gt; List:\n        \"\"\"Sets the color of the list\n\n        Note:\n            This method is only available in Planka 2.0.0 and later\n\n        Args:\n            color (str): Color of the list\n\n        Returns:\n            List: The list instance with the color set\n        \"\"\"\n        if color not in ListColors.__args__:\n            raise ValueError(\n                f\"Invalid color: {color}\\n\"\n                f\"Valid colors: {ListColors.__args__}\")\n        with self.editor():\n            self.color = color\n        return self\n</code></pre>"},{"location":"interfaces/List/#plankapy.interfaces.List.board","title":"<code>board</code>  <code>property</code>","text":"<p>Board the list belongs to</p> <p>Returns:</p> Name Type Description <code>Board</code> <code>Board</code> <p>Board instance</p>"},{"location":"interfaces/List/#plankapy.interfaces.List.cards","title":"<code>cards</code>  <code>property</code>","text":"<p>All cards in the list</p> <p>Returns:</p> Type Description <code>QueryableList[Card]</code> <p>Queryable List of all cards in the list</p>"},{"location":"interfaces/List/#plankapy.interfaces.List.create_card","title":"<code>create_card(*args, **kwargs)</code>","text":"<pre><code>create_card(card: Card) -&gt; Card\n</code></pre><pre><code>create_card(name: str, position: int = 0, description: str = None, dueDate: datetime = None, isDueDateCompleted: bool = None, stopwatch: Stopwatch = None, boardId: int = None, listId: int = None, creatorUserId: int = None, coverAttachmentId: int = None, isSubscribed: bool = None) -&gt; Card\n</code></pre> <p>Creates a card in the list</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the card (required)</p> required <code>position</code> <code>int</code> <p>Position of the card (default: 0)</p> required <code>description</code> <code>str</code> <p>Description of the card (optional)</p> required <code>dueDate</code> <code>datetime</code> <p>Due date of the card (optional)</p> required <code>isDueDateCompleted</code> <code>bool</code> <p>Whether the due date is completed (optional)</p> required <code>stopwatch</code> <code>Stopwatch</code> <p>Stopwatch of the card (optional)</p> required <code>boardId</code> <code>int</code> <p>Board id of the card (optional)</p> required <code>listId</code> <code>int</code> <p>List id of the card (optional)</p> required <code>creatorUserId</code> <code>int</code> <p>Creator user id of the card (optional)</p> required <code>coverAttachmentId</code> <code>int</code> <p>Cover attachment id of the card (optional)</p> required <code>isSubscribed</code> <code>bool</code> <p>Whether the card is subscribed (optional)</p> required <p>Alternate</p> Name Type Description Default <code>card</code> <code>Card</code> <p>Card instance to create</p> required <p>Returns:</p> Name Type Description <code>Card</code> <code>Card</code> <p>New card instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def create_card(self, *args, **kwargs) -&gt; Card:\n    \"\"\"Creates a card in the list\n\n    Args:\n        name (str): Name of the card (required)\n        position (int): Position of the card (default: 0)\n        description (str): Description of the card (optional)\n        dueDate (datetime): Due date of the card (optional)\n        isDueDateCompleted (bool): Whether the due date is completed (optional)\n        stopwatch (Stopwatch): Stopwatch of the card (optional)\n        boardId (int): Board id of the card (optional)\n        listId (int): List id of the card (optional)\n        creatorUserId (int): Creator user id of the card (optional)\n        coverAttachmentId (int): Cover attachment id of the card (optional)\n        isSubscribed (bool): Whether the card is subscribed (optional)\n\n    Args: Alternate\n        card (Card): Card instance to create\n\n    Returns:\n        Card: New card instance\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='card', \n        options=('name', 'position', 'description', 'dueDate', \n                'isDueDateCompleted', 'stopwatch', \n                'creatorUserId', 'coverAttachmentId', \n                'isSubscribed'), \n        required=('name',))\n\n    overload['boardId'] = self.boardId\n    overload['listId'] = self.id\n    overload['position'] = overload.get('position', 0)\n\n    route = self.routes.post_card(id=self.id)\n    return Card(**route(**overload)['item']).bind(self.routes)\n</code></pre>"},{"location":"interfaces/List/#plankapy.interfaces.List.delete","title":"<code>delete()</code>","text":"<p>Deletes the list</p> Danger <p>This action is irreversible and cannot be undone</p> <p>Returns:</p> Name Type Description <code>List</code> <code>List</code> <p>Deleted list instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def delete(self) -&gt; List:\n    \"\"\"Deletes the list\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        List: Deleted list instance\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_list(id=self.id)\n    route()\n    return self\n</code></pre>"},{"location":"interfaces/List/#plankapy.interfaces.List.refresh","title":"<code>refresh()</code>","text":"<p>Refreshes the list data</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshes the list data\"\"\"\n    for _list in self.board.lists:\n        if _list.id == self.id:\n            self.__init__(**_list)\n</code></pre>"},{"location":"interfaces/List/#plankapy.interfaces.List.set_color","title":"<code>set_color(color)</code>","text":"<p>Sets the color of the list</p> Note <p>This method is only available in Planka 2.0.0 and later</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str</code> <p>Color of the list</p> required <p>Returns:</p> Name Type Description <code>List</code> <code>List</code> <p>The list instance with the color set</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def set_color(self, color: ListColors) -&gt; List:\n    \"\"\"Sets the color of the list\n\n    Note:\n        This method is only available in Planka 2.0.0 and later\n\n    Args:\n        color (str): Color of the list\n\n    Returns:\n        List: The list instance with the color set\n    \"\"\"\n    if color not in ListColors.__args__:\n        raise ValueError(\n            f\"Invalid color: {color}\\n\"\n            f\"Valid colors: {ListColors.__args__}\")\n    with self.editor():\n        self.color = color\n    return self\n</code></pre>"},{"location":"interfaces/List/#plankapy.interfaces.List.sort_by_due_date","title":"<code>sort_by_due_date()</code>","text":"<p>Sorts cards in the list by due date</p> Note <p>After sorting, a call to <code>list.cards</code> will return a sorted list of cards</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def sort_by_due_date(self) -&gt; None:\n    \"\"\"Sorts cards in the list by due date\n\n    Note:\n        After sorting, a call to `list.cards` will return a sorted list of cards\n    \"\"\"\n    self._sort('Due date')\n</code></pre>"},{"location":"interfaces/List/#plankapy.interfaces.List.sort_by_name","title":"<code>sort_by_name()</code>","text":"<p>Sorts cards in the list by name</p> Note <p>After sorting, a call to <code>list.cards</code> will return a sorted list of cards</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def sort_by_name(self) -&gt; None:\n    \"\"\"Sorts cards in the list by name\n\n    Note:\n        After sorting, a call to `list.cards` will return a sorted list of cards\n    \"\"\"\n    self._sort('Name')\n</code></pre>"},{"location":"interfaces/List/#plankapy.interfaces.List.sort_by_newest","title":"<code>sort_by_newest()</code>","text":"<p>Sorts cards in the list by newest first</p> Note <p>After sorting, a call to <code>list.cards</code> will return a sorted list of cards</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def sort_by_newest(self) -&gt; None:\n    \"\"\"Sorts cards in the list by newest first\n\n    Note:\n        After sorting, a call to `list.cards` will return a sorted list of cards\n    \"\"\"\n    self._sort('Newest First')\n</code></pre>"},{"location":"interfaces/List/#plankapy.interfaces.List.sort_by_oldest","title":"<code>sort_by_oldest()</code>","text":"<p>Sorts cards in the list by oldest first</p> Note <p>After sorting, a call to <code>list.cards</code> will return a sorted list of cards</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def sort_by_oldest(self) -&gt; None:\n    \"\"\"Sorts cards in the list by oldest first\n\n    Note:\n        After sorting, a call to `list.cards` will return a sorted list of cards\n    \"\"\"\n    self._sort('Oldest First')\n</code></pre>"},{"location":"interfaces/List/#plankapy.interfaces.List.update","title":"<code>update(*args, **kwargs)</code>","text":"<pre><code>update() -&gt; List\n</code></pre><pre><code>update(list: List) -&gt; List\n</code></pre><pre><code>update(name: str = None, position: int = None) -&gt; List\n</code></pre> <p>Updates the list with new values</p> Tip <p>If you want to update a list, it's better to use the <code>editor()</code> context manager</p> <p>Example: <pre><code>&gt;&gt;&gt; with list_.editor():\n...    list_.name = 'New List Name'\n...    list_.position = 1\n\n&gt;&gt;&gt; list\nList(id=1, name='New List Name', position=1, ...)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the list (optional)</p> required <code>position</code> <code>int</code> <p>Position of the list (optional)</p> required <p>Alternate</p> Name Type Description Default <code>list</code> <code>List</code> <p>List instance to update (required)</p> required Note <p>If no arguments are provided, the list will update itself with the current values stored in its attributes</p> <p>Returns:</p> Name Type Description <code>List</code> <code>List</code> <p>Updated list instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def update(self, *args, **kwargs) -&gt; List:\n    \"\"\"Updates the list with new values\n\n    Tip:\n        If you want to update a list, it's better to use the `editor()` context manager\n\n        Example:\n        ```python\n        &gt;&gt;&gt; with list_.editor():\n        ...    list_.name = 'New List Name'\n        ...    list_.position = 1\n\n        &gt;&gt;&gt; list\n        List(id=1, name='New List Name', position=1, ...)\n        ```\n\n    Args:\n        name (str): Name of the list (optional)\n        position (int): Position of the list (optional)\n\n    Args: Alternate\n        list (List): List instance to update (required)\n\n    Note:\n        If no arguments are provided, the list will update itself with the current values stored in its attributes\n\n    Returns:\n        List: Updated list instance\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='list', \n        options=('name', 'position'),\n        noarg=self)\n\n    route = self.routes.patch_list(id=self.id)\n    self.__init__(**route(**overload)['item'])\n    return self\n</code></pre>"},{"location":"interfaces/Notification/","title":"Notification","text":"<p>               Bases: <code>Notification_</code></p> <p>Interface for interacting with planka Notifications</p> Note <p>Only notifications that are associated with the current user can be accessed</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>class Notification(Notification_):\n    \"\"\"Interface for interacting with planka Notifications\n\n    Note:\n        Only notifications that are associated with the current user can be accessed\n    \"\"\"\n    @property\n    def user(self) -&gt; User:\n        \"\"\"User that the notification is associated with\n\n        Returns:\n            User: User instance\n        \"\"\"\n        user_route = self.routes.get_user(id=self.userId)\n        return User(**user_route()['item']).bind(self.routes)\n\n    @property\n    def action(self) -&gt; Action:\n        \"\"\"Action that the notification is associated with\n\n        Returns:\n            Action: Action instance\n        \"\"\"\n        action_route = self.routes.get_action(id=self.actionId)\n        return Action(**action_route()['item']).bind(self.routes)\n\n    @property\n    def card(self) -&gt; Card:\n        \"\"\"Card that the notification is associated with\n\n        Returns:\n            Card: Card instance\n        \"\"\"\n        card_route = self.routes.get_card(id=self.cardId)\n        return Card(**card_route()['item']).bind(self.routes)\n\n    @overload\n    def update(self): ...\n\n    @overload\n    def update(self, notification: Notification): ...\n\n    @overload\n    def update(self, isRead: bool=None): ...\n\n    def update(self, *args, **kwargs) -&gt; Notification:\n        \"\"\"Updates the notification with new values\n\n        Note:\n            The only value that can be updated is the 'isRead' value. There is no way to delete a notification\n            use the `.mark_as_read()` method to mark the notification as read\n\n        Args:\n            isRead (bool): Whether the notification is read (default: None)\n\n        Args: Alternate\n            notification (Notification): Notification instance to update with\n\n        Note:\n            If no arguments are provided, the notification will update itself with the current values stored in its attributes\n        \"\"\"\n        overload = parse_overload(\n            args, kwargs, \n            model='notification', \n            options=('isRead',),\n            noarg=self)\n\n        route = self.routes.patch_notification(id=self.id)\n        self.__init__(**route(**overload)['item'])\n        return self\n\n    def mark_as_read(self) -&gt; None:\n        \"\"\"Marks the notification as read\n\n        Note:\n            There is no way to delete a notification, only mark it as read\n        \"\"\"\n        with self.editor():\n            self.isRead = True\n\n    def refresh(self) -&gt; None:\n        \"\"\"Refreshes the notification data\"\"\"\n        route = self.routes.get_notification(id=self.id)\n        self.__init__(**route()['item'])\n</code></pre>"},{"location":"interfaces/Notification/#plankapy.interfaces.Notification.action","title":"<code>action</code>  <code>property</code>","text":"<p>Action that the notification is associated with</p> <p>Returns:</p> Name Type Description <code>Action</code> <code>Action</code> <p>Action instance</p>"},{"location":"interfaces/Notification/#plankapy.interfaces.Notification.card","title":"<code>card</code>  <code>property</code>","text":"<p>Card that the notification is associated with</p> <p>Returns:</p> Name Type Description <code>Card</code> <code>Card</code> <p>Card instance</p>"},{"location":"interfaces/Notification/#plankapy.interfaces.Notification.user","title":"<code>user</code>  <code>property</code>","text":"<p>User that the notification is associated with</p> <p>Returns:</p> Name Type Description <code>User</code> <code>User</code> <p>User instance</p>"},{"location":"interfaces/Notification/#plankapy.interfaces.Notification.mark_as_read","title":"<code>mark_as_read()</code>","text":"<p>Marks the notification as read</p> Note <p>There is no way to delete a notification, only mark it as read</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def mark_as_read(self) -&gt; None:\n    \"\"\"Marks the notification as read\n\n    Note:\n        There is no way to delete a notification, only mark it as read\n    \"\"\"\n    with self.editor():\n        self.isRead = True\n</code></pre>"},{"location":"interfaces/Notification/#plankapy.interfaces.Notification.refresh","title":"<code>refresh()</code>","text":"<p>Refreshes the notification data</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshes the notification data\"\"\"\n    route = self.routes.get_notification(id=self.id)\n    self.__init__(**route()['item'])\n</code></pre>"},{"location":"interfaces/Notification/#plankapy.interfaces.Notification.update","title":"<code>update(*args, **kwargs)</code>","text":"<pre><code>update()\n</code></pre><pre><code>update(notification: Notification)\n</code></pre><pre><code>update(isRead: bool = None)\n</code></pre> <p>Updates the notification with new values</p> Note <p>The only value that can be updated is the 'isRead' value. There is no way to delete a notification use the <code>.mark_as_read()</code> method to mark the notification as read</p> <p>Parameters:</p> Name Type Description Default <code>isRead</code> <code>bool</code> <p>Whether the notification is read (default: None)</p> required <p>Alternate</p> Name Type Description Default <code>notification</code> <code>Notification</code> <p>Notification instance to update with</p> required Note <p>If no arguments are provided, the notification will update itself with the current values stored in its attributes</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def update(self, *args, **kwargs) -&gt; Notification:\n    \"\"\"Updates the notification with new values\n\n    Note:\n        The only value that can be updated is the 'isRead' value. There is no way to delete a notification\n        use the `.mark_as_read()` method to mark the notification as read\n\n    Args:\n        isRead (bool): Whether the notification is read (default: None)\n\n    Args: Alternate\n        notification (Notification): Notification instance to update with\n\n    Note:\n        If no arguments are provided, the notification will update itself with the current values stored in its attributes\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='notification', \n        options=('isRead',),\n        noarg=self)\n\n    route = self.routes.patch_notification(id=self.id)\n    self.__init__(**route(**overload)['item'])\n    return self\n</code></pre>"},{"location":"interfaces/Planka/","title":"Planka","text":"<p>Root object for interacting with the Planka API</p> <p>Attributes:</p> Name Type Description <code>auth</code> <code>Type[BaseAuth]</code> <p>Authentication method</p> <code>url</code> <code>str</code> <p>Base url for the Planka instance</p> <code>handler</code> <code>JSONHandler</code> <p>JSONHandler instance for making requests</p> Note <p>All objects that return a list of objects will return a <code>QueryableList</code> object. This object is a subclass of <code>list</code> see the <code>QueryableList</code> docs for more information</p> Note <p>All implemented public properties return API responses with accessed. This means that the values are not cached  and will be updated on every access. If you wish to cache values, you are responsible for doing so. By default,  property access will always provide the most up to date information.</p> <p>Example:     <pre><code>&gt;&gt;&gt; len(project.cards)\n5\n&gt;&gt;&gt; project.create_card('My Card')\n&gt;&gt;&gt; len(project.cards)\n6\n</code></pre></p> Example <pre><code>&gt;&gt;&gt; from plankapy import Planka, PasswordAuth\n\n&gt;&gt;&gt; auth = PasswordAuth('username', 'password')\n&gt;&gt;&gt; planka = Planka('https://planka.example.com', auth)\n\n&gt;&gt;&gt; planka.me\nUser(id=...9234, name='username', ...)\n</code></pre> Tip <p>If you want to store a property chain to update later, but dont want to call it by full name, you can use a lambda</p> <p>Example:     <pre><code>&gt;&gt;&gt; card = lambda: planka.project[0].boards[0].lists[0].cards[0]\n&gt;&gt;&gt; comments = lambda: card().comments\n&gt;&gt;&gt; len(comments())\n2\n\n&gt;&gt;&gt; card().add_comment('My Comment')\n&gt;&gt;&gt; len(comments())\n3\n</code></pre></p> Tip <p>All objects inherit the <code>editor</code> context manager from the <code>Model</code> class except <code>Planka</code>. This means if you want to make changes to something, you can do it directly to attributes in an editor context instead of calling the model's <code>update</code> method</p> <p>Example:     <pre><code>&gt;&gt;&gt; with card.editor():\n...    card.name = 'My New Card'\n...    card.description = 'My New Description'\n\n&gt;&gt;&gt; card.name\n'My New Card'\n</code></pre></p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>class Planka:\n    \"\"\"Root object for interacting with the Planka API\n\n    Attributes:\n        auth (Type[BaseAuth]): Authentication method\n        url (str): Base url for the Planka instance\n        handler (JSONHandler): JSONHandler instance for making requests\n\n    Note:\n        All objects that return a list of objects will return a `QueryableList` object. This object is a subclass of `list`\n        see the `QueryableList` docs for more information\n\n    Note:\n        All implemented public properties return API responses with accessed. This means that the values are not cached \n        and will be updated on every access. If you wish to cache values, you are responsible for doing so. By default, \n        property access will always provide the most up to date information.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; len(project.cards)\n            5\n            &gt;&gt;&gt; project.create_card('My Card')\n            &gt;&gt;&gt; len(project.cards)\n            6\n            ```\n\n    Example:\n        ```python\n        &gt;&gt;&gt; from plankapy import Planka, PasswordAuth\n\n        &gt;&gt;&gt; auth = PasswordAuth('username', 'password')\n        &gt;&gt;&gt; planka = Planka('https://planka.example.com', auth)\n\n        &gt;&gt;&gt; planka.me\n        User(id=...9234, name='username', ...)\n        ```\n\n    Tip:\n        If you want to store a property chain to update later, but dont want to call it by full name, you can use a lambda\n\n        Example:\n            ```python\n            &gt;&gt;&gt; card = lambda: planka.project[0].boards[0].lists[0].cards[0]\n            &gt;&gt;&gt; comments = lambda: card().comments\n            &gt;&gt;&gt; len(comments())\n            2\n\n            &gt;&gt;&gt; card().add_comment('My Comment')\n            &gt;&gt;&gt; len(comments())\n            3\n            ```\n\n    Tip:\n        All objects inherit the `editor` context manager from the `Model` class except `Planka`.\n        This means if you want to make changes to something, you can do it directly to attributes\n        in an editor context instead of calling the model's `update` method\n\n        Example:\n            ```python\n            &gt;&gt;&gt; with card.editor():\n            ...    card.name = 'My New Card'\n            ...    card.description = 'My New Description'\n\n            &gt;&gt;&gt; card.name\n            'My New Card'\n            ```\n    \"\"\"\n    def __init__(self, url: str, auth: Type[BaseAuth]):        \n        self._url = url\n        self._auth = auth\n        self._create_session()\n\n    def _create_session(self) -&gt; None:\n        \"\"\"INTERNAL: Creates a new session with the current authentication method and url\"\"\"\n        self.handler = JSONHandler(self.url)\n        self.handler.headers.update(self.auth.authenticate(self.url))\n        self.routes = Routes(self.handler)\n\n    @property\n    def auth(self) -&gt; Type[BaseAuth]:\n        \"\"\"Current authentication instance\n\n        Returns:\n            Authentication method\n        \"\"\"\n        return self._auth\n\n    @auth.setter\n    def auth(self, auth: Type[BaseAuth]):\n        \"\"\"Changes the authentication method and creates a new session\n\n        Args:\n            auth (Type[BaseAuth]): New authentication method\n\n        Warning:\n            Changing the authentication method will create a new session with the current url, \n            If you need to change both the url and the authentication method, create a new Planka instance\n\n        Example:\n            ```python\n            &gt;&gt;&gt; planka.auth = TokenAuth('&lt;new_token&gt;')\n            ```\n        \"\"\"\n        self._auth = auth\n        self._create_session(auth)\n\n    @property\n    def url(self) -&gt; str:\n        \"\"\"The current planka url\n\n        Returns:\n            Planka url\n        \"\"\"\n        return self._url\n\n    @url.setter\n    def url(self, url: str):\n        \"\"\"Changes the base url and creates a new session\n\n        Args:\n            url: New base url\n\n        Warning:\n            Changing the url will create a new session with the current authentication method, \n            If you need to change both the url and the authentication method, create a new Planka instance\n\n        Example:\n            ```python\n            &gt;&gt;&gt; planka.url = 'https://planka.example.com'\n            ```\n        \"\"\"\n        self._url = url\n        self._create_session(self.auth)\n\n    @property\n    def projects(self) -&gt; QueryableList[Project]:\n        \"\"\"Queryable List of all projects on the Planka instance\n\n        Returns:\n            Queryable List of all projects\n        \"\"\"\n        route = self.routes.get_project_index()\n        return QueryableList([\n            Project(**project).bind(self.routes)\n            for project in route()['items']\n        ])\n\n    @property\n    def users(self) -&gt; QueryableList[User]:\n        \"\"\"Queryable List of all users on the Planka instance\n\n        Returns:\n            Queryable List of all users\n        \"\"\"\n        route = self.routes.get_user_index()\n        return QueryableList([\n            User(**user).bind(self.routes)\n            for user in route()['items']\n        ])\n\n    @property\n    def notifications(self) -&gt; QueryableList[Notification]:\n        \"\"\"Queryable List of all notifications for the current user\n\n        Returns:\n            Queryable List of all notifications\n        \"\"\"\n        route = self.routes.get_notification_index()\n        return QueryableList([\n            Notification(**notification).bind(self.routes)\n            for notification in route()['items']\n        ])\n\n    @property\n    def project_background_images(self) -&gt; QueryableList[BackgroundImage]:\n        \"\"\"Get Project Background Images\n\n        Returns:\n            Queryable List of all project background images\n        \"\"\"\n        return QueryableList(\n            BackgroundImage(**project.backgroundImage)\n            for project in self.projects\n            if project.backgroundImage\n        )\n\n    @property\n    def user_avatars(self) -&gt; list[str]:\n        \"\"\"Get User Avatars\n\n        Returns:\n            Queryable List of all user avatar links\n        \"\"\"\n        return [\n            user.avatarUrl\n            for user in self.users\n            if user.avatarUrl\n        ]\n    @property\n    def me(self) -&gt; User:\n        \"\"\"Current Logged in User\n\n        Returns:\n            Current user\n        \"\"\"\n        route = self.routes.get_me()\n        return User(**route()['item']).bind(self.routes)\n\n    @property\n    def config(self) -&gt; JSONHandler.JSONResponse:\n        \"\"\"Planka Configuration\n\n        Returns:\n            Configuration data\n        \"\"\"\n        route = self.routes.get_config()\n        return route()['item']\n\n    @overload\n    def create_project(self, project: Project) -&gt; Project: ...\n\n    @overload\n    def create_project(self, name: str, position: int=None, \n                       background: Gradient=None) -&gt; Project: ...\n\n    def create_project(self, *args, **kwargs) -&gt; Project:\n        \"\"\"Creates a new project\n\n        Note:\n            If no background is provided, a random gradient will be assigned\n\n            If no position is provided, the project will be created at position 0\n\n        Args:\n            name (str): Name of the project (required)\n            position (int): Position of the project (default: 0)\n            background (Gradient): Background gradient of the project (default: None)\n\n        Args: Alternate\n            project (Project): Project instance to create\n\n        Returns:\n            Project: New project instance\n\n        Example:\n            ```python\n            &gt;&gt;&gt; new_project = planka.create_project('My Project')\n            &gt;&gt;&gt; new_project.set_background_gradient('blue-xchange') # Set background gradient\n            &gt;&gt;&gt; new_project.add_project_manager(planka.me) # Add current user as project manager\n            ```\n        \"\"\"\n        overload = parse_overload(args, kwargs, model='project', \n                                  options=('name', 'position', 'background'), \n                                  required=('name',))\n\n        overload['position'] = overload.get('position', 0)\n\n        style = overload.get('background', None)\n        route = self.routes.post_project()\n        project = Project(**route(**overload)['item']).bind(self.routes)\n\n        with project.editor(): # Project POST does not accept background, so we set it after creation\n            project.set_background_gradient(style or choice(Project.gradients))\n\n        return project\n\n\n    def create_user(self, username: str, email: str, password: str, name: str=None) -&gt; User:\n        \"\"\"Create a new user\n\n        Note:\n            Planka will reject insecure passwords! If creating a user with a specific password fails, \n            try a more secure password\n\n        Note:\n            If the username is not lowercase, it will be converted to lowercase\n\n        Args:\n            username (str): Username of the user (required)\n            email (str): Email address of the user (required)\n            password (str): Password for the user (required)\n            name (str): Full name of the user (default: `username`)\n\n        Raises:\n            ValueError: If the username or email already exists\n            ValueError: If password is insecure or a 400 code is returned\n        \"\"\"\n\n        username = username.strip()\n        if not username.islower():\n            print('Warning: Usernames are converted to lowercase')\n            username = username.lower()\n\n        for user in self.users:\n            if user.username == username:\n                raise ValueError(f'Username {username} already exists. '\n                                 'Please use a different username')\n            if user.email == email:\n                raise ValueError(f'Email {email} already exists. '\n                                 'Please use a different email address')\n\n        route = self.routes.post_user()\n        try:\n            return User(**route(username=username, name=name or username, password=password, email=email)['item']).bind(self.routes)\n        except HTTPError as e:\n            if e.code == 400: # Invalid password, email, or username\n                raise ValueError(\n                    f'Failed to create user {username}:\\n'\n                    '\\tTry: \\n'\n                    '\\t\\tA more secure password\\n'\n                    '\\t\\tValidating the user\\'s email address\\n'\n                    '\\t\\tChecking that the username has no whitespace') from e\n            else: # Unknown error\n                raise e\n</code></pre>"},{"location":"interfaces/Planka/#plankapy.interfaces.Planka.auth","title":"<code>auth</code>  <code>property</code> <code>writable</code>","text":"<p>Current authentication instance</p> <p>Returns:</p> Type Description <code>Type[BaseAuth]</code> <p>Authentication method</p>"},{"location":"interfaces/Planka/#plankapy.interfaces.Planka.config","title":"<code>config</code>  <code>property</code>","text":"<p>Planka Configuration</p> <p>Returns:</p> Type Description <code>JSONResponse</code> <p>Configuration data</p>"},{"location":"interfaces/Planka/#plankapy.interfaces.Planka.me","title":"<code>me</code>  <code>property</code>","text":"<p>Current Logged in User</p> <p>Returns:</p> Type Description <code>User</code> <p>Current user</p>"},{"location":"interfaces/Planka/#plankapy.interfaces.Planka.notifications","title":"<code>notifications</code>  <code>property</code>","text":"<p>Queryable List of all notifications for the current user</p> <p>Returns:</p> Type Description <code>QueryableList[Notification]</code> <p>Queryable List of all notifications</p>"},{"location":"interfaces/Planka/#plankapy.interfaces.Planka.project_background_images","title":"<code>project_background_images</code>  <code>property</code>","text":"<p>Get Project Background Images</p> <p>Returns:</p> Type Description <code>QueryableList[BackgroundImage]</code> <p>Queryable List of all project background images</p>"},{"location":"interfaces/Planka/#plankapy.interfaces.Planka.projects","title":"<code>projects</code>  <code>property</code>","text":"<p>Queryable List of all projects on the Planka instance</p> <p>Returns:</p> Type Description <code>QueryableList[Project]</code> <p>Queryable List of all projects</p>"},{"location":"interfaces/Planka/#plankapy.interfaces.Planka.url","title":"<code>url</code>  <code>property</code> <code>writable</code>","text":"<p>The current planka url</p> <p>Returns:</p> Type Description <code>str</code> <p>Planka url</p>"},{"location":"interfaces/Planka/#plankapy.interfaces.Planka.user_avatars","title":"<code>user_avatars</code>  <code>property</code>","text":"<p>Get User Avatars</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Queryable List of all user avatar links</p>"},{"location":"interfaces/Planka/#plankapy.interfaces.Planka.users","title":"<code>users</code>  <code>property</code>","text":"<p>Queryable List of all users on the Planka instance</p> <p>Returns:</p> Type Description <code>QueryableList[User]</code> <p>Queryable List of all users</p>"},{"location":"interfaces/Planka/#plankapy.interfaces.Planka.create_project","title":"<code>create_project(*args, **kwargs)</code>","text":"<pre><code>create_project(project: Project) -&gt; Project\n</code></pre><pre><code>create_project(name: str, position: int = None, background: Gradient = None) -&gt; Project\n</code></pre> <p>Creates a new project</p> Note <p>If no background is provided, a random gradient will be assigned</p> <p>If no position is provided, the project will be created at position 0</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the project (required)</p> required <code>position</code> <code>int</code> <p>Position of the project (default: 0)</p> required <code>background</code> <code>Gradient</code> <p>Background gradient of the project (default: None)</p> required <p>Alternate</p> Name Type Description Default <code>project</code> <code>Project</code> <p>Project instance to create</p> required <p>Returns:</p> Name Type Description <code>Project</code> <code>Project</code> <p>New project instance</p> Example <pre><code>&gt;&gt;&gt; new_project = planka.create_project('My Project')\n&gt;&gt;&gt; new_project.set_background_gradient('blue-xchange') # Set background gradient\n&gt;&gt;&gt; new_project.add_project_manager(planka.me) # Add current user as project manager\n</code></pre> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def create_project(self, *args, **kwargs) -&gt; Project:\n    \"\"\"Creates a new project\n\n    Note:\n        If no background is provided, a random gradient will be assigned\n\n        If no position is provided, the project will be created at position 0\n\n    Args:\n        name (str): Name of the project (required)\n        position (int): Position of the project (default: 0)\n        background (Gradient): Background gradient of the project (default: None)\n\n    Args: Alternate\n        project (Project): Project instance to create\n\n    Returns:\n        Project: New project instance\n\n    Example:\n        ```python\n        &gt;&gt;&gt; new_project = planka.create_project('My Project')\n        &gt;&gt;&gt; new_project.set_background_gradient('blue-xchange') # Set background gradient\n        &gt;&gt;&gt; new_project.add_project_manager(planka.me) # Add current user as project manager\n        ```\n    \"\"\"\n    overload = parse_overload(args, kwargs, model='project', \n                              options=('name', 'position', 'background'), \n                              required=('name',))\n\n    overload['position'] = overload.get('position', 0)\n\n    style = overload.get('background', None)\n    route = self.routes.post_project()\n    project = Project(**route(**overload)['item']).bind(self.routes)\n\n    with project.editor(): # Project POST does not accept background, so we set it after creation\n        project.set_background_gradient(style or choice(Project.gradients))\n\n    return project\n</code></pre>"},{"location":"interfaces/Planka/#plankapy.interfaces.Planka.create_user","title":"<code>create_user(username, email, password, name=None)</code>","text":"<p>Create a new user</p> Note <p>Planka will reject insecure passwords! If creating a user with a specific password fails,  try a more secure password</p> Note <p>If the username is not lowercase, it will be converted to lowercase</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>Username of the user (required)</p> required <code>email</code> <code>str</code> <p>Email address of the user (required)</p> required <code>password</code> <code>str</code> <p>Password for the user (required)</p> required <code>name</code> <code>str</code> <p>Full name of the user (default: <code>username</code>)</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the username or email already exists</p> <code>ValueError</code> <p>If password is insecure or a 400 code is returned</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def create_user(self, username: str, email: str, password: str, name: str=None) -&gt; User:\n    \"\"\"Create a new user\n\n    Note:\n        Planka will reject insecure passwords! If creating a user with a specific password fails, \n        try a more secure password\n\n    Note:\n        If the username is not lowercase, it will be converted to lowercase\n\n    Args:\n        username (str): Username of the user (required)\n        email (str): Email address of the user (required)\n        password (str): Password for the user (required)\n        name (str): Full name of the user (default: `username`)\n\n    Raises:\n        ValueError: If the username or email already exists\n        ValueError: If password is insecure or a 400 code is returned\n    \"\"\"\n\n    username = username.strip()\n    if not username.islower():\n        print('Warning: Usernames are converted to lowercase')\n        username = username.lower()\n\n    for user in self.users:\n        if user.username == username:\n            raise ValueError(f'Username {username} already exists. '\n                             'Please use a different username')\n        if user.email == email:\n            raise ValueError(f'Email {email} already exists. '\n                             'Please use a different email address')\n\n    route = self.routes.post_user()\n    try:\n        return User(**route(username=username, name=name or username, password=password, email=email)['item']).bind(self.routes)\n    except HTTPError as e:\n        if e.code == 400: # Invalid password, email, or username\n            raise ValueError(\n                f'Failed to create user {username}:\\n'\n                '\\tTry: \\n'\n                '\\t\\tA more secure password\\n'\n                '\\t\\tValidating the user\\'s email address\\n'\n                '\\t\\tChecking that the username has no whitespace') from e\n        else: # Unknown error\n            raise e\n</code></pre>"},{"location":"interfaces/Project/","title":"Project","text":"<p>               Bases: <code>Project_</code></p> <p>Interface for interacting with planka Projects and their included sub-objects</p> <p>Attributes:</p> Name Type Description <code>gradients</code> <code>list[Gradient]</code> <p>All available gradients</p> <code>gradient_to_css</code> <code>dict[Gradient, str]</code> <p>Mapping of gradient names to CSS values</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>class Project(Project_):\n    \"\"\"Interface for interacting with planka Projects and their included sub-objects\n\n    Attributes:\n        gradients (list[Gradient]): All available gradients\n        gradient_to_css (dict[Gradient, str]): Mapping of gradient names to CSS values\n    \"\"\"\n\n    gradients = Gradient.__args__\n    gradient_to_css = GradientCSSMap\n\n    @property\n    def _included(self) -&gt; JSONHandler.JSONResponse:\n        \"\"\"Included data for the project\n\n        Warning:\n            This property is meant to be used internally for building objects in the other properties\n            It can be directly accessed, but it will only return JSON data and not objects\n\n        Returns:\n            Included data for the project\n        \"\"\"\n        route = self.routes.get_project(id=self.id)\n        return route()['included']\n\n    @property\n    def users(self) -&gt; QueryableList[User]:\n        \"\"\"All users in the project\n\n        Returns:\n            Queryable List of all users\n        \"\"\"\n        return QueryableList([\n            User(**user).bind(self.routes)\n            for user in self._included['users']\n        ])\n\n    @property\n    def projectManagers(self) -&gt; QueryableList[ProjectManager]:\n        \"\"\"All project managers (ProjectManager Relations)\n\n        Note:\n            This property is not a list of users, but a list of `ProjectManager` objects\n            that define the user's role in the project. This is used to remove managers\n            in associated project boards and will likely never be used directly\n\n        Returns:\n            Queryable List of all project manager relations\n        \"\"\"\n        return QueryableList([\n            ProjectManager(**projectManager).bind(self.routes)\n            for projectManager in self._included['projectManagers']\n        ])\n\n    @property\n    def managers(self) -&gt; QueryableList[User]:\n        \"\"\"All project managers (Users)\n\n        Returns:\n            Queryable List of all project managers\n        \"\"\"\n        return QueryableList([\n            user\n            for user in self.users\n            for projectManager in self.projectManagers\n            if projectManager.userId == user.id\n        ])\n\n\n    @property\n    def boardMemberships(self) -&gt; QueryableList[BoardMembership]:\n        \"\"\"All board memberships and roles in the project\n\n        Note:\n            This property is not a list of users, but a list of `BoardMembership` objects\n            that define the user's role in the project boards. This is used to remove memberships\n            in associated project boards and will likely never be used directly\n\n        Returns:\n            Queryable List of all board membership relations in the project    \n        \"\"\"\n        return QueryableList([\n            BoardMembership(**boardMembership).bind(self.routes)\n            for boardMembership in self._included['boardMemberships']\n        ])\n\n    @property\n    def boards(self) -&gt; QueryableList[Board]:\n        \"\"\"All boards in the project\n\n        Returns:\n            Queryable List of all boards\n        \"\"\"\n        return QueryableList([\n            Board(**board).bind(self.routes)\n            for board in self._included['boards']\n        ])\n\n    def download_background_image(self, path: Path) -&gt; Path | None:\n        \"\"\"Download a background image from the project\n\n        Args:\n            path (Path): Path to save the image file\n\n        Returns:\n            Path: Path to the downloaded image file or None if no background image is set\n\n        Example:\n            ```python\n            &gt;&gt;&gt; project.download_background_image('/home/user/downloads/background.jpg')\n            ```\n        \"\"\"\n        if not self.backgroundImage:\n            return None\n\n        path = Path(path)\n        path.write_bytes(self.routes.handler._get_file(self.backgroundImage['url']))\n        return path\n\n\n    def gradient_css(self) -&gt; str | None:\n        \"\"\"Get the CSS value for the project gradient\n\n        Note:\n            If the project has no gradient set, this will return `None`\n\n        Returns:\n            CSS value for the gradient\n        \"\"\"\n        gradient = self.background\n        if gradient.type != 'gradient':\n            return None\n        return self.gradient_to_css[gradient.name]\n\n    @overload\n    def create_board(self, board: Board) -&gt; Board: ...\n\n    @overload\n    def create_board(self, name: str, position: int=0) -&gt; Board: ...\n\n    def create_board(self, *args, **kwargs) -&gt; Board:\n        \"\"\"Creates a new board in the project from a name and position or a Board instance\n\n        Args:\n            name (str): Name of the board\n            position (int): Position of the board (default: 0)\n\n        Args: Alternate\n            board (Board): Board instance to create\n\n        Returns:\n            Board: New board instance\n        \"\"\"\n        overload = parse_overload(\n            args, kwargs, \n            model='board', \n            options=('name', 'position'), \n            required=('name',))\n\n        overload['position'] = overload.get('position', 0)\n        overload['projectId'] = self.id\n\n        route = self.routes.post_board(projectId=self.id)\n        return Board(**route(**overload)['item']).bind(self.routes)\n\n    @overload\n    def add_project_manager(self, user: User) -&gt; ProjectManager: ...\n\n    @overload\n    def add_project_manager(self, userId: int) -&gt; ProjectManager: ...\n\n    def add_project_manager(self, *args, **kwargs) -&gt; ProjectManager:\n        \"\"\"Creates a new project manager in the project\n\n        Note:\n            This method has overloaded arguments,\n            You can pass a `User` instance or provide a required `userId` argument\n\n        Args:\n            userId (int): id of the user to make project manager (required)\n\n        Args: Alternate    \n            user (User): User instance to create (required)\n\n        Returns:\n            ProjectManager: New project manager instance\n\n        Example:\n            ```python\n            &gt;&gt;&gt; new_manager = project.create_project_manager(planka.me)\n            &gt;&gt;&gt; other_manager = project.create_project_manager(userId='...1234')\n            ```\n\n        \"\"\"\n        overload = parse_overload(\n            args, kwargs, \n            model='user', \n            options=('userId',), \n            required=('userId',))\n\n        userId = overload.get('userId', None)\n\n        if not userId: # Get id from passed User\n            userId = overload.get('id')\n\n        # Don't assign a manager twice (raises HTTP 409 - Conflict)\n        if userId in [manager.id for manager in self.managers]:\n            return\n\n        route = self.routes.post_project_manager(projectId=self.id)\n        return ProjectManager(**route(userId=userId, projectId=self.id)['item']).bind(self.routes)\n\n    @overload\n    def remove_project_manager(project_manager: User) -&gt; ProjectManager | None: ...\n\n    @overload\n    def remove_project_manager(userId: int) -&gt; ProjectManager | None: ...\n\n    def remove_project_manager(self, *args, **kwargs) -&gt; ProjectManager | None:\n        overload = parse_overload(args, kwargs,\n                                  model='user',\n                                  options=('userId',),\n                                  required=('userId',)\n        )\n\n        if 'userId' not in overload: # Case for User object\n            overload['userId'] = overload['id']\n\n        for manager in self.projectManagers:\n            if manager.userId == overload['userId']:\n                return manager.delete()\n\n    def delete(self) -&gt; Project:\n        \"\"\"Deletes the project\n\n        Danger:\n            This action is irreversible and cannot be undone\n\n        Returns:\n            Project: Deleted project instance\n        \"\"\"\n        self.refresh()\n        route = self.routes.delete_project(id=self.id)\n        route()\n        return self\n\n    @overload\n    def update(self, project: Project) -&gt; Project: ...\n\n    @overload\n    def update(self, name: str=None) -&gt; Project: ...\n\n    def update(self, *args, **kwargs) -&gt; Project:\n        \"\"\"Updates the project with new values\n\n        Note:\n            To set background image, use the `set_background_image` method\n            To set a background gradient, use the `set_background_gradient` method\n\n        Args:\n            name (str): Name of the project (required)\n\n        Args: Alternate\n            project (Project): Project instance to update (required)\n\n        Returns:\n            Project: Updated project instance\n\n        Example:\n            ```python\n            &gt;&gt;&gt; project.update(name='My New Project', background='blue-xchange'))\n            ```\n        \"\"\"\n        overload = parse_overload(\n            args, kwargs, model='project', \n            options=('name',),\n            noarg=self)\n\n        # Keep it backwards compatible\n        # Allow setting gradient directly by name\n        if 'background' in overload and isinstance(overload['background'], str):\n            bg = overload.pop('background') # Remove background from overload\n            if bg in self.gradients:\n                self.set_background_gradient(bg) # Set the gradient if it's valid\n\n        route = self.routes.patch_project(id=self.id)\n        self.__init__(**route(**overload)['item'])\n        return self\n\n    def set_background_gradient(self, gradient: Gradient) -&gt; Project:\n        \"\"\"Set a background gradient for the project\n\n        Args:\n            gradient (Gradient): Background gradient to set\n\n        Returns:\n            Project: Updated project instance\n\n        Raises:\n            ValueError: If the gradient name is not in the available gradients\n\n        Example:\n            ```python\n            &gt;&gt;&gt; project.set_background_gradient('blue-xchange')\n            ```\n        \"\"\"\n        if gradient not in self.gradients:\n            raise ValueError(\n                f'Invalid gradient: {gradient}'\n                f'Available gradients: {self.gradients}')\n\n        with self.editor():\n            self.backgroundImage = None            \n            self.background = {'name': gradient, 'type': 'gradient'}\n\n        return self\n\n    def set_background_image(self, image: Path) -&gt; BackgroundImage:\n        \"\"\"Add a background image to the project\n\n        Args:\n            image (Path): Path to the image file\n\n        Returns:\n            BackgroundImage: New background image\n        \"\"\"\n        route = self.routes.post_project_background_image(id=self.id)\n        return BackgroundImage(**route(_file=image)['item']['backgroundImage'])\n\n    def remove_background_image(self) -&gt; None:\n        \"\"\"Remove the background image from the project\"\"\"\n        with self.editor():\n            if self.backgroundImage:\n                self.backgroundImage = None\n                self.background = {'name': f'{choice(self.gradients)}', 'type': 'gradient'}\n\n    def refresh(self) -&gt; None:\n        \"\"\"Refreshes the project data\n\n        Note:\n            All objects accessed by properties are always up to date, but the root object that contains those\n            properties keeps a cache of its own data. This method refreshes the root object data.\n\n            FUTURE: This method might be removed or disabled in the future if I can get a __getattr__ implementation\n            to work without causing infinite recursion updating the root object when properties are accessed\n\n        \"\"\"\n        route = self.routes.get_project(id=self.id)\n        self.__init__(**route()['item'])\n</code></pre>"},{"location":"interfaces/Project/#plankapy.interfaces.Project.boardMemberships","title":"<code>boardMemberships</code>  <code>property</code>","text":"<p>All board memberships and roles in the project</p> Note <p>This property is not a list of users, but a list of <code>BoardMembership</code> objects that define the user's role in the project boards. This is used to remove memberships in associated project boards and will likely never be used directly</p> <p>Returns:</p> Type Description <code>QueryableList[BoardMembership]</code> <p>Queryable List of all board membership relations in the project</p>"},{"location":"interfaces/Project/#plankapy.interfaces.Project.boards","title":"<code>boards</code>  <code>property</code>","text":"<p>All boards in the project</p> <p>Returns:</p> Type Description <code>QueryableList[Board]</code> <p>Queryable List of all boards</p>"},{"location":"interfaces/Project/#plankapy.interfaces.Project.managers","title":"<code>managers</code>  <code>property</code>","text":"<p>All project managers (Users)</p> <p>Returns:</p> Type Description <code>QueryableList[User]</code> <p>Queryable List of all project managers</p>"},{"location":"interfaces/Project/#plankapy.interfaces.Project.projectManagers","title":"<code>projectManagers</code>  <code>property</code>","text":"<p>All project managers (ProjectManager Relations)</p> Note <p>This property is not a list of users, but a list of <code>ProjectManager</code> objects that define the user's role in the project. This is used to remove managers in associated project boards and will likely never be used directly</p> <p>Returns:</p> Type Description <code>QueryableList[ProjectManager]</code> <p>Queryable List of all project manager relations</p>"},{"location":"interfaces/Project/#plankapy.interfaces.Project.users","title":"<code>users</code>  <code>property</code>","text":"<p>All users in the project</p> <p>Returns:</p> Type Description <code>QueryableList[User]</code> <p>Queryable List of all users</p>"},{"location":"interfaces/Project/#plankapy.interfaces.Project.add_project_manager","title":"<code>add_project_manager(*args, **kwargs)</code>","text":"<pre><code>add_project_manager(user: User) -&gt; ProjectManager\n</code></pre><pre><code>add_project_manager(userId: int) -&gt; ProjectManager\n</code></pre> <p>Creates a new project manager in the project</p> Note <p>This method has overloaded arguments, You can pass a <code>User</code> instance or provide a required <code>userId</code> argument</p> <p>Parameters:</p> Name Type Description Default <code>userId</code> <code>int</code> <p>id of the user to make project manager (required)</p> required <p>Alternate    </p> Name Type Description Default <code>user</code> <code>User</code> <p>User instance to create (required)</p> required <p>Returns:</p> Name Type Description <code>ProjectManager</code> <code>ProjectManager</code> <p>New project manager instance</p> Example <pre><code>&gt;&gt;&gt; new_manager = project.create_project_manager(planka.me)\n&gt;&gt;&gt; other_manager = project.create_project_manager(userId='...1234')\n</code></pre> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def add_project_manager(self, *args, **kwargs) -&gt; ProjectManager:\n    \"\"\"Creates a new project manager in the project\n\n    Note:\n        This method has overloaded arguments,\n        You can pass a `User` instance or provide a required `userId` argument\n\n    Args:\n        userId (int): id of the user to make project manager (required)\n\n    Args: Alternate    \n        user (User): User instance to create (required)\n\n    Returns:\n        ProjectManager: New project manager instance\n\n    Example:\n        ```python\n        &gt;&gt;&gt; new_manager = project.create_project_manager(planka.me)\n        &gt;&gt;&gt; other_manager = project.create_project_manager(userId='...1234')\n        ```\n\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='user', \n        options=('userId',), \n        required=('userId',))\n\n    userId = overload.get('userId', None)\n\n    if not userId: # Get id from passed User\n        userId = overload.get('id')\n\n    # Don't assign a manager twice (raises HTTP 409 - Conflict)\n    if userId in [manager.id for manager in self.managers]:\n        return\n\n    route = self.routes.post_project_manager(projectId=self.id)\n    return ProjectManager(**route(userId=userId, projectId=self.id)['item']).bind(self.routes)\n</code></pre>"},{"location":"interfaces/Project/#plankapy.interfaces.Project.create_board","title":"<code>create_board(*args, **kwargs)</code>","text":"<pre><code>create_board(board: Board) -&gt; Board\n</code></pre><pre><code>create_board(name: str, position: int = 0) -&gt; Board\n</code></pre> <p>Creates a new board in the project from a name and position or a Board instance</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the board</p> required <code>position</code> <code>int</code> <p>Position of the board (default: 0)</p> required <p>Alternate</p> Name Type Description Default <code>board</code> <code>Board</code> <p>Board instance to create</p> required <p>Returns:</p> Name Type Description <code>Board</code> <code>Board</code> <p>New board instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def create_board(self, *args, **kwargs) -&gt; Board:\n    \"\"\"Creates a new board in the project from a name and position or a Board instance\n\n    Args:\n        name (str): Name of the board\n        position (int): Position of the board (default: 0)\n\n    Args: Alternate\n        board (Board): Board instance to create\n\n    Returns:\n        Board: New board instance\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='board', \n        options=('name', 'position'), \n        required=('name',))\n\n    overload['position'] = overload.get('position', 0)\n    overload['projectId'] = self.id\n\n    route = self.routes.post_board(projectId=self.id)\n    return Board(**route(**overload)['item']).bind(self.routes)\n</code></pre>"},{"location":"interfaces/Project/#plankapy.interfaces.Project.delete","title":"<code>delete()</code>","text":"<p>Deletes the project</p> Danger <p>This action is irreversible and cannot be undone</p> <p>Returns:</p> Name Type Description <code>Project</code> <code>Project</code> <p>Deleted project instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def delete(self) -&gt; Project:\n    \"\"\"Deletes the project\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        Project: Deleted project instance\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_project(id=self.id)\n    route()\n    return self\n</code></pre>"},{"location":"interfaces/Project/#plankapy.interfaces.Project.download_background_image","title":"<code>download_background_image(path)</code>","text":"<p>Download a background image from the project</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to save the image file</p> required <p>Returns:</p> Name Type Description <code>Path</code> <code>Path | None</code> <p>Path to the downloaded image file or None if no background image is set</p> Example <pre><code>&gt;&gt;&gt; project.download_background_image('/home/user/downloads/background.jpg')\n</code></pre> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def download_background_image(self, path: Path) -&gt; Path | None:\n    \"\"\"Download a background image from the project\n\n    Args:\n        path (Path): Path to save the image file\n\n    Returns:\n        Path: Path to the downloaded image file or None if no background image is set\n\n    Example:\n        ```python\n        &gt;&gt;&gt; project.download_background_image('/home/user/downloads/background.jpg')\n        ```\n    \"\"\"\n    if not self.backgroundImage:\n        return None\n\n    path = Path(path)\n    path.write_bytes(self.routes.handler._get_file(self.backgroundImage['url']))\n    return path\n</code></pre>"},{"location":"interfaces/Project/#plankapy.interfaces.Project.gradient_css","title":"<code>gradient_css()</code>","text":"<p>Get the CSS value for the project gradient</p> Note <p>If the project has no gradient set, this will return <code>None</code></p> <p>Returns:</p> Type Description <code>str | None</code> <p>CSS value for the gradient</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def gradient_css(self) -&gt; str | None:\n    \"\"\"Get the CSS value for the project gradient\n\n    Note:\n        If the project has no gradient set, this will return `None`\n\n    Returns:\n        CSS value for the gradient\n    \"\"\"\n    gradient = self.background\n    if gradient.type != 'gradient':\n        return None\n    return self.gradient_to_css[gradient.name]\n</code></pre>"},{"location":"interfaces/Project/#plankapy.interfaces.Project.refresh","title":"<code>refresh()</code>","text":"<p>Refreshes the project data</p> Note <p>All objects accessed by properties are always up to date, but the root object that contains those properties keeps a cache of its own data. This method refreshes the root object data.</p> <p>FUTURE: This method might be removed or disabled in the future if I can get a getattr implementation to work without causing infinite recursion updating the root object when properties are accessed</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshes the project data\n\n    Note:\n        All objects accessed by properties are always up to date, but the root object that contains those\n        properties keeps a cache of its own data. This method refreshes the root object data.\n\n        FUTURE: This method might be removed or disabled in the future if I can get a __getattr__ implementation\n        to work without causing infinite recursion updating the root object when properties are accessed\n\n    \"\"\"\n    route = self.routes.get_project(id=self.id)\n    self.__init__(**route()['item'])\n</code></pre>"},{"location":"interfaces/Project/#plankapy.interfaces.Project.remove_background_image","title":"<code>remove_background_image()</code>","text":"<p>Remove the background image from the project</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def remove_background_image(self) -&gt; None:\n    \"\"\"Remove the background image from the project\"\"\"\n    with self.editor():\n        if self.backgroundImage:\n            self.backgroundImage = None\n            self.background = {'name': f'{choice(self.gradients)}', 'type': 'gradient'}\n</code></pre>"},{"location":"interfaces/Project/#plankapy.interfaces.Project.set_background_gradient","title":"<code>set_background_gradient(gradient)</code>","text":"<p>Set a background gradient for the project</p> <p>Parameters:</p> Name Type Description Default <code>gradient</code> <code>Gradient</code> <p>Background gradient to set</p> required <p>Returns:</p> Name Type Description <code>Project</code> <code>Project</code> <p>Updated project instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the gradient name is not in the available gradients</p> Example <pre><code>&gt;&gt;&gt; project.set_background_gradient('blue-xchange')\n</code></pre> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def set_background_gradient(self, gradient: Gradient) -&gt; Project:\n    \"\"\"Set a background gradient for the project\n\n    Args:\n        gradient (Gradient): Background gradient to set\n\n    Returns:\n        Project: Updated project instance\n\n    Raises:\n        ValueError: If the gradient name is not in the available gradients\n\n    Example:\n        ```python\n        &gt;&gt;&gt; project.set_background_gradient('blue-xchange')\n        ```\n    \"\"\"\n    if gradient not in self.gradients:\n        raise ValueError(\n            f'Invalid gradient: {gradient}'\n            f'Available gradients: {self.gradients}')\n\n    with self.editor():\n        self.backgroundImage = None            \n        self.background = {'name': gradient, 'type': 'gradient'}\n\n    return self\n</code></pre>"},{"location":"interfaces/Project/#plankapy.interfaces.Project.set_background_image","title":"<code>set_background_image(image)</code>","text":"<p>Add a background image to the project</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Path</code> <p>Path to the image file</p> required <p>Returns:</p> Name Type Description <code>BackgroundImage</code> <code>BackgroundImage</code> <p>New background image</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def set_background_image(self, image: Path) -&gt; BackgroundImage:\n    \"\"\"Add a background image to the project\n\n    Args:\n        image (Path): Path to the image file\n\n    Returns:\n        BackgroundImage: New background image\n    \"\"\"\n    route = self.routes.post_project_background_image(id=self.id)\n    return BackgroundImage(**route(_file=image)['item']['backgroundImage'])\n</code></pre>"},{"location":"interfaces/Project/#plankapy.interfaces.Project.update","title":"<code>update(*args, **kwargs)</code>","text":"<pre><code>update(project: Project) -&gt; Project\n</code></pre><pre><code>update(name: str = None) -&gt; Project\n</code></pre> <p>Updates the project with new values</p> Note <p>To set background image, use the <code>set_background_image</code> method To set a background gradient, use the <code>set_background_gradient</code> method</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the project (required)</p> required <p>Alternate</p> Name Type Description Default <code>project</code> <code>Project</code> <p>Project instance to update (required)</p> required <p>Returns:</p> Name Type Description <code>Project</code> <code>Project</code> <p>Updated project instance</p> Example <pre><code>&gt;&gt;&gt; project.update(name='My New Project', background='blue-xchange'))\n</code></pre> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def update(self, *args, **kwargs) -&gt; Project:\n    \"\"\"Updates the project with new values\n\n    Note:\n        To set background image, use the `set_background_image` method\n        To set a background gradient, use the `set_background_gradient` method\n\n    Args:\n        name (str): Name of the project (required)\n\n    Args: Alternate\n        project (Project): Project instance to update (required)\n\n    Returns:\n        Project: Updated project instance\n\n    Example:\n        ```python\n        &gt;&gt;&gt; project.update(name='My New Project', background='blue-xchange'))\n        ```\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, model='project', \n        options=('name',),\n        noarg=self)\n\n    # Keep it backwards compatible\n    # Allow setting gradient directly by name\n    if 'background' in overload and isinstance(overload['background'], str):\n        bg = overload.pop('background') # Remove background from overload\n        if bg in self.gradients:\n            self.set_background_gradient(bg) # Set the gradient if it's valid\n\n    route = self.routes.patch_project(id=self.id)\n    self.__init__(**route(**overload)['item'])\n    return self\n</code></pre>"},{"location":"interfaces/ProjectManager/","title":"ProjectManager","text":"<p>               Bases: <code>ProjectManager_</code></p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>class ProjectManager(ProjectManager_):\n\n    @property\n    def user(self) -&gt; User:\n        \"\"\"User that is a manager of the project\n\n        Returns:\n            User: User instance\n        \"\"\"\n        user_route = self.routes.get_user(id=self.userId)\n        return User(**user_route()['item']).bind(self.routes)\n\n    @property\n    def project(self) -&gt; Project:\n        \"\"\"Project the user is a manager of\n\n        Returns:\n            Project: Project instance\n        \"\"\"\n        project_route = self.routes.get_project(id=self.projectId)\n        return Project(**project_route()['item']).bind(self.routes)\n\n    def delete(self) -&gt; tuple[User, Project]:\n        \"\"\"Deletes the project manager relationship\n\n        Danger:\n            This action is irreversible and cannot be undone\n\n        Returns:\n            tuple[User, Project]: The user and project that the user was manager of\n        \"\"\"\n        self.refresh()\n        route = self.routes.delete_project_manager(id=self.id)\n        route()\n        return (self.user, self.project)\n\n    def refresh(self) -&gt; None:\n        \"\"\"Refreshes the project manager data\"\"\"\n        for manager in self.project.managers:\n            if manager.id == self.id:\n                self.__init__(**manager)\n</code></pre>"},{"location":"interfaces/ProjectManager/#plankapy.interfaces.ProjectManager.project","title":"<code>project</code>  <code>property</code>","text":"<p>Project the user is a manager of</p> <p>Returns:</p> Name Type Description <code>Project</code> <code>Project</code> <p>Project instance</p>"},{"location":"interfaces/ProjectManager/#plankapy.interfaces.ProjectManager.user","title":"<code>user</code>  <code>property</code>","text":"<p>User that is a manager of the project</p> <p>Returns:</p> Name Type Description <code>User</code> <code>User</code> <p>User instance</p>"},{"location":"interfaces/ProjectManager/#plankapy.interfaces.ProjectManager.delete","title":"<code>delete()</code>","text":"<p>Deletes the project manager relationship</p> Danger <p>This action is irreversible and cannot be undone</p> <p>Returns:</p> Type Description <code>tuple[User, Project]</code> <p>tuple[User, Project]: The user and project that the user was manager of</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def delete(self) -&gt; tuple[User, Project]:\n    \"\"\"Deletes the project manager relationship\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        tuple[User, Project]: The user and project that the user was manager of\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_project_manager(id=self.id)\n    route()\n    return (self.user, self.project)\n</code></pre>"},{"location":"interfaces/ProjectManager/#plankapy.interfaces.ProjectManager.refresh","title":"<code>refresh()</code>","text":"<p>Refreshes the project manager data</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshes the project manager data\"\"\"\n    for manager in self.project.managers:\n        if manager.id == self.id:\n            self.__init__(**manager)\n</code></pre>"},{"location":"interfaces/Stopwatch/","title":"Stopwatch","text":"<p>               Bases: <code>Model</code></p> <p>Stopwatch Model</p> Note <p>The stopwatch model is not a regular interface and instead is dynamically generated on Access through the <code>Card</code> <code>.stopwatch</code> attribute. There is an override that intercepts <code>__getitem__</code> to return a <code>Stopwatch</code>. </p> <p>All <code>Stopwatch</code> methods directly update the <code>.stopwatch</code> attribute of the linked <code>Card</code>  instance.</p> <p>Attributes:</p> Name Type Description <code>startedAt</code> <code>datetime</code> <p>The start date of the stopwatch</p> <code>total</code> <code>int</code> <p>The total time of the stopwatch (in seconds)</p> <code>_card</code> <code>Card</code> <p>The card the stopwatch is associated with (Managed by the <code>Card</code> class)</p> Source code in <code>src/plankapy/models.py</code> <pre><code>@dataclass(eq=False)\nclass Stopwatch(Model):\n    \"\"\"Stopwatch Model\n\n    Note:\n        The stopwatch model is not a regular interface and instead is dynamically generated on\n        Access through the `Card` `.stopwatch` attribute. There is an override that intercepts\n        `__getitem__` to return a `Stopwatch`. \n\n        All `Stopwatch` methods directly update the `.stopwatch` attribute of the linked `Card` \n        instance.\n\n    Attributes:\n        startedAt (datetime): The start date of the stopwatch\n        total (int): The total time of the stopwatch (in seconds)\n        _card (Card): The card the stopwatch is associated with (Managed by the `Card` class)\n    \"\"\"\n    _card: Optional[Card_]=Unset\n    startedAt: Optional[str]=Unset\n    total: Optional[int]=Unset\n\n    def refresh(self):\n        self._card.refresh()\n        self.startedAt = self._card.stopwatch.startedAt\n        self.total = self._card.stopwatch.total\n\n    def start_time(self) -&gt; datetime:\n        \"\"\"Returns the datetime the stopwatch was started\"\"\"\n        self.refresh()\n        return datetime.fromisoformat(self.startedAt) if self.startedAt else None\n\n    def start(self) -&gt; None:\n        \"\"\"Starts the stopwatch\"\"\"\n        self.refresh()\n        if self.startedAt:\n            return\n        self.startedAt = datetime.now().isoformat()\n        with self._card.editor():\n            self._card.stopwatch = self\n\n    def stop(self) -&gt; None:\n        \"\"\"Stops the stopwatch\"\"\"\n        self.refresh()\n        if not self.startedAt:\n            return\n\n        now = datetime.now()\n        started = datetime.fromisoformat(self.startedAt)\n        self.total += int(now.timestamp() - started.timestamp())\n        self.startedAt = None\n        with self._card.editor():\n            self._card.stopwatch = self\n\n    def set(self, hours: int=0, minutes: int=0, seconds: int=0) -&gt; None:\n        \"\"\"Set an amount of time for the stopwatch\n\n        Args:\n            hours (int): Hours to set\n            minutes (int): Minutes to set\n            seconds (int): Seconds to set\n        \"\"\"\n        self.total = (hours * 3600) + (minutes * 60) + seconds\n        with self._card.editor():\n            self._card.stopwatch = self\n</code></pre>"},{"location":"interfaces/Stopwatch/#plankapy.models.Stopwatch.set","title":"<code>set(hours=0, minutes=0, seconds=0)</code>","text":"<p>Set an amount of time for the stopwatch</p> <p>Parameters:</p> Name Type Description Default <code>hours</code> <code>int</code> <p>Hours to set</p> <code>0</code> <code>minutes</code> <code>int</code> <p>Minutes to set</p> <code>0</code> <code>seconds</code> <code>int</code> <p>Seconds to set</p> <code>0</code> Source code in <code>src/plankapy/models.py</code> <pre><code>def set(self, hours: int=0, minutes: int=0, seconds: int=0) -&gt; None:\n    \"\"\"Set an amount of time for the stopwatch\n\n    Args:\n        hours (int): Hours to set\n        minutes (int): Minutes to set\n        seconds (int): Seconds to set\n    \"\"\"\n    self.total = (hours * 3600) + (minutes * 60) + seconds\n    with self._card.editor():\n        self._card.stopwatch = self\n</code></pre>"},{"location":"interfaces/Stopwatch/#plankapy.models.Stopwatch.start","title":"<code>start()</code>","text":"<p>Starts the stopwatch</p> Source code in <code>src/plankapy/models.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Starts the stopwatch\"\"\"\n    self.refresh()\n    if self.startedAt:\n        return\n    self.startedAt = datetime.now().isoformat()\n    with self._card.editor():\n        self._card.stopwatch = self\n</code></pre>"},{"location":"interfaces/Stopwatch/#plankapy.models.Stopwatch.start_time","title":"<code>start_time()</code>","text":"<p>Returns the datetime the stopwatch was started</p> Source code in <code>src/plankapy/models.py</code> <pre><code>def start_time(self) -&gt; datetime:\n    \"\"\"Returns the datetime the stopwatch was started\"\"\"\n    self.refresh()\n    return datetime.fromisoformat(self.startedAt) if self.startedAt else None\n</code></pre>"},{"location":"interfaces/Stopwatch/#plankapy.models.Stopwatch.stop","title":"<code>stop()</code>","text":"<p>Stops the stopwatch</p> Source code in <code>src/plankapy/models.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stops the stopwatch\"\"\"\n    self.refresh()\n    if not self.startedAt:\n        return\n\n    now = datetime.now()\n    started = datetime.fromisoformat(self.startedAt)\n    self.total += int(now.timestamp() - started.timestamp())\n    self.startedAt = None\n    with self._card.editor():\n        self._card.stopwatch = self\n</code></pre>"},{"location":"interfaces/Task/","title":"Task","text":"<p>               Bases: <code>Task_</code></p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>class Task(Task_):\n\n    @property\n    def card(self) -&gt; Card:\n        card_route = self.routes.get_card(id=self.cardId)\n        return Card(**card_route()['item']).bind(self.routes)\n\n    @overload\n    def update(self): ...\n\n    @overload\n    def update(self, task: Task): ...\n\n    @overload\n    def update(self, name: str=None, isCompleted: bool=None) -&gt; Task: ...\n\n    def update(self, *args, **kwargs) -&gt; Task:\n        \"\"\"Updates the task with new values\n\n        Tip:\n            If you want to update a task, it's better to use the `editor()` context manager\n\n            Example:\n            ```python\n            &gt;&gt;&gt; with task.editor():\n            ...    task.name = 'New Task Name'\n            ...    task.isCompleted = True\n\n            &gt;&gt;&gt; task\n            Task(id=1, name='New Task Name', isCompleted=True, ...)\n            ```\n\n        Args:\n            name (str): Name of the task (optional)\n            isCompleted (bool): Whether the task is completed (optional)\n\n        Args: Alternate\n            task (Task): Task instance to update (required)\n\n        Note:\n            If no arguments are provided, the task will update itself with the current values stored in its attributes\n\n        Returns:\n            Task: Updated task instance\n        \"\"\"\n        overload = parse_overload(\n            args, kwargs, \n            model='task', \n            options=('name', 'isCompleted'),\n            noarg=self)\n\n        route = self.routes.patch_task(id=self.id)\n        self.__init__(**route(**overload)['item'])\n        return self\n\n    def delete(self) -&gt; Task:\n        \"\"\"Deletes the task\n\n        Danger:\n            This action is irreversible and cannot be undone\n\n        Returns:\n            Task: Deleted task instance\n        \"\"\"\n        self.refresh()\n        route = self.routes.delete_task(id=self.id)\n        route()\n        return self\n\n    def refresh(self) -&gt; None:\n        \"\"\"Refreshes the task data\"\"\"\n        tasks = self.card.board.tasks\n        for task in tasks:\n            if task.id == self.id:\n                self.__init__(**task)\n</code></pre>"},{"location":"interfaces/Task/#plankapy.interfaces.Task.delete","title":"<code>delete()</code>","text":"<p>Deletes the task</p> Danger <p>This action is irreversible and cannot be undone</p> <p>Returns:</p> Name Type Description <code>Task</code> <code>Task</code> <p>Deleted task instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def delete(self) -&gt; Task:\n    \"\"\"Deletes the task\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        Task: Deleted task instance\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_task(id=self.id)\n    route()\n    return self\n</code></pre>"},{"location":"interfaces/Task/#plankapy.interfaces.Task.refresh","title":"<code>refresh()</code>","text":"<p>Refreshes the task data</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshes the task data\"\"\"\n    tasks = self.card.board.tasks\n    for task in tasks:\n        if task.id == self.id:\n            self.__init__(**task)\n</code></pre>"},{"location":"interfaces/Task/#plankapy.interfaces.Task.update","title":"<code>update(*args, **kwargs)</code>","text":"<pre><code>update()\n</code></pre><pre><code>update(task: Task)\n</code></pre><pre><code>update(name: str = None, isCompleted: bool = None) -&gt; Task\n</code></pre> <p>Updates the task with new values</p> Tip <p>If you want to update a task, it's better to use the <code>editor()</code> context manager</p> <p>Example: <pre><code>&gt;&gt;&gt; with task.editor():\n...    task.name = 'New Task Name'\n...    task.isCompleted = True\n\n&gt;&gt;&gt; task\nTask(id=1, name='New Task Name', isCompleted=True, ...)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the task (optional)</p> required <code>isCompleted</code> <code>bool</code> <p>Whether the task is completed (optional)</p> required <p>Alternate</p> Name Type Description Default <code>task</code> <code>Task</code> <p>Task instance to update (required)</p> required Note <p>If no arguments are provided, the task will update itself with the current values stored in its attributes</p> <p>Returns:</p> Name Type Description <code>Task</code> <code>Task</code> <p>Updated task instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def update(self, *args, **kwargs) -&gt; Task:\n    \"\"\"Updates the task with new values\n\n    Tip:\n        If you want to update a task, it's better to use the `editor()` context manager\n\n        Example:\n        ```python\n        &gt;&gt;&gt; with task.editor():\n        ...    task.name = 'New Task Name'\n        ...    task.isCompleted = True\n\n        &gt;&gt;&gt; task\n        Task(id=1, name='New Task Name', isCompleted=True, ...)\n        ```\n\n    Args:\n        name (str): Name of the task (optional)\n        isCompleted (bool): Whether the task is completed (optional)\n\n    Args: Alternate\n        task (Task): Task instance to update (required)\n\n    Note:\n        If no arguments are provided, the task will update itself with the current values stored in its attributes\n\n    Returns:\n        Task: Updated task instance\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='task', \n        options=('name', 'isCompleted'),\n        noarg=self)\n\n    route = self.routes.patch_task(id=self.id)\n    self.__init__(**route(**overload)['item'])\n    return self\n</code></pre>"},{"location":"interfaces/User/","title":"User","text":"<p>               Bases: <code>User_</code></p> <p>Interface for interacting with planka Users and their included sub-objects</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>class User(User_):\n    \"\"\"Interface for interacting with planka Users and their included sub-objects\n\n    \"\"\"\n    @property\n    def projects(self) -&gt; QueryableList[Project]:\n        \"\"\"All projects the user is a member of\n\n        Returns:\n            Queryable List of all projects the user is a member of\n        \"\"\"\n        projects_route = self.routes.get_project_index()\n        return QueryableList([\n            Project(**project).bind(self.routes)\n            for project in projects_route()['items']\n        ]).select_where(lambda project: self in project.users)\n\n    @property\n    def boards(self) -&gt; QueryableList[Board]:\n        \"\"\"All boards the user is a member of\n\n        Returns:\n            Queryable List of all boards the user is a member of\n        \"\"\"\n        return QueryableList([\n            boardMembership.board\n            for project in self.projects\n            for boardMembership in project.boardMemberships\n            if boardMembership.userId == self.id\n        ])\n\n    @property\n    def cards(self) -&gt; QueryableList[Card]:\n        \"\"\"All cards assigned to the user in all projects\n\n        Returns:\n            Queryable List of all cards assigned to the user\n        \"\"\"\n        return QueryableList([\n            cardMembership.card\n            for board in self.boards\n            for cardMembership in board.cardMemberships\n            if cardMembership.userId == self.id\n        ])\n\n    @property\n    def manager_of(self) -&gt; QueryableList[Project]:\n        \"\"\"All projects the user is a manager of\n\n        Returns:\n            Queryable List of all projects the user is a manager of\n        \"\"\"\n        return QueryableList([\n            project\n            for project in self.projects\n            for manager in project.managers\n            if manager.id == self.id\n        ])\n\n    @property\n    def notifications(self) -&gt; QueryableList[Notification]:\n        \"\"\"All notifications for the user\n\n        Returns:\n            Queryable List of all notifications for the user\n        \"\"\"\n        route = self.routes.get_notification_index()\n        return QueryableList([\n            Notification(**notification).bind(self.routes)\n            for notification in route()['items']\n            if notification['userId'] == self.id\n        ])\n\n    def download_avatar(self, path: Path) -&gt; Path | None:\n        \"\"\"Download the user's avatar to a file\n\n        Args:\n            path (Path): Path to save the avatar image\n\n        Raises:\n            ValueError: If the user has no avatar\n        \"\"\"\n        if self.avatarUrl is None:\n            return None\n\n        path = Path(path)\n        path.write_bytes(self.routes.handler._get_file(self.avatarUrl))\n        return path\n\n    def set_avatar(self, image: Path) -&gt; User:\n        \"\"\"Set the user's avatar\n\n        Note:\n            The image path can be a local filepath or a URL.\n\n        Args:\n            image (Path): Path to the image file\n\n        Returns:\n            User: Updated user instance\n        \"\"\"\n        route = self.routes.post_user_avatar(id=self.id)\n        return User(**route(_file=image)['item']).bind(self.routes)\n\n    def remove_avatar(self) -&gt; None:\n        \"\"\"Remove the user's avatar\"\"\"\n        with self.editor():\n            self.avatarUrl = None\n\n    @overload\n    def update(self) -&gt; User: ...\n\n    @overload\n    def update(self, user: User) -&gt; User: ...\n\n    @overload\n    def update(self, name: str=None, \n               username: str=None, email: str=None, \n               language: str=None, organization: str=None,\n               phone: str=None, avatarUrl: str=None,\n               isAdmin: bool=None, isDeletionLocked: bool=None,\n               isLocked: bool=None, isRoleLocked: bool=None,\n               isUsernameLocked: bool=None, subscribeToOwnCards:bool=None) -&gt; User: ...\n\n    def update(self, *args, **kwargs) -&gt; User:\n        \"\"\"Updates the user with new values\n\n        Args:\n            name (str): Name of the user (optional)\n            username (str): Username of the user (optional)\n            email (str): Email of the user (optional)\n            language (str): Language of the user (optional)\n            organization (str): Organization of the user (optional)\n            phone (str): Phone number of the user (optional)\n            avatarUrl (str): Avatar url of the user (optional)\n            isAdmin (bool): Whether the user is an admin (optional)\n            isDeletionLocked (bool): Whether the user is deletion locked (optional)\n            isLocked (bool): Whether the user is locked (optional)\n            isRoleLocked (bool): Whether the user is role locked (optional)\n            isUsernameLocked (bool): Whether the user is username locked (optional)\n            subscribeToOwnCards (bool): Whether the user is subscribed to their own cards (optional)\n\n        Args: Alternate\n            user (User): User instance to update (required)\n\n        Note:\n            If no arguments are provided, the user will update itself with the current values stored in its attributes\n\n        Returns:\n            User: Updated user instance\n        \"\"\"\n        overload = parse_overload(\n            args, kwargs, \n            model='user', \n            options=('name', 'username', 'email', 'language', \n                     'organization', 'phone', 'avatarUrl', \n                     'isAdmin', 'isDeletionLocked', 'isLocked', \n                     'isRoleLocked', 'isUsernameLocked', \n                     'subscribeToOwnCards'),\n            noarg=self)\n        route = self.routes.patch_user(id=self.id)\n        self.__init__(**route(**overload)['item'])\n        return self\n\n    def delete(self) -&gt; User:\n        \"\"\"Deletes the user\n\n        Danger:\n            This action is irreversible and cannot be undone\n\n        Returns:\n            User: Deleted user instance\n        \"\"\"\n        self.refresh()\n        route = self.routes.delete_user(id=self.id)\n        route()\n        return self\n\n    def refresh(self) -&gt; None:\n        \"\"\"Refreshes the user data\n        \"\"\"\n        route = self.routes.get_user(id=self.id)\n        self.__init__(**route()['item'])\n</code></pre>"},{"location":"interfaces/User/#plankapy.interfaces.User.boards","title":"<code>boards</code>  <code>property</code>","text":"<p>All boards the user is a member of</p> <p>Returns:</p> Type Description <code>QueryableList[Board]</code> <p>Queryable List of all boards the user is a member of</p>"},{"location":"interfaces/User/#plankapy.interfaces.User.cards","title":"<code>cards</code>  <code>property</code>","text":"<p>All cards assigned to the user in all projects</p> <p>Returns:</p> Type Description <code>QueryableList[Card]</code> <p>Queryable List of all cards assigned to the user</p>"},{"location":"interfaces/User/#plankapy.interfaces.User.manager_of","title":"<code>manager_of</code>  <code>property</code>","text":"<p>All projects the user is a manager of</p> <p>Returns:</p> Type Description <code>QueryableList[Project]</code> <p>Queryable List of all projects the user is a manager of</p>"},{"location":"interfaces/User/#plankapy.interfaces.User.notifications","title":"<code>notifications</code>  <code>property</code>","text":"<p>All notifications for the user</p> <p>Returns:</p> Type Description <code>QueryableList[Notification]</code> <p>Queryable List of all notifications for the user</p>"},{"location":"interfaces/User/#plankapy.interfaces.User.projects","title":"<code>projects</code>  <code>property</code>","text":"<p>All projects the user is a member of</p> <p>Returns:</p> Type Description <code>QueryableList[Project]</code> <p>Queryable List of all projects the user is a member of</p>"},{"location":"interfaces/User/#plankapy.interfaces.User.delete","title":"<code>delete()</code>","text":"<p>Deletes the user</p> Danger <p>This action is irreversible and cannot be undone</p> <p>Returns:</p> Name Type Description <code>User</code> <code>User</code> <p>Deleted user instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def delete(self) -&gt; User:\n    \"\"\"Deletes the user\n\n    Danger:\n        This action is irreversible and cannot be undone\n\n    Returns:\n        User: Deleted user instance\n    \"\"\"\n    self.refresh()\n    route = self.routes.delete_user(id=self.id)\n    route()\n    return self\n</code></pre>"},{"location":"interfaces/User/#plankapy.interfaces.User.download_avatar","title":"<code>download_avatar(path)</code>","text":"<p>Download the user's avatar to a file</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to save the avatar image</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the user has no avatar</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def download_avatar(self, path: Path) -&gt; Path | None:\n    \"\"\"Download the user's avatar to a file\n\n    Args:\n        path (Path): Path to save the avatar image\n\n    Raises:\n        ValueError: If the user has no avatar\n    \"\"\"\n    if self.avatarUrl is None:\n        return None\n\n    path = Path(path)\n    path.write_bytes(self.routes.handler._get_file(self.avatarUrl))\n    return path\n</code></pre>"},{"location":"interfaces/User/#plankapy.interfaces.User.refresh","title":"<code>refresh()</code>","text":"<p>Refreshes the user data</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"Refreshes the user data\n    \"\"\"\n    route = self.routes.get_user(id=self.id)\n    self.__init__(**route()['item'])\n</code></pre>"},{"location":"interfaces/User/#plankapy.interfaces.User.remove_avatar","title":"<code>remove_avatar()</code>","text":"<p>Remove the user's avatar</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def remove_avatar(self) -&gt; None:\n    \"\"\"Remove the user's avatar\"\"\"\n    with self.editor():\n        self.avatarUrl = None\n</code></pre>"},{"location":"interfaces/User/#plankapy.interfaces.User.set_avatar","title":"<code>set_avatar(image)</code>","text":"<p>Set the user's avatar</p> Note <p>The image path can be a local filepath or a URL.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Path</code> <p>Path to the image file</p> required <p>Returns:</p> Name Type Description <code>User</code> <code>User</code> <p>Updated user instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def set_avatar(self, image: Path) -&gt; User:\n    \"\"\"Set the user's avatar\n\n    Note:\n        The image path can be a local filepath or a URL.\n\n    Args:\n        image (Path): Path to the image file\n\n    Returns:\n        User: Updated user instance\n    \"\"\"\n    route = self.routes.post_user_avatar(id=self.id)\n    return User(**route(_file=image)['item']).bind(self.routes)\n</code></pre>"},{"location":"interfaces/User/#plankapy.interfaces.User.update","title":"<code>update(*args, **kwargs)</code>","text":"<pre><code>update() -&gt; User\n</code></pre><pre><code>update(user: User) -&gt; User\n</code></pre><pre><code>update(name: str = None, username: str = None, email: str = None, language: str = None, organization: str = None, phone: str = None, avatarUrl: str = None, isAdmin: bool = None, isDeletionLocked: bool = None, isLocked: bool = None, isRoleLocked: bool = None, isUsernameLocked: bool = None, subscribeToOwnCards: bool = None) -&gt; User\n</code></pre> <p>Updates the user with new values</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the user (optional)</p> required <code>username</code> <code>str</code> <p>Username of the user (optional)</p> required <code>email</code> <code>str</code> <p>Email of the user (optional)</p> required <code>language</code> <code>str</code> <p>Language of the user (optional)</p> required <code>organization</code> <code>str</code> <p>Organization of the user (optional)</p> required <code>phone</code> <code>str</code> <p>Phone number of the user (optional)</p> required <code>avatarUrl</code> <code>str</code> <p>Avatar url of the user (optional)</p> required <code>isAdmin</code> <code>bool</code> <p>Whether the user is an admin (optional)</p> required <code>isDeletionLocked</code> <code>bool</code> <p>Whether the user is deletion locked (optional)</p> required <code>isLocked</code> <code>bool</code> <p>Whether the user is locked (optional)</p> required <code>isRoleLocked</code> <code>bool</code> <p>Whether the user is role locked (optional)</p> required <code>isUsernameLocked</code> <code>bool</code> <p>Whether the user is username locked (optional)</p> required <code>subscribeToOwnCards</code> <code>bool</code> <p>Whether the user is subscribed to their own cards (optional)</p> required <p>Alternate</p> Name Type Description Default <code>user</code> <code>User</code> <p>User instance to update (required)</p> required Note <p>If no arguments are provided, the user will update itself with the current values stored in its attributes</p> <p>Returns:</p> Name Type Description <code>User</code> <code>User</code> <p>Updated user instance</p> Source code in <code>src/plankapy/interfaces.py</code> <pre><code>def update(self, *args, **kwargs) -&gt; User:\n    \"\"\"Updates the user with new values\n\n    Args:\n        name (str): Name of the user (optional)\n        username (str): Username of the user (optional)\n        email (str): Email of the user (optional)\n        language (str): Language of the user (optional)\n        organization (str): Organization of the user (optional)\n        phone (str): Phone number of the user (optional)\n        avatarUrl (str): Avatar url of the user (optional)\n        isAdmin (bool): Whether the user is an admin (optional)\n        isDeletionLocked (bool): Whether the user is deletion locked (optional)\n        isLocked (bool): Whether the user is locked (optional)\n        isRoleLocked (bool): Whether the user is role locked (optional)\n        isUsernameLocked (bool): Whether the user is username locked (optional)\n        subscribeToOwnCards (bool): Whether the user is subscribed to their own cards (optional)\n\n    Args: Alternate\n        user (User): User instance to update (required)\n\n    Note:\n        If no arguments are provided, the user will update itself with the current values stored in its attributes\n\n    Returns:\n        User: Updated user instance\n    \"\"\"\n    overload = parse_overload(\n        args, kwargs, \n        model='user', \n        options=('name', 'username', 'email', 'language', \n                 'organization', 'phone', 'avatarUrl', \n                 'isAdmin', 'isDeletionLocked', 'isLocked', \n                 'isRoleLocked', 'isUsernameLocked', \n                 'subscribeToOwnCards'),\n        noarg=self)\n    route = self.routes.patch_user(id=self.id)\n    self.__init__(**route(**overload)['item'])\n    return self\n</code></pre>"},{"location":"models/QueryableList/","title":"QueryableList","text":"<p>               Bases: <code>list[M]</code>, <code>Generic[M]</code></p> <p>A list of Queryable objects</p> <p>This class is a subclass of the built-in <code>list</code> class that allows for querying the list of objects.</p> Source code in <code>src/plankapy/models.py</code> <pre><code>class QueryableList(list[M], Generic[M]):\n    \"\"\"A list of Queryable objects\n\n    This class is a subclass of the built-in `list` class that allows for querying the list of objects.\n\n    \"\"\"\n\n    def filter_where(self, **kwargs) -&gt; QueryableList[M] | None:\n        \"\"\"Filter the list of objects by keyword arguments\n\n        Args:\n            **kwargs: See Model for the available attributes\n\n        Returns:\n            QueryableList[M]: The objects that match the filter or None if no objects match\n\n        Example:\n        ```python\n        &gt;&gt;&gt; users = QueryableList(project.users)\n        &gt;&gt;&gt; users\n        [User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Bob')]\n\n        &gt;&gt;&gt; users.filter_where(name='Bob')\n        [User(id=1, name='Bob'), User(id=3, name='Bob')]\n        ```\n        \"\"\"\n        return QueryableList(item for item in self if all(getattr(item, key) == value for key, value in kwargs.items())) or None\n\n    def select_where(self, predicate: Callable[[M], bool]) -&gt; QueryableList[M]:\n        \"\"\"Select objects from the list that match a function\n\n        Args:\n            predicate: A function that takes an object and returns a boolean\n\n        Returns:\n            QueryableList[M]: The objects that match the function\n\n        Example:\n        ```python\n        &gt;&gt;&gt; users = QueryableList(project.users)\n        &gt;&gt;&gt; users\n        [User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Frank')]\n\n        &gt;&gt;&gt; users = users.select_where(lambda x: x.name in ('Bob', 'Alice'))\n        &gt;&gt;&gt; users\n        [User(id=1, name='Bob'), User(id=2, name='Alice')]\n        ```\n        \"\"\"\n        return QueryableList(item for item in self if predicate(item))\n\n    def pop_where(self, **kwargs) -&gt; M | None:\n        \"\"\"Get the first object that matches the filter\n\n        Args:\n            **kwargs: Keyword arguments to filter the list by\n\n        Returns:\n            M: The first object that matches the filter\n\n        Example:\n        ```python\n        &gt;&gt;&gt; users = QueryableList(project.users)\n        &gt;&gt;&gt; users\n        [User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Bob')]\n\n        &gt;&gt;&gt; users.pop_where(name='Bob')\n        User(id=1, name='Bob')\n\n        &gt;&gt;&gt; user = users.pop_where(name='Frank')\n        &gt;&gt;&gt; user\n        None\n        ```\n        \"\"\"\n        vals = self.filter_where(**kwargs)\n        return vals[0] if vals else None\n\n    def order_by(self, key: str, desc: bool=False) -&gt; QueryableList[M]:\n        \"\"\"Order the list by a key\n\n        Args:\n            key (str): The key to order by\n            desc (bool): True to order in descending order, False otherwise\n\n        Returns:\n            QueryableList[M]: The list of objects ordered by the key\n\n        Example:\n        ```python\n        &gt;&gt;&gt; users = QueryableList(project.users)\n        &gt;&gt;&gt; users\n        [User(name='Bob'), User(name='Alice')]\n\n        &gt;&gt;&gt; users = users.order_by('name')\n        &gt;&gt;&gt; users\n        [User(name='Alice'), User(name='Bob')]\n\n        &gt;&gt;&gt; users = users.order_by('name', desc=True)\n        &gt;&gt;&gt; users\n        [User(name='Bob'), User(name='Alice')]\n        ```\n        \"\"\"\n        return QueryableList(sorted(self, key=lambda x: getattr(x, key), reverse=desc))\n\n    def take(self, n: int) -&gt; QueryableList[M]:\n        \"\"\"Take the first n objects from the list\n\n        Args:\n            n (int): The number of objects to take\n\n        Returns:\n            QueryableList[M]: The first n objects in the list, if n is greater than the length of the list, the list is padded with `None`\n\n        Example:\n        ```python\n        &gt;&gt;&gt; users = QueryableList(project.users)\n        &gt;&gt;&gt; users.take(2)\n        [User(name='Alice'), User(name='Bob')]\n\n        &gt;&gt;&gt; users.take(3)\n        [User(name='Alice'), User(name='Bob'), None]\n        ```\n        \"\"\"\n        if n &gt; len(self):\n            return self + [None] * (n - len(self))\n        return self[:n]\n</code></pre>"},{"location":"models/QueryableList/#plankapy.models.QueryableList.filter_where","title":"<code>filter_where(**kwargs)</code>","text":"<p>Filter the list of objects by keyword arguments</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>See Model for the available attributes</p> <code>{}</code> <p>Returns:</p> Type Description <code>QueryableList[M] | None</code> <p>QueryableList[M]: The objects that match the filter or None if no objects match</p> <p>Example: <pre><code>&gt;&gt;&gt; users = QueryableList(project.users)\n&gt;&gt;&gt; users\n[User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Bob')]\n\n&gt;&gt;&gt; users.filter_where(name='Bob')\n[User(id=1, name='Bob'), User(id=3, name='Bob')]\n</code></pre></p> Source code in <code>src/plankapy/models.py</code> <pre><code>def filter_where(self, **kwargs) -&gt; QueryableList[M] | None:\n    \"\"\"Filter the list of objects by keyword arguments\n\n    Args:\n        **kwargs: See Model for the available attributes\n\n    Returns:\n        QueryableList[M]: The objects that match the filter or None if no objects match\n\n    Example:\n    ```python\n    &gt;&gt;&gt; users = QueryableList(project.users)\n    &gt;&gt;&gt; users\n    [User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Bob')]\n\n    &gt;&gt;&gt; users.filter_where(name='Bob')\n    [User(id=1, name='Bob'), User(id=3, name='Bob')]\n    ```\n    \"\"\"\n    return QueryableList(item for item in self if all(getattr(item, key) == value for key, value in kwargs.items())) or None\n</code></pre>"},{"location":"models/QueryableList/#plankapy.models.QueryableList.order_by","title":"<code>order_by(key, desc=False)</code>","text":"<p>Order the list by a key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to order by</p> required <code>desc</code> <code>bool</code> <p>True to order in descending order, False otherwise</p> <code>False</code> <p>Returns:</p> Type Description <code>QueryableList[M]</code> <p>QueryableList[M]: The list of objects ordered by the key</p> <p>Example: <pre><code>&gt;&gt;&gt; users = QueryableList(project.users)\n&gt;&gt;&gt; users\n[User(name='Bob'), User(name='Alice')]\n\n&gt;&gt;&gt; users = users.order_by('name')\n&gt;&gt;&gt; users\n[User(name='Alice'), User(name='Bob')]\n\n&gt;&gt;&gt; users = users.order_by('name', desc=True)\n&gt;&gt;&gt; users\n[User(name='Bob'), User(name='Alice')]\n</code></pre></p> Source code in <code>src/plankapy/models.py</code> <pre><code>def order_by(self, key: str, desc: bool=False) -&gt; QueryableList[M]:\n    \"\"\"Order the list by a key\n\n    Args:\n        key (str): The key to order by\n        desc (bool): True to order in descending order, False otherwise\n\n    Returns:\n        QueryableList[M]: The list of objects ordered by the key\n\n    Example:\n    ```python\n    &gt;&gt;&gt; users = QueryableList(project.users)\n    &gt;&gt;&gt; users\n    [User(name='Bob'), User(name='Alice')]\n\n    &gt;&gt;&gt; users = users.order_by('name')\n    &gt;&gt;&gt; users\n    [User(name='Alice'), User(name='Bob')]\n\n    &gt;&gt;&gt; users = users.order_by('name', desc=True)\n    &gt;&gt;&gt; users\n    [User(name='Bob'), User(name='Alice')]\n    ```\n    \"\"\"\n    return QueryableList(sorted(self, key=lambda x: getattr(x, key), reverse=desc))\n</code></pre>"},{"location":"models/QueryableList/#plankapy.models.QueryableList.pop_where","title":"<code>pop_where(**kwargs)</code>","text":"<p>Get the first object that matches the filter</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Keyword arguments to filter the list by</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>M</code> <code>M | None</code> <p>The first object that matches the filter</p> <p>Example: <pre><code>&gt;&gt;&gt; users = QueryableList(project.users)\n&gt;&gt;&gt; users\n[User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Bob')]\n\n&gt;&gt;&gt; users.pop_where(name='Bob')\nUser(id=1, name='Bob')\n\n&gt;&gt;&gt; user = users.pop_where(name='Frank')\n&gt;&gt;&gt; user\nNone\n</code></pre></p> Source code in <code>src/plankapy/models.py</code> <pre><code>def pop_where(self, **kwargs) -&gt; M | None:\n    \"\"\"Get the first object that matches the filter\n\n    Args:\n        **kwargs: Keyword arguments to filter the list by\n\n    Returns:\n        M: The first object that matches the filter\n\n    Example:\n    ```python\n    &gt;&gt;&gt; users = QueryableList(project.users)\n    &gt;&gt;&gt; users\n    [User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Bob')]\n\n    &gt;&gt;&gt; users.pop_where(name='Bob')\n    User(id=1, name='Bob')\n\n    &gt;&gt;&gt; user = users.pop_where(name='Frank')\n    &gt;&gt;&gt; user\n    None\n    ```\n    \"\"\"\n    vals = self.filter_where(**kwargs)\n    return vals[0] if vals else None\n</code></pre>"},{"location":"models/QueryableList/#plankapy.models.QueryableList.select_where","title":"<code>select_where(predicate)</code>","text":"<p>Select objects from the list that match a function</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[M], bool]</code> <p>A function that takes an object and returns a boolean</p> required <p>Returns:</p> Type Description <code>QueryableList[M]</code> <p>QueryableList[M]: The objects that match the function</p> <p>Example: <pre><code>&gt;&gt;&gt; users = QueryableList(project.users)\n&gt;&gt;&gt; users\n[User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Frank')]\n\n&gt;&gt;&gt; users = users.select_where(lambda x: x.name in ('Bob', 'Alice'))\n&gt;&gt;&gt; users\n[User(id=1, name='Bob'), User(id=2, name='Alice')]\n</code></pre></p> Source code in <code>src/plankapy/models.py</code> <pre><code>def select_where(self, predicate: Callable[[M], bool]) -&gt; QueryableList[M]:\n    \"\"\"Select objects from the list that match a function\n\n    Args:\n        predicate: A function that takes an object and returns a boolean\n\n    Returns:\n        QueryableList[M]: The objects that match the function\n\n    Example:\n    ```python\n    &gt;&gt;&gt; users = QueryableList(project.users)\n    &gt;&gt;&gt; users\n    [User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Frank')]\n\n    &gt;&gt;&gt; users = users.select_where(lambda x: x.name in ('Bob', 'Alice'))\n    &gt;&gt;&gt; users\n    [User(id=1, name='Bob'), User(id=2, name='Alice')]\n    ```\n    \"\"\"\n    return QueryableList(item for item in self if predicate(item))\n</code></pre>"},{"location":"models/QueryableList/#plankapy.models.QueryableList.take","title":"<code>take(n)</code>","text":"<p>Take the first n objects from the list</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of objects to take</p> required <p>Returns:</p> Type Description <code>QueryableList[M]</code> <p>QueryableList[M]: The first n objects in the list, if n is greater than the length of the list, the list is padded with <code>None</code></p> <p>Example: <pre><code>&gt;&gt;&gt; users = QueryableList(project.users)\n&gt;&gt;&gt; users.take(2)\n[User(name='Alice'), User(name='Bob')]\n\n&gt;&gt;&gt; users.take(3)\n[User(name='Alice'), User(name='Bob'), None]\n</code></pre></p> Source code in <code>src/plankapy/models.py</code> <pre><code>def take(self, n: int) -&gt; QueryableList[M]:\n    \"\"\"Take the first n objects from the list\n\n    Args:\n        n (int): The number of objects to take\n\n    Returns:\n        QueryableList[M]: The first n objects in the list, if n is greater than the length of the list, the list is padded with `None`\n\n    Example:\n    ```python\n    &gt;&gt;&gt; users = QueryableList(project.users)\n    &gt;&gt;&gt; users.take(2)\n    [User(name='Alice'), User(name='Bob')]\n\n    &gt;&gt;&gt; users.take(3)\n    [User(name='Alice'), User(name='Bob'), None]\n    ```\n    \"\"\"\n    if n &gt; len(self):\n        return self + [None] * (n - len(self))\n    return self[:n]\n</code></pre>"},{"location":"models/models/","title":"Models","text":""},{"location":"models/models/#plankapy.models.Action_","title":"<code>Action_</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Model</code></p> <p>Action Model</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The ID of the action</p> <code>type</code> <code>ActionType</code> <p>The type of the action</p> <code>data</code> <code>dict</code> <p>The data of the action</p> <code>cardId</code> <code>int</code> <p>The ID of the card the action is associated with</p> <code>userId</code> <code>int</code> <p>The ID of the user who created the action</p> <code>createdAt</code> <code>datetime</code> <p>The creation date of the action</p> <code>updatedAt</code> <code>datetime</code> <p>The last update date of the action</p> Source code in <code>src/plankapy/models.py</code> <pre><code>@dataclass(eq=False)\nclass Action_(Model):\n    \"\"\"Action Model\n\n    Attributes:\n        id (int): The ID of the action\n        type (ActionType): The type of the action\n        data (dict): The data of the action\n        cardId (int): The ID of the card the action is associated with\n        userId (int): The ID of the user who created the action\n        createdAt (datetime): The creation date of the action\n        updatedAt (datetime): The last update date of the action\n    \"\"\"\n\n    id: Optional[int]=Unset\n    type: Optional[ActionType]=Required\n    data: Optional[dict]=Required\n    cardId: Optional[int]=Required\n    userId: Optional[int]=Required\n    createdAt: Optional[str]=Unset\n    updatedAt: Optional[str]=Unset\n</code></pre>"},{"location":"models/models/#plankapy.models.Archive_","title":"<code>Archive_</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Model</code></p> <p>Archive Model</p> Warning <p>This model is currently unavailable in the Planka API</p> <p>Attributes:</p> Name Type Description <code>fromModel</code> <code>str</code> <p>The model the archive is from</p> <code>originalRecordId</code> <code>int</code> <p>The ID of the original record</p> <code>originalRecord</code> <code>dict</code> <p>The original record</p> Source code in <code>src/plankapy/models.py</code> <pre><code>@dataclass(eq=False)\nclass Archive_(Model):\n    \"\"\"Archive Model\n\n    Warning:\n        This model is currently unavailable in the Planka API\n\n    Attributes:\n        fromModel (str): The model the archive is from\n        originalRecordId (int): The ID of the original record\n        originalRecord (dict): The original record\n    \"\"\"\n\n    fromModel: Optional[str]=Required\n    originalRecordId: Optional[int]=Required\n    originalRecord: Optional[dict]=Required\n</code></pre>"},{"location":"models/models/#plankapy.models.Attachment_","title":"<code>Attachment_</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Model</code></p> <p>Attachment Model</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The ID of the attachment</p> <code>name</code> <code>str</code> <p>The name of the attachment</p> <code>url</code> <code>str</code> <p>The URL of the attachment</p> <code>cardId</code> <code>int</code> <p>The ID of the card the attachment is associated with</p> <code>dirname</code> <code>str</code> <p>The directory name of the attachment</p> <code>filename</code> <code>str</code> <p>The filename of the attachment</p> <code>image</code> <code>dict</code> <p>The image of the attachment in the format <code>{'width': int, 'height': int}</code></p> <code>url</code> <code>str</code> <p>The URL of the attachment</p> <code>coverUrl</code> <code>str</code> <p>The cover URL of the attachment</p> <code>cardId</code> <code>int</code> <p>The ID of the card the attachment is associated with</p> <code>creatorUserId</code> <code>int</code> <p>The ID of the user who created the attachment</p> <code>createdAt</code> <code>datetime</code> <p>The creation date of the attachment</p> <code>updatedAt</code> <code>datetime</code> <p>The last update date of the attachment</p> Source code in <code>src/plankapy/models.py</code> <pre><code>@dataclass(eq=False)\nclass Attachment_(Model):\n    \"\"\"Attachment Model\n\n    Attributes:\n        id (int): The ID of the attachment\n        name (str): The name of the attachment\n        url (str): The URL of the attachment\n        cardId (int): The ID of the card the attachment is associated with\n        dirname (str): The directory name of the attachment\n        filename (str): The filename of the attachment\n        image (dict): The image of the attachment in the format `{'width': int, 'height': int}`\n        url (str): The URL of the attachment\n        coverUrl (str): The cover URL of the attachment\n        cardId (int): The ID of the card the attachment is associated with\n        creatorUserId (int): The ID of the user who created the attachment\n        createdAt (datetime): The creation date of the attachment\n        updatedAt (datetime): The last update date of the attachment\n        \"\"\"\n    id: Optional[int]=Unset\n    name: Optional[str]=Required\n    dirname: Optional[Literal['public', 'private/attachments']]=Required\n    filename: Optional[str]=Required\n    image: Optional[dict]=Unset\n    url: Optional[str]=Unset\n    coverUrl: Optional[str]=Unset\n    cardId: Optional[int]=Required\n    creatorUserId: Optional[int]=Unset\n    createdAt: Optional[str]=Unset\n    updatedAt: Optional[str]=Unset\n</code></pre>"},{"location":"models/models/#plankapy.models.BoardMembership_","title":"<code>BoardMembership_</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Model</code></p> <p>Board Membership Model</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The ID of the board membership</p> <code>role</code> <code>BoardRole</code> <p>The role of the board membership</p> <code>canComment</code> <code>bool</code> <p>The comment permission of the board membership</p> <code>boardId</code> <code>int</code> <p>The ID of the board the membership is associated with</p> <code>userId</code> <code>int</code> <p>The ID of the user the membership is associated with</p> <code>createdAt</code> <code>datetime</code> <p>The creation date of the board membership</p> <code>updatedAt</code> <code>datetime</code> <p>The last update date of the board membership</p> Source code in <code>src/plankapy/models.py</code> <pre><code>@dataclass(eq=False)\nclass BoardMembership_(Model):\n    \"\"\"Board Membership Model\n\n    Attributes:\n        id (int): The ID of the board membership\n        role (BoardRole): The role of the board membership\n        canComment (bool): The comment permission of the board membership\n        boardId (int): The ID of the board the membership is associated with\n        userId (int): The ID of the user the membership is associated with\n        createdAt (datetime): The creation date of the board membership\n        updatedAt (datetime): The last update date of the board membership\n    \"\"\"\n    id: Optional[int]=Unset\n    role: Optional[BoardRole]=Required\n    canComment: Optional[bool]=Unset\n    boardId: Optional[int]=Required\n    userId: Optional[int]=Required\n    createdAt: Optional[str]=Unset\n    updatedAt: Optional[str]=Unset\n</code></pre>"},{"location":"models/models/#plankapy.models.Board_","title":"<code>Board_</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Model</code></p> <p>Board Model</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The ID of the board</p> <code>name</code> <code>str</code> <p>The name of the board</p> <code>description</code> <code>str</code> <p>The description of the board</p> <code>isClosed</code> <code>bool</code> <p>The closed status of the board</p> <code>isStarred</code> <code>bool</code> <p>The starred status of the board</p> <code>createdAt</code> <code>datetime</code> <p>The creation date of the board</p> <code>updatedAt</code> <code>datetime</code> <p>The last update date of the board</p> Source code in <code>src/plankapy/models.py</code> <pre><code>@dataclass(eq=False)\nclass Board_(Model):\n    \"\"\"Board Model\n\n    Attributes:\n        id (int): The ID of the board\n        name (str): The name of the board\n        description (str): The description of the board\n        isClosed (bool): The closed status of the board\n        isStarred (bool): The starred status of the board\n        createdAt (datetime): The creation date of the board\n        updatedAt (datetime): The last update date of the board\n    \"\"\"\n    id: Optional[int]=Unset\n    name: Optional[str]=Required\n    position: Optional[int]=Required\n    projectId: Optional[int]=Required\n    createdAt: Optional[str]=Unset\n    updatedAt: Optional[str]=Unset\n</code></pre>"},{"location":"models/models/#plankapy.models.CardLabel_","title":"<code>CardLabel_</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Model</code></p> <p>Card Label Model</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The ID of the card label</p> <code>cardId</code> <code>int</code> <p>The ID of the card the label is associated with</p> <code>labelId</code> <code>int</code> <p>The ID of the label the card is associated with</p> <code>createdAt</code> <code>datetime</code> <p>The creation date of the card label</p> <code>updatedAt</code> <code>datetime</code> <p>The last update date of the card label</p> Source code in <code>src/plankapy/models.py</code> <pre><code>@dataclass(eq=False)\nclass CardLabel_(Model):\n    \"\"\"Card Label Model\n\n    Attributes:\n        id (int): The ID of the card label\n        cardId (int): The ID of the card the label is associated with\n        labelId (int): The ID of the label the card is associated with\n        createdAt (datetime): The creation date of the card label\n        updatedAt (datetime): The last update date of the card label\n    \"\"\"\n    id: Optional[int]=Unset\n    cardId: Optional[int]=Required\n    labelId: Optional[int]=Required\n    createdAt: Optional[str]=Unset\n    updatedAt: Optional[str]=Unset\n</code></pre>"},{"location":"models/models/#plankapy.models.CardMembership_","title":"<code>CardMembership_</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Model</code></p> <p>Card Membership Model</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The ID of the card membership</p> <code>cardId</code> <code>int</code> <p>The ID of the card the membership is associated with</p> <code>userId</code> <code>int</code> <p>The ID of the user the membership is associated with</p> <code>createdAt</code> <code>datetime</code> <p>The creation date of the card membership</p> <code>updatedAt</code> <code>datetime</code> <p>The last update date of the card membership</p> Source code in <code>src/plankapy/models.py</code> <pre><code>@dataclass(eq=False)\nclass CardMembership_(Model):\n    \"\"\"Card Membership Model\n\n    Attributes:\n        id (int): The ID of the card membership\n        cardId (int): The ID of the card the membership is associated with\n        userId (int): The ID of the user the membership is associated with\n        createdAt (datetime): The creation date of the card membership\n        updatedAt (datetime): The last update date of the card membership\n    \"\"\"\n    id: Optional[int]=Unset\n    cardId: Optional[int]=Required\n    userId: Optional[int]=Required\n    createdAt: Optional[str]=Unset\n    updatedAt: Optional[str]=Unset\n</code></pre>"},{"location":"models/models/#plankapy.models.CardSubscription_","title":"<code>CardSubscription_</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Model</code></p> <p>Card Subscription Model</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The ID of the card subscription</p> <code>cardId</code> <code>int</code> <p>The ID of the card the subscription is associated with</p> <code>userId</code> <code>int</code> <p>The ID of the user the subscription is associated with</p> <code>createdAt</code> <code>datetime</code> <p>The creation date of the card subscription</p> <code>updatedAt</code> <code>datetime</code> <p>The last update date of the card subscription</p> Source code in <code>src/plankapy/models.py</code> <pre><code>@dataclass(eq=False)\nclass CardSubscription_(Model):\n    \"\"\"Card Subscription Model\n\n    Attributes:\n        id (int): The ID of the card subscription\n        cardId (int): The ID of the card the subscription is associated with\n        userId (int): The ID of the user the subscription is associated with\n        createdAt (datetime): The creation date of the card subscription\n        updatedAt (datetime): The last update date of the card subscription    \n    \"\"\"\n    id: Optional[int]=Unset\n    cardId: Optional[int]=Required\n    userId: Optional[int]=Required\n    isPermanent: Optional[bool]=Unset\n    createdAt: Optional[str]=Unset\n    updatedAt: Optional[str]=Unset\n</code></pre>"},{"location":"models/models/#plankapy.models.Card_","title":"<code>Card_</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Model</code></p> <p>Card Model</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The ID of the card</p> <code>name</code> <code>str</code> <p>The name of the card</p> <code>position</code> <code>int</code> <p>The position of the card</p> <code>description</code> <code>str</code> <p>The description of the card</p> <code>dueDate</code> <code>datetime</code> <p>The due date of the card</p> <code>isDueDateCompleted</code> <code>bool</code> <p>The due date completion status of the card</p> <code>stopwatch</code> <code>_Stopwatch</code> <p>The stopwatch associated with the card</p> <code>boardId</code> <code>int</code> <p>The ID of the board the card is associated with</p> <code>listId</code> <code>int</code> <p>The ID of the list the card is associated with</p> <code>creatorUserId</code> <code>int</code> <p>The ID of the user who created the card</p> <code>coverAttachmentId</code> <code>int</code> <p>The ID of the cover attachment of the card</p> <code>isSubscribed</code> <code>bool</code> <p>The current user's subscription status with the card</p> <code>createdAt</code> <code>datetime</code> <p>The creation date of the card</p> <code>updatedAt</code> <code>datetime</code> <p>The last update date of the card</p> Source code in <code>src/plankapy/models.py</code> <pre><code>@dataclass(eq=False)\nclass Card_(Model):\n    \"\"\"Card Model\n\n    Attributes:\n        id (int): The ID of the card\n        name (str): The name of the card\n        position (int): The position of the card\n        description (str): The description of the card\n        dueDate (datetime): The due date of the card\n        isDueDateCompleted (bool): The due date completion status of the card\n        stopwatch (_Stopwatch): The stopwatch associated with the card\n        boardId (int): The ID of the board the card is associated with\n        listId (int): The ID of the list the card is associated with\n        creatorUserId (int): The ID of the user who created the card\n        coverAttachmentId (int): The ID of the cover attachment of the card\n        isSubscribed (bool): The current user's subscription status with the card\n        createdAt (datetime): The creation date of the card\n        updatedAt (datetime): The last update date of the card\n    \"\"\"\n    id: Optional[int]=Unset\n    name: Optional[str]=Required\n    position: Optional[int]=Required\n    description: Optional[str]=Unset\n    dueDate: Optional[str]=Unset\n    isDueDateCompleted: Optional[bool]=Unset\n    stopwatch: Optional[Stopwatch]=Unset\n    boardId: Optional[int]=Required\n    listId: Optional[int]=Required\n    creatorUserId: Optional[int]=Unset\n    coverAttachmentId: Optional[int]=Unset\n    isSubscribed: Optional[bool]=Unset\n    createdAt: Optional[str]=Unset\n    updatedAt: Optional[str]=Unset\n</code></pre>"},{"location":"models/models/#plankapy.models.IdentityProviderUser_","title":"<code>IdentityProviderUser_</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Model</code></p> <p>Identity Provider User Model</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The ID of the identity provider user</p> <code>issuer</code> <code>str</code> <p>The issuer of the identity provider user</p> <code>sub</code> <code>str</code> <p>The sub of the identity provider user</p> <code>userId</code> <code>int</code> <p>The ID of the user the identity provider user is associated with</p> <code>createdAt</code> <code>datetime</code> <p>The creation date of the identity provider user</p> <code>updatedAt</code> <code>datetime</code> <p>The last update date of the identity provider user</p> Source code in <code>src/plankapy/models.py</code> <pre><code>@dataclass(eq=False)\nclass IdentityProviderUser_(Model):\n    \"\"\"Identity Provider User Model\n\n    Attributes:\n        id (int): The ID of the identity provider user\n        issuer (str): The issuer of the identity provider user\n        sub (str): The sub of the identity provider user\n        userId (int): The ID of the user the identity provider user is associated with\n        createdAt (datetime): The creation date of the identity provider user\n        updatedAt (datetime): The last update date of the identity provider user\n    \"\"\"\n    id: Optional[int]=Unset\n    issuer: Optional[str]=Unset\n    sub: Optional[str]=Unset\n    userId: Optional[int]=Required\n    createdAt: Optional[str]=Unset\n    updatedAt: Optional[str]=Unset\n</code></pre>"},{"location":"models/models/#plankapy.models.Label_","title":"<code>Label_</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Model</code></p> <p>Label Model</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The ID of the label</p> <code>name</code> <code>str</code> <p>The name of the label</p> <code>position</code> <code>int</code> <p>The position of the label</p> <code>color</code> <code>str</code> <p>The color of the label</p> <code>boardId</code> <code>int</code> <p>The ID of the board the label is associated with</p> <code>createdAt</code> <code>datetime</code> <p>The creation date of the label</p> <code>updatedAt</code> <code>datetime</code> <p>The last update date of the label</p> Source code in <code>src/plankapy/models.py</code> <pre><code>@dataclass(eq=False)\nclass Label_(Model):\n    \"\"\"Label Model\n\n    Attributes:\n        id (int): The ID of the label\n        name (str): The name of the label\n        position (int): The position of the label\n        color (str): The color of the label\n        boardId (int): The ID of the board the label is associated with\n        createdAt (datetime): The creation date of the label\n        updatedAt (datetime): The last update date of the label\n    \"\"\"\n    id: Optional[int]=Unset\n    name: Optional[str]=Required\n    position: Optional[int]=Required\n    color: Optional[str]=Required\n    boardId: Optional[int]=Required\n    createdAt: Optional[str]=Unset\n    updatedAt: Optional[str]=Unset\n</code></pre>"},{"location":"models/models/#plankapy.models.List_","title":"<code>List_</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Model</code></p> <p>List Model</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The ID of the list</p> <code>name</code> <code>str</code> <p>The name of the list</p> <code>position</code> <code>int</code> <p>The position of the list</p> <code>boardId</code> <code>int</code> <p>The ID of the board the list is associated with</p> <code>color</code> <code>str</code> <p>The color of the list</p> <code>createdAt</code> <code>datetime</code> <p>The creation date of the list</p> <code>updatedAt</code> <code>datetime</code> <p>The last update date of the list</p> Source code in <code>src/plankapy/models.py</code> <pre><code>@dataclass(eq=False)\nclass List_(Model):\n    \"\"\"List Model\n\n    Attributes:\n        id (int): The ID of the list\n        name (str): The name of the list\n        position (int): The position of the list\n        boardId (int): The ID of the board the list is associated with\n        color (str): The color of the list\n        createdAt (datetime): The creation date of the list\n        updatedAt (datetime): The last update date of the list\n    \"\"\"\n    id: Optional[int]=Unset\n    name: Optional[str]=Required\n    position: Optional[int]=Required\n    boardId: Optional[int]=Required\n    color: Optional[str]=Unset\n    createdAt: Optional[str]=Unset\n    updatedAt: Optional[str]=Unset\n</code></pre>"},{"location":"models/models/#plankapy.models.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>Mapping</code></p> <p>Implements common magic methods for all Models</p> Source code in <code>src/plankapy/models.py</code> <pre><code>class Model(Mapping):\n    \"\"\"Implements common magic methods for all Models\n    \"\"\"\n\n    @property\n    def link(self) -&gt; str | None:\n        \"\"\"Get the link to the model instance\n\n        Note:\n            Only `Project`, `Board`, and `Card` models have links.\n\n            All other models return `None`\n\n        Returns:\n            str: The link to the model instance\n        \"\"\"\n        if hasattr(self, 'id') and hasattr(self, '_routes'):\n            base_url = self.routes.handler.base_url\n            name = self.__class__.__name__.lower().replace('_', '')\n            if name in ('board', 'card', 'project'):\n                return f\"{base_url}{name}s/{self.id}\"\n\n    @property\n    def routes(self) -&gt; Routes:\n        \"\"\"Get the routes for the model instance\n\n        Returns:\n            Routes: The routes bound to the model instance\n        \"\"\"\n        return self._routes\n\n    @routes.setter\n    def routes(self, routes: Routes):\n        \"\"\"Set the routes for the model instance\n\n        Args:\n            routes (Routes): The routes to bind to the model instance\n        \"\"\"\n        self._routes = routes\n\n    @property\n    def unique_name(self) -&gt; str:\n        \"\"\"Generate a unique name for the model instance using the last 5 characters of the id\n        and the name attribute\n\n        Returns:\n            str: The unique name for the model instance in the format {name}_{id[:-5]}\n        \"\"\"\n        if hasattr(self, 'id') and hasattr(self, 'name'):\n            return f\"{self.name}_{chr(123)}{self.id[-5:]}{chr(125)}\"\n\n        # Default unique name if no id or name (model name and last 5 characters of hash)\n        return f\"{self.__class__.__name__}_{str(hash(self))[-5:]}\"\n\n    @property\n    def created_at(self) -&gt; Optional[datetime]:\n        \"\"\"Get the creation date of the model instance\n\n        Returns:\n            Optional[datetime]: The creation date of the model instance\n        \"\"\"\n        if hasattr(self, 'createdAt'):\n            return datetime.fromisoformat(self.createdAt)\n\n    @property\n    def updated_at(self) -&gt; Optional[datetime]:\n        \"\"\"Get the last update date of the model instance\n\n        Returns:\n            Optional[datetime]: The last update date of the model instance\n        \"\"\"\n        if hasattr(self, 'updatedAt'):\n            return datetime.fromisoformat(self.updatedAt)\n\n    @property\n    def deleted_at(self) -&gt; Optional[datetime]:\n        \"\"\"Get the deletion date of the model instance\n\n        Returns:\n            Optional[datetime]: The deletion date of the model instance\n        \"\"\"\n        if hasattr(self, 'deletedAt'):\n            return datetime.fromisoformat(self.deletedAt)\n\n    def json(self) -&gt; str:\n        \"\"\"Dump the model properties to a JSON string\n\n        Note:\n            Only properties defined in the `{Model}_` dataclass are dumped. \n            All relationships and included items (e.g. `board.cards`) are lost.\n            If you wish to preserve these relationships, use the `.pickle` method\n\n        Returns:\n            (str) : A JSON string with the Model attributes\n        \"\"\"\n        return json.dumps({k: self[k] for k in self})\n\n    def pickle(self) -&gt; bytes:\n        \"\"\"Pickle the model, preserving as much of its state as possible\n\n        Warning:\n            This method currently works, and since the object data is updated by routes\n            You can use this to store a reference to a specific object. The data will be\n            maintained until operations that trigger a `.refresh()` call are made, e.g. \n            using the `.editor()` context.\n\n        Returns:\n            (bytes) : Raw bytes generated by `pickle.dump`\n        \"\"\"\n        out = io.BufferedWriter(raw=io.BytesIO())\n        pickle.dump(self, out)\n        return out.raw.read()\n\n    def bind(self, routes: Routes) -&gt; Self:\n        \"\"\"Bind routes to the model\n        Args:\n            routes (Routes): The routes to bind to the model instance\n\n        Returns:\n            Self for chain operations\n\n        Example:\n            ```python\n            model = Model(**kwargs).bind(routes)\n            ```\n        \"\"\"\n        self.routes = routes\n        return self\n\n    def __getitem__(self, key) -&gt; Any:\n        \"\"\"Get the value of an attribute\n\n        Warning:\n            This is an implementation detail that allows for the unpacking operations\n            in the rest of the codebase, all model attributes are still directly accessible\n            through `__getattribute___`\n\n        Note:\n            Returns None if the attribute is `Unset` or starts with an underscore\n\n        Example:\n            ```python\n            print(model['name'])\n            &gt;&gt;&gt; \"Model Name\"\n\n            model.name = Unset\n            print(model['name'])\n            &gt;&gt;&gt; None\n            ```\n        \"\"\"\n        val = self.__dict__[key]\n        return val if val is not Unset else None\n\n    def __iter__(self):\n        \"\"\"Iterate over public, assigned model attribute names\n\n        Warning:\n            This is used in conjunction with `__getitem__` to unpack assigned values. \n            This allows model state to be passed as keyword arguments to functions\n\n            Example:\n                ```python\n                model = Model(name=\"Model Name\", position=1, other=Unset)\n\n                def func(name=None, position=None):\n                    return {\"name\": name, \"position\": position}\n\n                print(func(**model))\n                &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n                ```\n            Notice how only the assigned values are returned after unpacking and any Unset or \n            private attributes are skipped, This allows `None` values to be assigned during\n            a `PATCH` request to delete data \n\n        Note:\n            Skips attributes that are `Unset` or start with an underscore\n\n        Returns:\n            Iterator: The iterator of the model attributes\n\n        Example:\n            ```python\n\n            # Skip Private attributes\n            print(list(model.__dict__))\n            &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n            print(list(model))\n            &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n            # Skip Unset attributes\n            print(model.___dict___)\n            &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n            items = dict(model.items())\n            print(items)\n            &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n            ```\n        \"\"\"\n        return iter(\n            k for k, v in self.__dict__.items() \n            if v is not Unset \n            and not k.startswith(\"_\")\n        )\n\n    def __len__(self) -&gt; int:\n        return len([i for i in self])\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n        Note:\n            All Models are still mutable, but their ID value is unique\n\n        Returns:\n            int: The hash value of the model instance\n\n        Example:\n            ```python\n            board_map = {\n                Board(name=\"Board 1\"): board.,\n                Board(name=\"Board 2\"): \"Board 2\"\n            }\n            &gt;&gt;&gt; 1\n            ```\n        \"\"\"\n        if hasattr(self, 'id'):\n            return int(self.id)\n\n        # Default hash if no id (string of name and attributes)\n        return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n\n    def __eq__(self, other: Model) -&gt; bool:\n        \"\"\"Check if two model instances are equal\n\n        Note:\n            Compares the hash and class of the model instances\n\n        Warning:\n            Does not compare the attributes of the model instances, out of sync models\n            with different attributes can still be equal, it's best to refresh the models\n            before comparing.\n\n        Args:\n            other (Model): The other model instance to compare\n\n        Returns:\n            bool: True if the model instances are equal, False otherwise\n        \"\"\"\n        return isinstance(other, self.__class__) and hash(self) == hash(other)\n\n    def update(self): \n        \"\"\"Update the model instance\n        Note:\n            Method is implemented in the child classes, but is not required\n        \"\"\"\n        ...\n\n    def refresh(self): \n        \"\"\"\"Refresh the model instance\n        Note:\n            Method is implemented in the child classes, but is not required\n        \"\"\"\n        ...\n\n    def delete(self): \n        \"\"\"Delete the model instance\n        Note:\n            Method is implemented in the child classes, but is not required\n        \"\"\"\n        ...\n\n    @contextmanager\n    def editor(self) -&gt; Generator[Self, None, None]:\n        \"\"\"Context manager for editing the model\n\n        Example:\n            ```python\n            print(model.name)\n            &gt;&gt;&gt; \"Old Name\"\n            with model.editor() as m:\n                m.name = \"New Name\"\n                m.position = 1\n\n            print(model.name)\n            &gt;&gt;&gt; \"New Name\"\n            ```\n\n        \"\"\"\n        try:\n            self.refresh()\n            _self = self.__dict__.copy() # Backup the model state\n            yield self\n        except Exception as e:\n            self.__dict__ = _self # Restore the model state\n            raise e\n        finally:\n            self.update()\n</code></pre>"},{"location":"models/models/#plankapy.models.Model.created_at","title":"<code>created_at</code>  <code>property</code>","text":"<p>Get the creation date of the model instance</p> <p>Returns:</p> Type Description <code>Optional[datetime]</code> <p>Optional[datetime]: The creation date of the model instance</p>"},{"location":"models/models/#plankapy.models.Model.deleted_at","title":"<code>deleted_at</code>  <code>property</code>","text":"<p>Get the deletion date of the model instance</p> <p>Returns:</p> Type Description <code>Optional[datetime]</code> <p>Optional[datetime]: The deletion date of the model instance</p>"},{"location":"models/models/#plankapy.models.Model.link","title":"<code>link</code>  <code>property</code>","text":"<p>Get the link to the model instance</p> Note <p>Only <code>Project</code>, <code>Board</code>, and <code>Card</code> models have links.</p> <p>All other models return <code>None</code></p> <p>Returns:</p> Name Type Description <code>str</code> <code>str | None</code> <p>The link to the model instance</p>"},{"location":"models/models/#plankapy.models.Model.routes","title":"<code>routes</code>  <code>property</code> <code>writable</code>","text":"<p>Get the routes for the model instance</p> <p>Returns:</p> Name Type Description <code>Routes</code> <code>Routes</code> <p>The routes bound to the model instance</p>"},{"location":"models/models/#plankapy.models.Model.unique_name","title":"<code>unique_name</code>  <code>property</code>","text":"<p>Generate a unique name for the model instance using the last 5 characters of the id and the name attribute</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The unique name for the model instance in the format {name}_{id[:-5]}</p>"},{"location":"models/models/#plankapy.models.Model.updated_at","title":"<code>updated_at</code>  <code>property</code>","text":"<p>Get the last update date of the model instance</p> <p>Returns:</p> Type Description <code>Optional[datetime]</code> <p>Optional[datetime]: The last update date of the model instance</p>"},{"location":"models/models/#plankapy.models.Model.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check if two model instances are equal</p> Note <p>Compares the hash and class of the model instances</p> Warning <p>Does not compare the attributes of the model instances, out of sync models with different attributes can still be equal, it's best to refresh the models before comparing.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Model</code> <p>The other model instance to compare</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the model instances are equal, False otherwise</p> Source code in <code>src/plankapy/models.py</code> <pre><code>def __eq__(self, other: Model) -&gt; bool:\n    \"\"\"Check if two model instances are equal\n\n    Note:\n        Compares the hash and class of the model instances\n\n    Warning:\n        Does not compare the attributes of the model instances, out of sync models\n        with different attributes can still be equal, it's best to refresh the models\n        before comparing.\n\n    Args:\n        other (Model): The other model instance to compare\n\n    Returns:\n        bool: True if the model instances are equal, False otherwise\n    \"\"\"\n    return isinstance(other, self.__class__) and hash(self) == hash(other)\n</code></pre>"},{"location":"models/models/#plankapy.models.Model.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Get the value of an attribute</p> Warning <p>This is an implementation detail that allows for the unpacking operations in the rest of the codebase, all model attributes are still directly accessible through <code>__getattribute___</code></p> Note <p>Returns None if the attribute is <code>Unset</code> or starts with an underscore</p> Example <pre><code>print(model['name'])\n&gt;&gt;&gt; \"Model Name\"\n\nmodel.name = Unset\nprint(model['name'])\n&gt;&gt;&gt; None\n</code></pre> Source code in <code>src/plankapy/models.py</code> <pre><code>def __getitem__(self, key) -&gt; Any:\n    \"\"\"Get the value of an attribute\n\n    Warning:\n        This is an implementation detail that allows for the unpacking operations\n        in the rest of the codebase, all model attributes are still directly accessible\n        through `__getattribute___`\n\n    Note:\n        Returns None if the attribute is `Unset` or starts with an underscore\n\n    Example:\n        ```python\n        print(model['name'])\n        &gt;&gt;&gt; \"Model Name\"\n\n        model.name = Unset\n        print(model['name'])\n        &gt;&gt;&gt; None\n        ```\n    \"\"\"\n    val = self.__dict__[key]\n    return val if val is not Unset else None\n</code></pre>"},{"location":"models/models/#plankapy.models.Model.__hash__","title":"<code>__hash__()</code>","text":"<p>Generate a hash for the model instance so it can be used in mappings (<code>dict</code>, <code>set</code>)</p> Note <p>All Models are still mutable, but their ID value is unique</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The hash value of the model instance</p> Example <pre><code>board_map = {\n    Board(name=\"Board 1\"): board.,\n    Board(name=\"Board 2\"): \"Board 2\"\n}\n&gt;&gt;&gt; 1\n</code></pre> Source code in <code>src/plankapy/models.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Generate a hash for the model instance so it can be used in mappings (`dict`, `set`)\n\n    Note:\n        All Models are still mutable, but their ID value is unique\n\n    Returns:\n        int: The hash value of the model instance\n\n    Example:\n        ```python\n        board_map = {\n            Board(name=\"Board 1\"): board.,\n            Board(name=\"Board 2\"): \"Board 2\"\n        }\n        &gt;&gt;&gt; 1\n        ```\n    \"\"\"\n    if hasattr(self, 'id'):\n        return int(self.id)\n\n    # Default hash if no id (string of name and attributes)\n    return hash(f\"{self.__class__.__name__}{self.__dict__}\")\n</code></pre>"},{"location":"models/models/#plankapy.models.Model.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over public, assigned model attribute names</p> Warning <p>This is used in conjunction with <code>__getitem__</code> to unpack assigned values.  This allows model state to be passed as keyword arguments to functions</p> <p>Example:     <pre><code>model = Model(name=\"Model Name\", position=1, other=Unset)\n\ndef func(name=None, position=None):\n    return {\"name\": name, \"position\": position}\n\nprint(func(**model))\n&gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n</code></pre> Notice how only the assigned values are returned after unpacking and any Unset or  private attributes are skipped, This allows <code>None</code> values to be assigned during a <code>PATCH</code> request to delete data </p> Note <p>Skips attributes that are <code>Unset</code> or start with an underscore</p> <p>Returns:</p> Name Type Description <code>Iterator</code> <p>The iterator of the model attributes</p> Example <pre><code># Skip Private attributes\nprint(list(model.__dict__))\n&gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\nprint(list(model))\n&gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n# Skip Unset attributes\nprint(model.___dict___)\n&gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\nitems = dict(model.items())\nprint(items)\n&gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n</code></pre> Source code in <code>src/plankapy/models.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over public, assigned model attribute names\n\n    Warning:\n        This is used in conjunction with `__getitem__` to unpack assigned values. \n        This allows model state to be passed as keyword arguments to functions\n\n        Example:\n            ```python\n            model = Model(name=\"Model Name\", position=1, other=Unset)\n\n            def func(name=None, position=None):\n                return {\"name\": name, \"position\": position}\n\n            print(func(**model))\n            &gt;&gt;&gt; {'name': 'Model Name', 'position': 1}\n            ```\n        Notice how only the assigned values are returned after unpacking and any Unset or \n        private attributes are skipped, This allows `None` values to be assigned during\n        a `PATCH` request to delete data \n\n    Note:\n        Skips attributes that are `Unset` or start with an underscore\n\n    Returns:\n        Iterator: The iterator of the model attributes\n\n    Example:\n        ```python\n\n        # Skip Private attributes\n        print(list(model.__dict__))\n        &gt;&gt;&gt; ['_privateattribute', 'name', 'position', 'id']\n\n        print(list(model))\n        &gt;&gt;&gt; ['name', 'position', 'id'] # Skips _privateattribute\n\n        # Skip Unset attributes\n        print(model.___dict___)\n        &gt;&gt;&gt; {'_privateattribute': 'Private', 'name': 'Model Name', 'position': Unset, 'id': 1}\n\n        items = dict(model.items())\n        print(items)\n        &gt;&gt;&gt; {'name': 'Model Name', 'id': 1} # Skips position because it's Unset\n        ```\n    \"\"\"\n    return iter(\n        k for k, v in self.__dict__.items() \n        if v is not Unset \n        and not k.startswith(\"_\")\n    )\n</code></pre>"},{"location":"models/models/#plankapy.models.Model.bind","title":"<code>bind(routes)</code>","text":"<p>Bind routes to the model Args:     routes (Routes): The routes to bind to the model instance</p> <p>Returns:</p> Type Description <code>Self</code> <p>Self for chain operations</p> Example <pre><code>model = Model(**kwargs).bind(routes)\n</code></pre> Source code in <code>src/plankapy/models.py</code> <pre><code>def bind(self, routes: Routes) -&gt; Self:\n    \"\"\"Bind routes to the model\n    Args:\n        routes (Routes): The routes to bind to the model instance\n\n    Returns:\n        Self for chain operations\n\n    Example:\n        ```python\n        model = Model(**kwargs).bind(routes)\n        ```\n    \"\"\"\n    self.routes = routes\n    return self\n</code></pre>"},{"location":"models/models/#plankapy.models.Model.delete","title":"<code>delete()</code>","text":"<p>Delete the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/models.py</code> <pre><code>def delete(self): \n    \"\"\"Delete the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"models/models/#plankapy.models.Model.editor","title":"<code>editor()</code>","text":"<p>Context manager for editing the model</p> Example <pre><code>print(model.name)\n&gt;&gt;&gt; \"Old Name\"\nwith model.editor() as m:\n    m.name = \"New Name\"\n    m.position = 1\n\nprint(model.name)\n&gt;&gt;&gt; \"New Name\"\n</code></pre> Source code in <code>src/plankapy/models.py</code> <pre><code>@contextmanager\ndef editor(self) -&gt; Generator[Self, None, None]:\n    \"\"\"Context manager for editing the model\n\n    Example:\n        ```python\n        print(model.name)\n        &gt;&gt;&gt; \"Old Name\"\n        with model.editor() as m:\n            m.name = \"New Name\"\n            m.position = 1\n\n        print(model.name)\n        &gt;&gt;&gt; \"New Name\"\n        ```\n\n    \"\"\"\n    try:\n        self.refresh()\n        _self = self.__dict__.copy() # Backup the model state\n        yield self\n    except Exception as e:\n        self.__dict__ = _self # Restore the model state\n        raise e\n    finally:\n        self.update()\n</code></pre>"},{"location":"models/models/#plankapy.models.Model.json","title":"<code>json()</code>","text":"<p>Dump the model properties to a JSON string</p> Note <p>Only properties defined in the <code>{Model}_</code> dataclass are dumped.  All relationships and included items (e.g. <code>board.cards</code>) are lost. If you wish to preserve these relationships, use the <code>.pickle</code> method</p> <p>Returns:</p> Type Description <code>str</code> <p>(str) : A JSON string with the Model attributes</p> Source code in <code>src/plankapy/models.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"Dump the model properties to a JSON string\n\n    Note:\n        Only properties defined in the `{Model}_` dataclass are dumped. \n        All relationships and included items (e.g. `board.cards`) are lost.\n        If you wish to preserve these relationships, use the `.pickle` method\n\n    Returns:\n        (str) : A JSON string with the Model attributes\n    \"\"\"\n    return json.dumps({k: self[k] for k in self})\n</code></pre>"},{"location":"models/models/#plankapy.models.Model.pickle","title":"<code>pickle()</code>","text":"<p>Pickle the model, preserving as much of its state as possible</p> Warning <p>This method currently works, and since the object data is updated by routes You can use this to store a reference to a specific object. The data will be maintained until operations that trigger a <code>.refresh()</code> call are made, e.g.  using the <code>.editor()</code> context.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>(bytes) : Raw bytes generated by <code>pickle.dump</code></p> Source code in <code>src/plankapy/models.py</code> <pre><code>def pickle(self) -&gt; bytes:\n    \"\"\"Pickle the model, preserving as much of its state as possible\n\n    Warning:\n        This method currently works, and since the object data is updated by routes\n        You can use this to store a reference to a specific object. The data will be\n        maintained until operations that trigger a `.refresh()` call are made, e.g. \n        using the `.editor()` context.\n\n    Returns:\n        (bytes) : Raw bytes generated by `pickle.dump`\n    \"\"\"\n    out = io.BufferedWriter(raw=io.BytesIO())\n    pickle.dump(self, out)\n    return out.raw.read()\n</code></pre>"},{"location":"models/models/#plankapy.models.Model.refresh","title":"<code>refresh()</code>","text":"<p>\"Refresh the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/models.py</code> <pre><code>def refresh(self): \n    \"\"\"\"Refresh the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"models/models/#plankapy.models.Model.update","title":"<code>update()</code>","text":"<p>Update the model instance Note:     Method is implemented in the child classes, but is not required</p> Source code in <code>src/plankapy/models.py</code> <pre><code>def update(self): \n    \"\"\"Update the model instance\n    Note:\n        Method is implemented in the child classes, but is not required\n    \"\"\"\n    ...\n</code></pre>"},{"location":"models/models/#plankapy.models.Notification_","title":"<code>Notification_</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Model</code></p> <p>Notification Model</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The ID of the notification</p> <code>isRead</code> <code>bool</code> <p>The read status of the notification</p> <code>userId</code> <code>int</code> <p>The ID of the user the notification is associated with</p> <code>actionId</code> <code>int</code> <p>The ID of the action the notification is associated with</p> <code>cardId</code> <code>int</code> <p>The ID of the card the notification is associated with</p> <code>createdAt</code> <code>datetime</code> <p>The creation date of the notification</p> <code>updatedAt</code> <code>datetime</code> <p>The last update date of the notification</p> Source code in <code>src/plankapy/models.py</code> <pre><code>@dataclass(eq=False)\nclass Notification_(Model):\n    \"\"\"Notification Model\n\n    Attributes:\n        id (int): The ID of the notification\n        isRead (bool): The read status of the notification\n        userId (int): The ID of the user the notification is associated with\n        actionId (int): The ID of the action the notification is associated with\n        cardId (int): The ID of the card the notification is associated with\n        createdAt (datetime): The creation date of the notification\n        updatedAt (datetime): The last update date of the notification\n    \"\"\"\n    id: Optional[int]=Unset\n    isRead: bool=Required\n    userId: Optional[int]=Required\n    actionId: Optional[int]=Required\n    cardId: Optional[int]=Required\n    createdAt: Optional[str]=Unset\n    updatedAt: Optional[str]=Unset\n</code></pre>"},{"location":"models/models/#plankapy.models.ProjectManager_","title":"<code>ProjectManager_</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Model</code></p> <p>Project Manager Model</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The ID of the project manager</p> <code>projectId</code> <code>int</code> <p>The ID of the project the manager is associated with</p> <code>userId</code> <code>int</code> <p>The ID of the user the manager is associated with</p> <code>createdAt</code> <code>datetime</code> <p>The creation date of the project manager</p> <code>updatedAt</code> <code>datetime</code> <p>The last update date of the project manager</p> Source code in <code>src/plankapy/models.py</code> <pre><code>@dataclass(eq=False)\nclass ProjectManager_(Model):\n    \"\"\"Project Manager Model\n\n    Attributes:\n        id (int): The ID of the project manager\n        projectId (int): The ID of the project the manager is associated with\n        userId (int): The ID of the user the manager is associated with\n        createdAt (datetime): The creation date of the project manager\n        updatedAt (datetime): The last update date of the project manager\n    \"\"\"\n    id: Optional[int]=Unset\n    projectId: Optional[int]=Required\n    userId: Optional[int]=Required\n    createdAt: Optional[str]=Unset\n    updatedAt: Optional[str]=Unset\n</code></pre>"},{"location":"models/models/#plankapy.models.Project_","title":"<code>Project_</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Model</code></p> <p>Project Model</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The ID of the project</p> <code>name</code> <code>str</code> <p>The name of the project</p> <code>background</code> <code>Background</code> <p>The background of the project</p> <code>backgroundImage</code> <code>BackgroundImage</code> <p>The background image of the project</p> <code>createdAt</code> <code>datetime</code> <p>The creation date of the project</p> <code>updatedAt</code> <code>datetime</code> <p>The last update date of the project</p> Source code in <code>src/plankapy/models.py</code> <pre><code>@dataclass(eq=False)\nclass Project_(Model):\n    \"\"\"Project Model\n\n    Attributes:\n        id (int): The ID of the project\n        name (str): The name of the project\n        background (Background): The background of the project\n        backgroundImage (BackgroundImage): The background image of the project\n        createdAt (datetime): The creation date of the project\n        updatedAt (datetime): The last update date of the project\n    \"\"\"\n    id: Optional[int]=Unset\n    name: Optional[str]=Required\n    # Background overrides backgroundImage\n    background: Optional[dict]=Unset\n    backgroundImage: Optional[BackgroundImage]=Unset\n    createdAt: Optional[str]=Unset\n    updatedAt: Optional[str]=Unset\n</code></pre>"},{"location":"models/models/#plankapy.models.QueryableList","title":"<code>QueryableList</code>","text":"<p>               Bases: <code>list[M]</code>, <code>Generic[M]</code></p> <p>A list of Queryable objects</p> <p>This class is a subclass of the built-in <code>list</code> class that allows for querying the list of objects.</p> Source code in <code>src/plankapy/models.py</code> <pre><code>class QueryableList(list[M], Generic[M]):\n    \"\"\"A list of Queryable objects\n\n    This class is a subclass of the built-in `list` class that allows for querying the list of objects.\n\n    \"\"\"\n\n    def filter_where(self, **kwargs) -&gt; QueryableList[M] | None:\n        \"\"\"Filter the list of objects by keyword arguments\n\n        Args:\n            **kwargs: See Model for the available attributes\n\n        Returns:\n            QueryableList[M]: The objects that match the filter or None if no objects match\n\n        Example:\n        ```python\n        &gt;&gt;&gt; users = QueryableList(project.users)\n        &gt;&gt;&gt; users\n        [User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Bob')]\n\n        &gt;&gt;&gt; users.filter_where(name='Bob')\n        [User(id=1, name='Bob'), User(id=3, name='Bob')]\n        ```\n        \"\"\"\n        return QueryableList(item for item in self if all(getattr(item, key) == value for key, value in kwargs.items())) or None\n\n    def select_where(self, predicate: Callable[[M], bool]) -&gt; QueryableList[M]:\n        \"\"\"Select objects from the list that match a function\n\n        Args:\n            predicate: A function that takes an object and returns a boolean\n\n        Returns:\n            QueryableList[M]: The objects that match the function\n\n        Example:\n        ```python\n        &gt;&gt;&gt; users = QueryableList(project.users)\n        &gt;&gt;&gt; users\n        [User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Frank')]\n\n        &gt;&gt;&gt; users = users.select_where(lambda x: x.name in ('Bob', 'Alice'))\n        &gt;&gt;&gt; users\n        [User(id=1, name='Bob'), User(id=2, name='Alice')]\n        ```\n        \"\"\"\n        return QueryableList(item for item in self if predicate(item))\n\n    def pop_where(self, **kwargs) -&gt; M | None:\n        \"\"\"Get the first object that matches the filter\n\n        Args:\n            **kwargs: Keyword arguments to filter the list by\n\n        Returns:\n            M: The first object that matches the filter\n\n        Example:\n        ```python\n        &gt;&gt;&gt; users = QueryableList(project.users)\n        &gt;&gt;&gt; users\n        [User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Bob')]\n\n        &gt;&gt;&gt; users.pop_where(name='Bob')\n        User(id=1, name='Bob')\n\n        &gt;&gt;&gt; user = users.pop_where(name='Frank')\n        &gt;&gt;&gt; user\n        None\n        ```\n        \"\"\"\n        vals = self.filter_where(**kwargs)\n        return vals[0] if vals else None\n\n    def order_by(self, key: str, desc: bool=False) -&gt; QueryableList[M]:\n        \"\"\"Order the list by a key\n\n        Args:\n            key (str): The key to order by\n            desc (bool): True to order in descending order, False otherwise\n\n        Returns:\n            QueryableList[M]: The list of objects ordered by the key\n\n        Example:\n        ```python\n        &gt;&gt;&gt; users = QueryableList(project.users)\n        &gt;&gt;&gt; users\n        [User(name='Bob'), User(name='Alice')]\n\n        &gt;&gt;&gt; users = users.order_by('name')\n        &gt;&gt;&gt; users\n        [User(name='Alice'), User(name='Bob')]\n\n        &gt;&gt;&gt; users = users.order_by('name', desc=True)\n        &gt;&gt;&gt; users\n        [User(name='Bob'), User(name='Alice')]\n        ```\n        \"\"\"\n        return QueryableList(sorted(self, key=lambda x: getattr(x, key), reverse=desc))\n\n    def take(self, n: int) -&gt; QueryableList[M]:\n        \"\"\"Take the first n objects from the list\n\n        Args:\n            n (int): The number of objects to take\n\n        Returns:\n            QueryableList[M]: The first n objects in the list, if n is greater than the length of the list, the list is padded with `None`\n\n        Example:\n        ```python\n        &gt;&gt;&gt; users = QueryableList(project.users)\n        &gt;&gt;&gt; users.take(2)\n        [User(name='Alice'), User(name='Bob')]\n\n        &gt;&gt;&gt; users.take(3)\n        [User(name='Alice'), User(name='Bob'), None]\n        ```\n        \"\"\"\n        if n &gt; len(self):\n            return self + [None] * (n - len(self))\n        return self[:n]\n</code></pre>"},{"location":"models/models/#plankapy.models.QueryableList.filter_where","title":"<code>filter_where(**kwargs)</code>","text":"<p>Filter the list of objects by keyword arguments</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>See Model for the available attributes</p> <code>{}</code> <p>Returns:</p> Type Description <code>QueryableList[M] | None</code> <p>QueryableList[M]: The objects that match the filter or None if no objects match</p> <p>Example: <pre><code>&gt;&gt;&gt; users = QueryableList(project.users)\n&gt;&gt;&gt; users\n[User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Bob')]\n\n&gt;&gt;&gt; users.filter_where(name='Bob')\n[User(id=1, name='Bob'), User(id=3, name='Bob')]\n</code></pre></p> Source code in <code>src/plankapy/models.py</code> <pre><code>def filter_where(self, **kwargs) -&gt; QueryableList[M] | None:\n    \"\"\"Filter the list of objects by keyword arguments\n\n    Args:\n        **kwargs: See Model for the available attributes\n\n    Returns:\n        QueryableList[M]: The objects that match the filter or None if no objects match\n\n    Example:\n    ```python\n    &gt;&gt;&gt; users = QueryableList(project.users)\n    &gt;&gt;&gt; users\n    [User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Bob')]\n\n    &gt;&gt;&gt; users.filter_where(name='Bob')\n    [User(id=1, name='Bob'), User(id=3, name='Bob')]\n    ```\n    \"\"\"\n    return QueryableList(item for item in self if all(getattr(item, key) == value for key, value in kwargs.items())) or None\n</code></pre>"},{"location":"models/models/#plankapy.models.QueryableList.order_by","title":"<code>order_by(key, desc=False)</code>","text":"<p>Order the list by a key</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to order by</p> required <code>desc</code> <code>bool</code> <p>True to order in descending order, False otherwise</p> <code>False</code> <p>Returns:</p> Type Description <code>QueryableList[M]</code> <p>QueryableList[M]: The list of objects ordered by the key</p> <p>Example: <pre><code>&gt;&gt;&gt; users = QueryableList(project.users)\n&gt;&gt;&gt; users\n[User(name='Bob'), User(name='Alice')]\n\n&gt;&gt;&gt; users = users.order_by('name')\n&gt;&gt;&gt; users\n[User(name='Alice'), User(name='Bob')]\n\n&gt;&gt;&gt; users = users.order_by('name', desc=True)\n&gt;&gt;&gt; users\n[User(name='Bob'), User(name='Alice')]\n</code></pre></p> Source code in <code>src/plankapy/models.py</code> <pre><code>def order_by(self, key: str, desc: bool=False) -&gt; QueryableList[M]:\n    \"\"\"Order the list by a key\n\n    Args:\n        key (str): The key to order by\n        desc (bool): True to order in descending order, False otherwise\n\n    Returns:\n        QueryableList[M]: The list of objects ordered by the key\n\n    Example:\n    ```python\n    &gt;&gt;&gt; users = QueryableList(project.users)\n    &gt;&gt;&gt; users\n    [User(name='Bob'), User(name='Alice')]\n\n    &gt;&gt;&gt; users = users.order_by('name')\n    &gt;&gt;&gt; users\n    [User(name='Alice'), User(name='Bob')]\n\n    &gt;&gt;&gt; users = users.order_by('name', desc=True)\n    &gt;&gt;&gt; users\n    [User(name='Bob'), User(name='Alice')]\n    ```\n    \"\"\"\n    return QueryableList(sorted(self, key=lambda x: getattr(x, key), reverse=desc))\n</code></pre>"},{"location":"models/models/#plankapy.models.QueryableList.pop_where","title":"<code>pop_where(**kwargs)</code>","text":"<p>Get the first object that matches the filter</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Keyword arguments to filter the list by</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>M</code> <code>M | None</code> <p>The first object that matches the filter</p> <p>Example: <pre><code>&gt;&gt;&gt; users = QueryableList(project.users)\n&gt;&gt;&gt; users\n[User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Bob')]\n\n&gt;&gt;&gt; users.pop_where(name='Bob')\nUser(id=1, name='Bob')\n\n&gt;&gt;&gt; user = users.pop_where(name='Frank')\n&gt;&gt;&gt; user\nNone\n</code></pre></p> Source code in <code>src/plankapy/models.py</code> <pre><code>def pop_where(self, **kwargs) -&gt; M | None:\n    \"\"\"Get the first object that matches the filter\n\n    Args:\n        **kwargs: Keyword arguments to filter the list by\n\n    Returns:\n        M: The first object that matches the filter\n\n    Example:\n    ```python\n    &gt;&gt;&gt; users = QueryableList(project.users)\n    &gt;&gt;&gt; users\n    [User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Bob')]\n\n    &gt;&gt;&gt; users.pop_where(name='Bob')\n    User(id=1, name='Bob')\n\n    &gt;&gt;&gt; user = users.pop_where(name='Frank')\n    &gt;&gt;&gt; user\n    None\n    ```\n    \"\"\"\n    vals = self.filter_where(**kwargs)\n    return vals[0] if vals else None\n</code></pre>"},{"location":"models/models/#plankapy.models.QueryableList.select_where","title":"<code>select_where(predicate)</code>","text":"<p>Select objects from the list that match a function</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[M], bool]</code> <p>A function that takes an object and returns a boolean</p> required <p>Returns:</p> Type Description <code>QueryableList[M]</code> <p>QueryableList[M]: The objects that match the function</p> <p>Example: <pre><code>&gt;&gt;&gt; users = QueryableList(project.users)\n&gt;&gt;&gt; users\n[User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Frank')]\n\n&gt;&gt;&gt; users = users.select_where(lambda x: x.name in ('Bob', 'Alice'))\n&gt;&gt;&gt; users\n[User(id=1, name='Bob'), User(id=2, name='Alice')]\n</code></pre></p> Source code in <code>src/plankapy/models.py</code> <pre><code>def select_where(self, predicate: Callable[[M], bool]) -&gt; QueryableList[M]:\n    \"\"\"Select objects from the list that match a function\n\n    Args:\n        predicate: A function that takes an object and returns a boolean\n\n    Returns:\n        QueryableList[M]: The objects that match the function\n\n    Example:\n    ```python\n    &gt;&gt;&gt; users = QueryableList(project.users)\n    &gt;&gt;&gt; users\n    [User(id=1, name='Bob'), User(id=2, name='Alice'), User(id=3, name='Frank')]\n\n    &gt;&gt;&gt; users = users.select_where(lambda x: x.name in ('Bob', 'Alice'))\n    &gt;&gt;&gt; users\n    [User(id=1, name='Bob'), User(id=2, name='Alice')]\n    ```\n    \"\"\"\n    return QueryableList(item for item in self if predicate(item))\n</code></pre>"},{"location":"models/models/#plankapy.models.QueryableList.take","title":"<code>take(n)</code>","text":"<p>Take the first n objects from the list</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of objects to take</p> required <p>Returns:</p> Type Description <code>QueryableList[M]</code> <p>QueryableList[M]: The first n objects in the list, if n is greater than the length of the list, the list is padded with <code>None</code></p> <p>Example: <pre><code>&gt;&gt;&gt; users = QueryableList(project.users)\n&gt;&gt;&gt; users.take(2)\n[User(name='Alice'), User(name='Bob')]\n\n&gt;&gt;&gt; users.take(3)\n[User(name='Alice'), User(name='Bob'), None]\n</code></pre></p> Source code in <code>src/plankapy/models.py</code> <pre><code>def take(self, n: int) -&gt; QueryableList[M]:\n    \"\"\"Take the first n objects from the list\n\n    Args:\n        n (int): The number of objects to take\n\n    Returns:\n        QueryableList[M]: The first n objects in the list, if n is greater than the length of the list, the list is padded with `None`\n\n    Example:\n    ```python\n    &gt;&gt;&gt; users = QueryableList(project.users)\n    &gt;&gt;&gt; users.take(2)\n    [User(name='Alice'), User(name='Bob')]\n\n    &gt;&gt;&gt; users.take(3)\n    [User(name='Alice'), User(name='Bob'), None]\n    ```\n    \"\"\"\n    if n &gt; len(self):\n        return self + [None] * (n - len(self))\n    return self[:n]\n</code></pre>"},{"location":"models/models/#plankapy.models.Stopwatch","title":"<code>Stopwatch</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Model</code></p> <p>Stopwatch Model</p> Note <p>The stopwatch model is not a regular interface and instead is dynamically generated on Access through the <code>Card</code> <code>.stopwatch</code> attribute. There is an override that intercepts <code>__getitem__</code> to return a <code>Stopwatch</code>. </p> <p>All <code>Stopwatch</code> methods directly update the <code>.stopwatch</code> attribute of the linked <code>Card</code>  instance.</p> <p>Attributes:</p> Name Type Description <code>startedAt</code> <code>datetime</code> <p>The start date of the stopwatch</p> <code>total</code> <code>int</code> <p>The total time of the stopwatch (in seconds)</p> <code>_card</code> <code>Card</code> <p>The card the stopwatch is associated with (Managed by the <code>Card</code> class)</p> Source code in <code>src/plankapy/models.py</code> <pre><code>@dataclass(eq=False)\nclass Stopwatch(Model):\n    \"\"\"Stopwatch Model\n\n    Note:\n        The stopwatch model is not a regular interface and instead is dynamically generated on\n        Access through the `Card` `.stopwatch` attribute. There is an override that intercepts\n        `__getitem__` to return a `Stopwatch`. \n\n        All `Stopwatch` methods directly update the `.stopwatch` attribute of the linked `Card` \n        instance.\n\n    Attributes:\n        startedAt (datetime): The start date of the stopwatch\n        total (int): The total time of the stopwatch (in seconds)\n        _card (Card): The card the stopwatch is associated with (Managed by the `Card` class)\n    \"\"\"\n    _card: Optional[Card_]=Unset\n    startedAt: Optional[str]=Unset\n    total: Optional[int]=Unset\n\n    def refresh(self):\n        self._card.refresh()\n        self.startedAt = self._card.stopwatch.startedAt\n        self.total = self._card.stopwatch.total\n\n    def start_time(self) -&gt; datetime:\n        \"\"\"Returns the datetime the stopwatch was started\"\"\"\n        self.refresh()\n        return datetime.fromisoformat(self.startedAt) if self.startedAt else None\n\n    def start(self) -&gt; None:\n        \"\"\"Starts the stopwatch\"\"\"\n        self.refresh()\n        if self.startedAt:\n            return\n        self.startedAt = datetime.now().isoformat()\n        with self._card.editor():\n            self._card.stopwatch = self\n\n    def stop(self) -&gt; None:\n        \"\"\"Stops the stopwatch\"\"\"\n        self.refresh()\n        if not self.startedAt:\n            return\n\n        now = datetime.now()\n        started = datetime.fromisoformat(self.startedAt)\n        self.total += int(now.timestamp() - started.timestamp())\n        self.startedAt = None\n        with self._card.editor():\n            self._card.stopwatch = self\n\n    def set(self, hours: int=0, minutes: int=0, seconds: int=0) -&gt; None:\n        \"\"\"Set an amount of time for the stopwatch\n\n        Args:\n            hours (int): Hours to set\n            minutes (int): Minutes to set\n            seconds (int): Seconds to set\n        \"\"\"\n        self.total = (hours * 3600) + (minutes * 60) + seconds\n        with self._card.editor():\n            self._card.stopwatch = self\n</code></pre>"},{"location":"models/models/#plankapy.models.Stopwatch.set","title":"<code>set(hours=0, minutes=0, seconds=0)</code>","text":"<p>Set an amount of time for the stopwatch</p> <p>Parameters:</p> Name Type Description Default <code>hours</code> <code>int</code> <p>Hours to set</p> <code>0</code> <code>minutes</code> <code>int</code> <p>Minutes to set</p> <code>0</code> <code>seconds</code> <code>int</code> <p>Seconds to set</p> <code>0</code> Source code in <code>src/plankapy/models.py</code> <pre><code>def set(self, hours: int=0, minutes: int=0, seconds: int=0) -&gt; None:\n    \"\"\"Set an amount of time for the stopwatch\n\n    Args:\n        hours (int): Hours to set\n        minutes (int): Minutes to set\n        seconds (int): Seconds to set\n    \"\"\"\n    self.total = (hours * 3600) + (minutes * 60) + seconds\n    with self._card.editor():\n        self._card.stopwatch = self\n</code></pre>"},{"location":"models/models/#plankapy.models.Stopwatch.start","title":"<code>start()</code>","text":"<p>Starts the stopwatch</p> Source code in <code>src/plankapy/models.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Starts the stopwatch\"\"\"\n    self.refresh()\n    if self.startedAt:\n        return\n    self.startedAt = datetime.now().isoformat()\n    with self._card.editor():\n        self._card.stopwatch = self\n</code></pre>"},{"location":"models/models/#plankapy.models.Stopwatch.start_time","title":"<code>start_time()</code>","text":"<p>Returns the datetime the stopwatch was started</p> Source code in <code>src/plankapy/models.py</code> <pre><code>def start_time(self) -&gt; datetime:\n    \"\"\"Returns the datetime the stopwatch was started\"\"\"\n    self.refresh()\n    return datetime.fromisoformat(self.startedAt) if self.startedAt else None\n</code></pre>"},{"location":"models/models/#plankapy.models.Stopwatch.stop","title":"<code>stop()</code>","text":"<p>Stops the stopwatch</p> Source code in <code>src/plankapy/models.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stops the stopwatch\"\"\"\n    self.refresh()\n    if not self.startedAt:\n        return\n\n    now = datetime.now()\n    started = datetime.fromisoformat(self.startedAt)\n    self.total += int(now.timestamp() - started.timestamp())\n    self.startedAt = None\n    with self._card.editor():\n        self._card.stopwatch = self\n</code></pre>"},{"location":"models/models/#plankapy.models.Task_","title":"<code>Task_</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Model</code></p> <p>Task Model</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The ID of the task</p> <code>name</code> <code>str</code> <p>The name of the task</p> <code>position</code> <code>int</code> <p>The position of the task</p> <code>isCompleted</code> <code>bool</code> <p>The completion status of the task</p> <code>cardId</code> <code>int</code> <p>The ID of the card the task is associated with</p> <code>createdAt</code> <code>datetime</code> <p>The creation date of the task</p> <code>updatedAt</code> <code>datetime</code> <p>The last update date of the task</p> Source code in <code>src/plankapy/models.py</code> <pre><code>@dataclass(eq=False)\nclass Task_(Model):\n    \"\"\"Task Model\n\n    Attributes:\n        id (int): The ID of the task\n        name (str): The name of the task\n        position (int): The position of the task\n        isCompleted (bool): The completion status of the task\n        cardId (int): The ID of the card the task is associated with\n        createdAt (datetime): The creation date of the task\n        updatedAt (datetime): The last update date of the task\n    \"\"\"\n    id: Optional[int]=Unset\n    name: Optional[str]=Required\n    position: Optional[int]=Required\n    isCompleted: bool=Unset\n    cardId: Optional[int]=Unset\n    createdAt: Optional[str]=Unset\n    updatedAt: Optional[str]=Unset\n</code></pre>"},{"location":"models/models/#plankapy.models.User_","title":"<code>User_</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Model</code></p> <p>User Model</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The ID of the user</p> <code>name</code> <code>str</code> <p>The name of the user</p> <code>username</code> <code>str</code> <p>The username of the user</p> <code>email</code> <code>str</code> <p>The email of the user</p> <code>language</code> <code>str</code> <p>The language of the user</p> <code>organization</code> <code>str</code> <p>The organization of the user</p> <code>phone</code> <code>str</code> <p>The phone of the user</p> <code>avatarUrl</code> <code>str</code> <p>The avatar URL of the user</p> <code>isSso</code> <code>bool</code> <p>The SSO status of the user</p> <code>isAdmin</code> <code>bool</code> <p>The admin status of the user</p> <code>isDeletionLocked</code> <code>bool</code> <p>The deletion lock status of the user</p> <code>isLocked</code> <code>bool</code> <p>The lock status of the user</p> <code>isRoleLocked</code> <code>bool</code> <p>The role lock status of the user</p> <code>isUsernameLocked</code> <code>bool</code> <p>The username lock status of the user</p> <code>subscribeToOwnCards</code> <code>bool</code> <p>The subscription status of the user</p> <code>createdAt</code> <code>datetime</code> <p>The creation date of the user</p> <code>updatedAt</code> <code>datetime</code> <p>The last update date of the user</p> <code>deletedAt</code> <code>datetime</code> <p>The deletion date of the user</p> Source code in <code>src/plankapy/models.py</code> <pre><code>@dataclass(eq=False)\nclass User_(Model):\n    \"\"\"User Model\n\n    Attributes:\n        id (int): The ID of the user\n        name (str): The name of the user\n        username (str): The username of the user\n        email (str): The email of the user\n        language (str): The language of the user\n        organization (str): The organization of the user\n        phone (str): The phone of the user\n        avatarUrl (str): The avatar URL of the user\n        isSso (bool): The SSO status of the user\n        isAdmin (bool): The admin status of the user\n        isDeletionLocked (bool): The deletion lock status of the user\n        isLocked (bool): The lock status of the user\n        isRoleLocked (bool): The role lock status of the user\n        isUsernameLocked (bool): The username lock status of the user\n        subscribeToOwnCards (bool): The subscription status of the user\n        createdAt (datetime): The creation date of the user\n        updatedAt (datetime): The last update date of the user\n        deletedAt (datetime): The deletion date of the user\n    \"\"\"\n    id: Optional[int]=Unset\n    name: Optional[str]=Required\n    username: Optional[str]=Unset\n    email: Optional[str]=Required\n    language: Optional[str]=Unset\n    organization: Optional[str]=Unset\n    phone: Optional[str]=Unset\n    avatarUrl: Optional[str]=Unset\n    isSso: Optional[bool]=Unset\n    isAdmin: bool=Unset\n    isDeletionLocked: bool=Unset\n    isLocked: bool=Unset\n    isRoleLocked: bool=Unset\n    isUsernameLocked: bool=Unset\n    subscribeToOwnCards: bool=Unset\n    createdAt: Optional[str]=Unset\n    updatedAt: Optional[str]=Unset\n    deletedAt: Optional[str]=Unset\n</code></pre>"},{"location":"routes/routes/","title":"Routes","text":""},{"location":"routes/routes/#plankapy.routes.Route","title":"<code>Route</code>","text":"<p>Wraps a JSONHandler method with a specific HTTP method and endpoint. On call, it delegates the request to the wrapped method.</p> <p>Usage:</p> <p>route = Route('GET', '/api/projects', handler) route()  Source code in <code>src/plankapy/routes.py</code> <pre><code>class Route:\n    \"\"\"Wraps a JSONHandler method with a specific HTTP method and endpoint.\n    On call, it delegates the request to the wrapped method.\n\n    Usage:\n    &gt;&gt;&gt; route = Route('GET', '/api/projects', handler)\n    &gt;&gt;&gt; route()\n    &lt;JSONResponse&gt;\n    \"\"\"\n\n    RequestType: TypeAlias = Literal['GET', 'POST', 'PATCH', 'PUT', 'DELETE']\n\n    def __init__(self, method: RequestType, endpoint: str, handler: JSONHandler):\n        self.handler = handler\n        self.method = method\n        self.endpoint = endpoint\n\n    @property\n    def url(self):\n        return self.handler.base_url + self.endpoint\n\n    def __call__(self, **data) -&gt; JSONHandler.JSONResponse:\n        with self.handler.endpoint_as(self.endpoint):\n            if self.method == 'GET':\n                return self.handler.get()\n\n            elif self.method == 'POST':\n                return self.handler.post(data)\n\n            elif self.method == 'PATCH':\n                return self.handler.patch(data)\n\n            elif self.method == 'PUT':\n                return self.handler.put(data)\n\n            elif self.method == 'DELETE':\n                return self.handler.delete()\n\n        return None\n\n    def __repr__(self):\n        return f'&lt;Route {self.method} {self.endpoint} for {self.handler}&gt;'\n\n    def __iter__(self):\n        if not self.method == 'GET':\n            raise ValueError('Only GET routes can be iterated')\n        return iter(self()['items'])\n</code></pre>"},{"location":"routes/routes/#plankapy.routes.Routes","title":"<code>Routes</code>","text":"<p>Container for all routes in the Planka API. Each method returns a Route object that can be called to make a request.</p> <p>Usage:</p> <p>routes = Routes(handler) route = routes.index() route()  <p>update_card = routes.cards_update(1) update_card(name='Updated name')  Source code in <code>src/plankapy/routes.py</code> <pre><code>class Routes:\n    \"\"\"Container for all routes in the Planka API.\n    Each method returns a Route object that can be called to make a request.\n\n    Usage:\n    &gt;&gt;&gt; routes = Routes(handler)\n    &gt;&gt;&gt; route = routes.index()\n    &gt;&gt;&gt; route()\n    &lt;JSONHandler.JSONResponse&gt;\n\n    &gt;&gt;&gt; update_card = routes.cards_update(1)\n    &gt;&gt;&gt; update_card(name='Updated name')\n    &lt;JSONHandler.JSONResponse&gt;\n    \"\"\"\n    def __init__(self, handler: JSONHandler) -&gt; None:\n        self.handler = handler\n\n    def register_route(method: Route.RequestType, endpoint: str):\n        def _wrapper(route):\n            @wraps(route)\n            def _wrapped(self, *args, **kwargs):\n                if args:\n                    arg_map = dict(zip(route.__annotations__.keys(), args))\n                    kwargs.update(arg_map)\n                return Route(method, endpoint.format(**kwargs), self.handler)\n            return _wrapped\n        return _wrapper\n\n    @register_route('GET', '/*')\n    def get_index(self) -&gt; Route: ...\n\n    @register_route('GET', '/api/users/me')\n    def get_me(self) -&gt; Route: ...\n\n    @register_route('GET', '/api/config')\n    def get_config(self) -&gt; Route: ...\n\n    @register_route('GET', '/api/boards/{id}')\n    def get_board(self, id: int) -&gt; Route: ...\n\n    @register_route('GET', '/api/cards/{cardId}/actions')\n    def get_action_index(self, cardId: int) -&gt; Route: ...\n\n    @register_route('GET', '/api/cards/{id}')\n    def get_card(self, id: int) -&gt; Route: ...\n\n    @register_route('GET', '/api/notifications')\n    def get_notification_index(self) -&gt; Route: ...\n\n    @register_route('GET', '/api/notifications/{id}')\n    def get_notification(self, id: int) -&gt; Route: ...\n\n    @register_route('GET', '/api/projects')\n    def get_project_index(self) -&gt; Route: ...\n\n    @register_route('GET', '/api/projects/{id}')\n    def get_project(self, id: int) -&gt; Route: ...\n\n    @register_route('GET', '/api/users')\n    def get_user_index(self) -&gt; Route: ...\n\n    @register_route('GET', '/api/users/{id}')\n    def get_user(self, id: int) -&gt; Route: ...\n\n    @register_route('GET', '/attachments/{id}/download/{filename}')\n    def get_attachment_download(self, id: int, filename: str) -&gt; Route: ...\n\n    @register_route('GET', '/attachments/{id}/download/thumbnails/cover-256.{extension}')\n    def get_attachment_download_thumbnail(self, id: int, extension: str) -&gt; Route: ...\n\n    @register_route('GET', '/project-background-images/*')\n    def get_project_background_images(self) -&gt; Route: ...\n\n    @register_route('GET', '/user-avatars/*')\n    def get_user_avatars(self) -&gt; Route: ...\n\n    @register_route('POST', '/api/access-tokens')\n    def post_access_tokens(self) -&gt; Route: ...\n\n    @register_route('POST', '/api/access-tokens/exchange-using-oidc')\n    def post_exchange_using_oidc(self) -&gt; Route: ...\n\n    @register_route('POST', '/api/boards/{boardId}/labels')\n    def post_label(self, boardId: int) -&gt; Route: ...\n\n    @register_route('POST', '/api/boards/{boardId}/lists')\n    def post_list(self, boardId: int) -&gt; Route: ...\n\n    @register_route('POST', '/api/boards/{boardId}/memberships')\n    def post_board_membership(self, boardId: int) -&gt; Route: ...\n\n    @register_route('POST', '/api/cards/{cardId}/attachments')\n    def post_attachment(self, cardId: int) -&gt; Route: ...\n\n    @register_route('POST', '/api/cards/{cardId}/comment-actions')\n    def post_comment_action(self, cardId: int) -&gt; Route: ...\n\n    @register_route('POST', '/api/cards/{cardId}/labels')\n    def post_card_label(self, cardId: int) -&gt; Route: ...\n\n    @register_route('POST', '/api/cards/{cardId}/memberships')\n    def post_card_membership(self, cardId: int) -&gt; Route: ...\n\n    @register_route('POST', '/api/cards/{cardId}/tasks')\n    def post_task(self, cardId: int) -&gt; Route: ...\n\n    @register_route('POST', '/api/cards/{id}/duplicate')\n    def post_duplicate_card(self, id: int) -&gt; Route: ...\n\n    @register_route('POST', '/api/lists/{id}/sort')\n    def post_sort_list(self, id: int) -&gt; Route: ...\n\n    @register_route('POST', '/api/lists/{id}/cards')\n    def post_card(self, id: int) -&gt; Route: ...\n\n    @register_route('POST', '/api/projects')\n    def post_project(self) -&gt; Route: ...\n\n    @register_route('POST', '/api/projects/{id}/background-image')\n    def post_project_background_image(self, id: int) -&gt; Route: ...\n\n    @register_route('POST', '/api/projects/{projectId}/boards')\n    def post_board(self, projectId: int) -&gt; Route: ...\n\n    @register_route('POST', '/api/projects/{projectId}/managers')\n    def post_project_manager(self, projectId: int) -&gt; Route: ...\n\n    @register_route('POST', '/api/users')\n    def post_user(self) -&gt; Route: ...\n\n    @register_route('POST', '/api/users/{id}/avatar')\n    def post_user_avatar(self, id: int) -&gt; Route: ...\n\n    @register_route('PUT', '/api/attachments/{id}')\n    def put_attachment(self, id: int) -&gt; Route: ...\n\n    @register_route('PUT', '/api/board-memberships/{id}')\n    def put_board_membership(self, id: int) -&gt; Route: ...\n\n    @register_route('PUT', '/api/boards/{id}')\n    def put_board(self, id: int) -&gt; Route: ...\n\n    @register_route('PUT', '/api/cards/{id}')\n    def put_card(self, id: int) -&gt; Route: ...\n\n    @register_route('PUT', '/api/comment-actions/{id}')\n    def put_comment_action(self, id: int) -&gt; Route: ...\n\n    @register_route('PUT', '/api/labels/{id}')\n    def put_label(self, id: int) -&gt; Route: ...\n\n    @register_route('PUT', '/api/lists/{id}')\n    def put_list(self, id: int) -&gt; Route: ...\n\n    @register_route('PUT', '/api/notifications/{ids}')\n    def put_notification(self, ids: str) -&gt; Route: ...\n\n    @register_route('PUT', '/api/projects/{id}')\n    def put_project(self, id: int) -&gt; Route: ...\n\n    @register_route('PUT', '/api/tasks/{id}')\n    def put_task(self, id: int) -&gt; Route: ...\n\n    @register_route('PUT', '/api/users/{id}')\n    def put_user(self, id: int) -&gt; Route: ...\n\n    @register_route('PUT', '/api/users/{id}/email')\n    def put_user_email(self, id: int) -&gt; Route: ...\n\n    @register_route('PUT', '/api/users/{id}/password')\n    def put_user_password(self, id: int) -&gt; Route: ...\n\n    @register_route('PUT', '/api/users/{id}/username')\n    def put_user_username(self, id: int) -&gt; Route: ...\n\n    @register_route('PATCH', '/api/attachments/{id}')\n    def patch_attachment(self, id: int) -&gt; Route: ...\n\n    @register_route('PATCH', '/api/board-memberships/{id}')\n    def patch_board_membership(self, id: int) -&gt; Route: ...\n\n    @register_route('PATCH', '/api/boards/{id}')\n    def patch_board(self, id: int) -&gt; Route: ...\n\n    @register_route('PATCH', '/api/cards/{id}')\n    def patch_card(self, id: int) -&gt; Route: ...\n\n    @register_route('PATCH', '/api/comment-actions/{id}')\n    def patch_comment_action(self, id: int) -&gt; Route: ...\n\n    @register_route('PATCH', '/api/labels/{id}')\n    def patch_label(self, id: int) -&gt; Route: ...\n\n    @register_route('PATCH', '/api/lists/{id}')\n    def patch_list(self, id: int) -&gt; Route: ...\n\n    @register_route('PATCH', '/api/notifications/{ids}')\n    def patch_notification(self, ids: str) -&gt; Route: ...\n\n    @register_route('PATCH', '/api/projects/{id}')\n    def patch_project(self, id: int) -&gt; Route: ...\n\n    @register_route('PATCH', '/api/tasks/{id}')\n    def patch_task(self, id: int) -&gt; Route: ...\n\n    @register_route('PATCH', '/api/users/{id}')\n    def patch_user(self, id: int) -&gt; Route: ...\n\n    @register_route('PATCH', '/api/users/{id}/email')\n    def patch_user_email(self, id: int) -&gt; Route: ...\n\n    @register_route('PATCH', '/api/users/{id}/password')\n    def patch_user_password(self, id: int) -&gt; Route: ...\n\n    @register_route('PATCH', '/api/users/{id}/username')\n    def patch_user_username(self, id: int) -&gt; Route: ...\n\n    @register_route('DELETE', '/api/access-tokens/me')\n    def delete_access_tokens(self) -&gt; Route: ...\n\n    @register_route('DELETE', '/api/attachments/{id}')\n    def delete_attachment(self, id: int) -&gt; Route: ...\n\n    @register_route('DELETE', '/api/board-memberships/{id}')\n    def delete_board_membership(self, id: int) -&gt; Route: ...\n\n    @register_route('DELETE', '/api/boards/{id}')\n    def delete_board(self, id: int) -&gt; Route: ...\n\n    @register_route('DELETE', '/api/cards/{cardId}/labels/{labelId}')\n    def delete_card_label(self, cardId: int, labelId: int) -&gt; Route: ...\n\n    @register_route('DELETE', '/api/cards/{cardId}/memberships')\n    def delete_card_membership(self, cardId: int) -&gt; Route: ...\n\n    @register_route('DELETE', '/api/cards/{id}')\n    def delete_card(self, id: int) -&gt; Route: ...\n\n    @register_route('DELETE', '/api/comment-actions/{id}')\n    def delete_comment_action(self, id: int) -&gt; Route: ...\n\n    @register_route('DELETE', '/api/labels/{id}')\n    def delete_label(self, id: int) -&gt; Route: ...\n\n    @register_route('DELETE', '/api/lists/{id}')\n    def delete_list(self, id: int) -&gt; Route: ...\n\n    @register_route('DELETE', '/api/project-managers/{id}')\n    def delete_project_manager(self, id: int) -&gt; Route: ...\n\n    @register_route('DELETE', '/api/projects/{id}')\n    def delete_project(self, id: int) -&gt; Route: ...\n\n    @register_route('DELETE', '/api/tasks/{id}')\n    def delete_task(self, id: int) -&gt; Route: ...\n\n    @register_route('DELETE', '/api/users/{id}')\n    def delete_user(self, id: int) -&gt; Route: ...\n</code></pre>"}]}